
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import com.sun.jna.ptr.PointerByReference;
import java.util.Arrays;
import java.util.List;
/**
 * <i>native declaration : /usr/include/libavformat/avformat.h:7922</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class AVStream extends Structure {
	/** < stream index in AVFormatContext */
	public int index;
	/** < format-specific stream ID */
	public int id;
	/**
	 * < codec context<br>
	 * C type : AVCodecContext*
	 */
	public AVCodecContext.ByReference codec;
	/**
	 * Real base framerate of the stream.<br>
	 * This is the lowest framerate with which all timestamps can be<br>
	 * represented accurately (it is the least common multiple of all<br>
	 * framerates in the stream). Note, this value is just a guess!<br>
	 * For example, if the time base is 1/90000 and all frames have either<br>
	 * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.<br>
	 * C type : AVRational
	 */
	public AVRational r_frame_rate;
	/** C type : void* */
	public Pointer priv_data;
	/** internal data used in av_find_stream_info() */
	public long first_dts;
	/**
	 * encoding: pts generation when outputting stream<br>
	 * C type : AVFrac
	 */
	public AVFrac pts;
	/**
	 * This is the fundamental unit of time (in seconds) in terms<br>
	 * of which frame timestamps are represented. For fixed-fps content,<br>
	 * time base should be 1/framerate and timestamp increments should be 1.<br>
	 * decoding: set by libavformat<br>
	 * encoding: set by libavformat in av_write_header<br>
	 * C type : AVRational
	 */
	public AVRational.ByValue time_base;
	/** < number of bits in pts (used for wrapping control) */
	public int pts_wrap_bits;
	/**
	 * ffmpeg.c private use<br>
	 * < If set, just copy stream.
	 */
	public int stream_copy;
	/**
	 * @see com.acuitus.wrapffmpeg.AvcodecLibrary#AVDiscard<br>
	 * < Selects which packets can be discarded at will and do not need to be demuxed.<br>
	 * C type : AVDiscard
	 */
	public int discard;
	/**
	 * Quality, as it has been removed from AVCodecContext and put in AVVideoFrame.<br>
	 * MN: dunno if that is the right place for it
	 */
	public float quality;
	/**
	 * Decoding: pts of the first frame of the stream, in stream time base.<br>
	 * Only set this if you are absolutely 100% sure that the value you set<br>
	 * it to really is the pts of the first frame.<br>
	 * This may be undefined (AV_NOPTS_VALUE).
	 */
	public long start_time;
	/**
	 * Decoding: duration of the stream, in stream time base.<br>
	 * If a source file does not specify a duration, but does specify<br>
	 * a bitrate, this value will be estimated from bitrate and file size.
	 */
	public long duration;
	/**
	 * av_read_frame() support<br>
	 * @see AVStreamParseType<br>
	 * C type : AVStreamParseType
	 */
	public int need_parsing;
	/** C type : AVCodecParserContext* */
	public AVCodecParserContext.ByReference parser;
	public long cur_dts;
	public int last_IP_duration;
	public long last_IP_pts;
	/**
	 * av_seek_frame() support<br>
	 * < Only used if the format does not<br>
	 * support seeking natively.<br>
	 * C type : AVIndexEntry*
	 */
	public AVIndexEntry.ByReference index_entries;
	public int nb_index_entries;
	public int index_entries_allocated_size;
	/** < number of frames in this stream if known or 0 */
	public long nb_frames;
	/** < AV_DISPOSITION_* bit field */
	public int disposition;
	/** C type : AVProbeData */
	public AVProbeData probe_data;
	/** C type : int64_t[16 + 1] */
	public long[] pts_buffer = new long[16 + 1];
	/**
	 * sample aspect ratio (0 if unknown)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavformat.<br>
	 * C type : AVRational
	 */
	public AVRational sample_aspect_ratio;
	/** C type : AVDictionary* */
	public PointerByReference metadata;
	/**
	 * external applications; try to use something else if at all possible.<br>
	 * C type : const uint8_t*
	 */
	public Pointer cur_ptr;
	public int cur_len;
	/** C type : AVPacket */
	public AVPacket cur_pkt;
	/**
	 * Timestamp corresponding to the last dts sync point.<br>
	 * * Initialized when AVCodecParserContext.dts_sync_point >= 0 and<br>
	 * a DTS is received from the underlying container. Otherwise set to<br>
	 * AV_NOPTS_VALUE by default.
	 */
	public long reference_dts;
	public int probe_packets;
	/**
	 * last packet in packet_buffer for this stream when muxing.<br>
	 * Used internally, NOT PART OF PUBLIC API, do not read or<br>
	 * write from outside of libav*<br>
	 * C type : AVPacketList*
	 */
	public AVPacketList.ByReference last_in_packet_buffer;
	/**
	 * Average framerate<br>
	 * C type : AVRational
	 */
	public AVRational avg_frame_rate;
	/** Number of frames that have been demuxed during av_find_stream_info() */
	public int codec_info_nb_frames;
	/** C type : info_struct* */
	public AVStream.info_struct.ByReference info;
	/** <i>native declaration : /usr/include/libavformat/avformat.h:7921</i> */
	public static class info_struct extends Structure {
		public long last_dts;
		public long duration_gcd;
		public int duration_count;
		/** C type : double[(60 * 12 + 5)] */
		public double[] duration_error = new double[60 * 12 + 5];
		public long codec_info_duration;
		public int nb_decoded_frames;
		public info_struct() {
			super();
		}
		protected List<? > getFieldOrder() {
			return Arrays.asList("last_dts", "duration_gcd", "duration_count", "duration_error", "codec_info_duration", "nb_decoded_frames");
		}
		/** @param duration_error C type : double[(60 * 12 + 5)] */
		public info_struct(long last_dts, long duration_gcd, int duration_count, double duration_error[], long codec_info_duration, int nb_decoded_frames) {
			super();
			this.last_dts = last_dts;
			this.duration_gcd = duration_gcd;
			this.duration_count = duration_count;
			if ((duration_error.length != this.duration_error.length)) 
				throw new IllegalArgumentException("Wrong array size !");
			this.duration_error = duration_error;
			this.codec_info_duration = codec_info_duration;
			this.nb_decoded_frames = nb_decoded_frames;
		}
		public static class ByReference extends info_struct implements Structure.ByReference {
			
		};
		public static class ByValue extends info_struct implements Structure.ByValue {
			
		};
	};
	public AVStream() {
		super();
	}
	protected List<? > getFieldOrder() {
		return Arrays.asList("index", "id", "codec", "r_frame_rate", "priv_data", "first_dts", "pts", "time_base", "pts_wrap_bits", "stream_copy", "discard", "quality", "start_time", "duration", "need_parsing", "parser", "cur_dts", "last_IP_duration", "last_IP_pts", "index_entries", "nb_index_entries", "index_entries_allocated_size", "nb_frames", "disposition", "probe_data", "pts_buffer", "sample_aspect_ratio", "metadata", "cur_ptr", "cur_len", "cur_pkt", "reference_dts", "probe_packets", "last_in_packet_buffer", "avg_frame_rate", "codec_info_nb_frames", "info");
	}
	public static class ByReference extends AVStream implements Structure.ByReference {
		
	};
	public static class ByValue extends AVStream implements Structure.ByValue {
		
	};
}
