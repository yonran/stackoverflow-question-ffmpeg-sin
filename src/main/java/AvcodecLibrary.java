
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
/**
 * JNA Wrapper for library <b>avcodec</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AvcodecLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "avcodec";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(AvcodecLibrary.JNA_LIBRARY_NAME);
	public static final AvcodecLibrary INSTANCE = (AvcodecLibrary)Native.loadLibrary(AvcodecLibrary.JNA_LIBRARY_NAME, AvcodecLibrary.class);
	/**
	 * Identify the syntax and semantics of the bitstream.<br>
	 * The principle is roughly:<br>
	 * Two decoders with the same ID can decode the same streams.<br>
	 * Two encoders with the same ID can encode compatible streams.<br>
	 * There may be slight deviations from the principle due to implementation<br>
	 * details.<br>
	 * * If you add a codec ID to this list, add it so that<br>
	 * 1. no value of a existing codec ID changes (that would break ABI),<br>
	 * 2. it is as close as possible to similar codecs.<br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3662</i><br>
	 * enum values
	 */
	public static interface CodecID {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3339</i> */
		public static final int CODEC_ID_NONE = 0;
		/**
		 * video codecs<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3341</i>
		 */
		public static final int CODEC_ID_MPEG1VIDEO = 1;
		/**
		 * < preferred ID for MPEG-1/2 video decoding<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3343</i>
		 */
		public static final int CODEC_ID_MPEG2VIDEO = 2;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3344</i> */
		public static final int CODEC_ID_MPEG2VIDEO_XVMC = 3;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3345</i> */
		public static final int CODEC_ID_H261 = 4;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3346</i> */
		public static final int CODEC_ID_H263 = 5;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3347</i> */
		public static final int CODEC_ID_RV10 = 6;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3348</i> */
		public static final int CODEC_ID_RV20 = 7;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3349</i> */
		public static final int CODEC_ID_MJPEG = 8;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3350</i> */
		public static final int CODEC_ID_MJPEGB = 9;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3351</i> */
		public static final int CODEC_ID_LJPEG = 10;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3352</i> */
		public static final int CODEC_ID_SP5X = 11;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3353</i> */
		public static final int CODEC_ID_JPEGLS = 12;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3354</i> */
		public static final int CODEC_ID_MPEG4 = 13;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3355</i> */
		public static final int CODEC_ID_RAWVIDEO = 14;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3356</i> */
		public static final int CODEC_ID_MSMPEG4V1 = 15;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3357</i> */
		public static final int CODEC_ID_MSMPEG4V2 = 16;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3358</i> */
		public static final int CODEC_ID_MSMPEG4V3 = 17;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3359</i> */
		public static final int CODEC_ID_WMV1 = 18;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3360</i> */
		public static final int CODEC_ID_WMV2 = 19;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3361</i> */
		public static final int CODEC_ID_H263P = 20;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3362</i> */
		public static final int CODEC_ID_H263I = 21;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3363</i> */
		public static final int CODEC_ID_FLV1 = 22;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3364</i> */
		public static final int CODEC_ID_SVQ1 = 23;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3365</i> */
		public static final int CODEC_ID_SVQ3 = 24;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3366</i> */
		public static final int CODEC_ID_DVVIDEO = 25;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3367</i> */
		public static final int CODEC_ID_HUFFYUV = 26;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3368</i> */
		public static final int CODEC_ID_CYUV = 27;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3369</i> */
		public static final int CODEC_ID_H264 = 28;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3370</i> */
		public static final int CODEC_ID_INDEO3 = 29;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3371</i> */
		public static final int CODEC_ID_VP3 = 30;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3372</i> */
		public static final int CODEC_ID_THEORA = 31;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3373</i> */
		public static final int CODEC_ID_ASV1 = 32;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3374</i> */
		public static final int CODEC_ID_ASV2 = 33;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3375</i> */
		public static final int CODEC_ID_FFV1 = 34;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3376</i> */
		public static final int CODEC_ID_4XM = 35;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3377</i> */
		public static final int CODEC_ID_VCR1 = 36;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3378</i> */
		public static final int CODEC_ID_CLJR = 37;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3379</i> */
		public static final int CODEC_ID_MDEC = 38;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3380</i> */
		public static final int CODEC_ID_ROQ = 39;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3381</i> */
		public static final int CODEC_ID_INTERPLAY_VIDEO = 40;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3382</i> */
		public static final int CODEC_ID_XAN_WC3 = 41;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3383</i> */
		public static final int CODEC_ID_XAN_WC4 = 42;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3384</i> */
		public static final int CODEC_ID_RPZA = 43;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3385</i> */
		public static final int CODEC_ID_CINEPAK = 44;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3386</i> */
		public static final int CODEC_ID_WS_VQA = 45;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3387</i> */
		public static final int CODEC_ID_MSRLE = 46;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3388</i> */
		public static final int CODEC_ID_MSVIDEO1 = 47;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3389</i> */
		public static final int CODEC_ID_IDCIN = 48;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3390</i> */
		public static final int CODEC_ID_8BPS = 49;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3391</i> */
		public static final int CODEC_ID_SMC = 50;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3392</i> */
		public static final int CODEC_ID_FLIC = 51;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3393</i> */
		public static final int CODEC_ID_TRUEMOTION1 = 52;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3394</i> */
		public static final int CODEC_ID_VMDVIDEO = 53;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3395</i> */
		public static final int CODEC_ID_MSZH = 54;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3396</i> */
		public static final int CODEC_ID_ZLIB = 55;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3397</i> */
		public static final int CODEC_ID_QTRLE = 56;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3398</i> */
		public static final int CODEC_ID_SNOW = 57;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3399</i> */
		public static final int CODEC_ID_TSCC = 58;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3400</i> */
		public static final int CODEC_ID_ULTI = 59;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3401</i> */
		public static final int CODEC_ID_QDRAW = 60;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3402</i> */
		public static final int CODEC_ID_VIXL = 61;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3403</i> */
		public static final int CODEC_ID_QPEG = 62;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3404</i> */
		public static final int CODEC_ID_PNG = 63;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3405</i> */
		public static final int CODEC_ID_PPM = 64;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3406</i> */
		public static final int CODEC_ID_PBM = 65;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3407</i> */
		public static final int CODEC_ID_PGM = 66;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3408</i> */
		public static final int CODEC_ID_PGMYUV = 67;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3409</i> */
		public static final int CODEC_ID_PAM = 68;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3410</i> */
		public static final int CODEC_ID_FFVHUFF = 69;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3411</i> */
		public static final int CODEC_ID_RV30 = 70;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3412</i> */
		public static final int CODEC_ID_RV40 = 71;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3413</i> */
		public static final int CODEC_ID_VC1 = 72;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3414</i> */
		public static final int CODEC_ID_WMV3 = 73;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3415</i> */
		public static final int CODEC_ID_LOCO = 74;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3416</i> */
		public static final int CODEC_ID_WNV1 = 75;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3417</i> */
		public static final int CODEC_ID_AASC = 76;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3418</i> */
		public static final int CODEC_ID_INDEO2 = 77;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3419</i> */
		public static final int CODEC_ID_FRAPS = 78;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3420</i> */
		public static final int CODEC_ID_TRUEMOTION2 = 79;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3421</i> */
		public static final int CODEC_ID_BMP = 80;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3422</i> */
		public static final int CODEC_ID_CSCD = 81;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3423</i> */
		public static final int CODEC_ID_MMVIDEO = 82;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3424</i> */
		public static final int CODEC_ID_ZMBV = 83;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3425</i> */
		public static final int CODEC_ID_AVS = 84;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3426</i> */
		public static final int CODEC_ID_SMACKVIDEO = 85;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3427</i> */
		public static final int CODEC_ID_NUV = 86;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3428</i> */
		public static final int CODEC_ID_KMVC = 87;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3429</i> */
		public static final int CODEC_ID_FLASHSV = 88;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3430</i> */
		public static final int CODEC_ID_CAVS = 89;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3431</i> */
		public static final int CODEC_ID_JPEG2000 = 90;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3432</i> */
		public static final int CODEC_ID_VMNC = 91;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3433</i> */
		public static final int CODEC_ID_VP5 = 92;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3434</i> */
		public static final int CODEC_ID_VP6 = 93;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3435</i> */
		public static final int CODEC_ID_VP6F = 94;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3436</i> */
		public static final int CODEC_ID_TARGA = 95;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3437</i> */
		public static final int CODEC_ID_DSICINVIDEO = 96;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3438</i> */
		public static final int CODEC_ID_TIERTEXSEQVIDEO = 97;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3439</i> */
		public static final int CODEC_ID_TIFF = 98;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3440</i> */
		public static final int CODEC_ID_GIF = 99;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3441</i> */
		public static final int CODEC_ID_FFH264 = 100;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3442</i> */
		public static final int CODEC_ID_DXA = 101;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3443</i> */
		public static final int CODEC_ID_DNXHD = 102;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3444</i> */
		public static final int CODEC_ID_THP = 103;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3445</i> */
		public static final int CODEC_ID_SGI = 104;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3446</i> */
		public static final int CODEC_ID_C93 = 105;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3447</i> */
		public static final int CODEC_ID_BETHSOFTVID = 106;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3448</i> */
		public static final int CODEC_ID_PTX = 107;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3449</i> */
		public static final int CODEC_ID_TXD = 108;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3450</i> */
		public static final int CODEC_ID_VP6A = 109;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3451</i> */
		public static final int CODEC_ID_AMV = 110;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3452</i> */
		public static final int CODEC_ID_VB = 111;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3453</i> */
		public static final int CODEC_ID_PCX = 112;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3454</i> */
		public static final int CODEC_ID_SUNRAST = 113;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3455</i> */
		public static final int CODEC_ID_INDEO4 = 114;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3456</i> */
		public static final int CODEC_ID_INDEO5 = 115;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3457</i> */
		public static final int CODEC_ID_MIMIC = 116;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3458</i> */
		public static final int CODEC_ID_RL2 = 117;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3459</i> */
		public static final int CODEC_ID_8SVX_EXP = 118;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3460</i> */
		public static final int CODEC_ID_8SVX_FIB = 119;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3461</i> */
		public static final int CODEC_ID_ESCAPE124 = 120;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3462</i> */
		public static final int CODEC_ID_DIRAC = 121;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3463</i> */
		public static final int CODEC_ID_BFI = 122;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3464</i> */
		public static final int CODEC_ID_CMV = 123;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3465</i> */
		public static final int CODEC_ID_MOTIONPIXELS = 124;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3466</i> */
		public static final int CODEC_ID_TGV = 125;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3467</i> */
		public static final int CODEC_ID_TGQ = 126;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3468</i> */
		public static final int CODEC_ID_TQI = 127;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3469</i> */
		public static final int CODEC_ID_AURA = 128;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3470</i> */
		public static final int CODEC_ID_AURA2 = 129;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3471</i> */
		public static final int CODEC_ID_V210X = 130;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3472</i> */
		public static final int CODEC_ID_TMV = 131;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3473</i> */
		public static final int CODEC_ID_V210 = 132;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3474</i> */
		public static final int CODEC_ID_DPX = 133;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3475</i> */
		public static final int CODEC_ID_MAD = 134;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3476</i> */
		public static final int CODEC_ID_FRWU = 135;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3477</i> */
		public static final int CODEC_ID_FLASHSV2 = 136;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3478</i> */
		public static final int CODEC_ID_CDGRAPHICS = 137;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3479</i> */
		public static final int CODEC_ID_R210 = 138;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3480</i> */
		public static final int CODEC_ID_ANM = 139;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3481</i> */
		public static final int CODEC_ID_BINKVIDEO = 140;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3482</i> */
		public static final int CODEC_ID_IFF_ILBM = 141;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3483</i> */
		public static final int CODEC_ID_IFF_BYTERUN1 = 142;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3484</i> */
		public static final int CODEC_ID_KGV1 = 143;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3485</i> */
		public static final int CODEC_ID_YOP = 144;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3486</i> */
		public static final int CODEC_ID_VP8 = 145;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3487</i> */
		public static final int CODEC_ID_PICTOR = 146;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3488</i> */
		public static final int CODEC_ID_ANSI = 147;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3489</i> */
		public static final int CODEC_ID_A64_MULTI = 148;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3490</i> */
		public static final int CODEC_ID_A64_MULTI5 = 149;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3491</i> */
		public static final int CODEC_ID_R10K = 150;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3492</i> */
		public static final int CODEC_ID_MXPEG = 151;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3493</i> */
		public static final int CODEC_ID_LAGARITH = 152;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3494</i> */
		public static final int CODEC_ID_PRORES = 153;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3495</i> */
		public static final int CODEC_ID_JV = 154;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3496</i> */
		public static final int CODEC_ID_DFA = 155;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3497</i> */
		public static final int CODEC_ID_WMV3IMAGE = 156;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3498</i> */
		public static final int CODEC_ID_VC1IMAGE = 157;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3499</i> */
		public static final int CODEC_ID_G723_1 = 158;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3500</i> */
		public static final int CODEC_ID_G729 = 159;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3501</i> */
		public static final int CODEC_ID_UTVIDEO = 160;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3502</i> */
		public static final int CODEC_ID_BMV_VIDEO = 161;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3503</i> */
		public static final int CODEC_ID_VBLE = 162;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3504</i> */
		public static final int CODEC_ID_DXTORY = 163;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3505</i> */
		public static final int CODEC_ID_V410 = 164;
		/**
		 * various PCM "codecs"<br>
		 * < A dummy id pointing at the start of audio codecs<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3508</i>
		 */
		public static final int CODEC_ID_FIRST_AUDIO = 0x10000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3509</i> */
		public static final int CODEC_ID_PCM_S16LE = 0x10000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3510</i> */
		public static final int CODEC_ID_PCM_S16BE = (0x10000 + 1);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3511</i> */
		public static final int CODEC_ID_PCM_U16LE = (0x10000 + 2);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3512</i> */
		public static final int CODEC_ID_PCM_U16BE = (0x10000 + 3);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3513</i> */
		public static final int CODEC_ID_PCM_S8 = (0x10000 + 4);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3514</i> */
		public static final int CODEC_ID_PCM_U8 = (0x10000 + 5);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3515</i> */
		public static final int CODEC_ID_PCM_MULAW = (0x10000 + 6);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3516</i> */
		public static final int CODEC_ID_PCM_ALAW = (0x10000 + 7);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3517</i> */
		public static final int CODEC_ID_PCM_S32LE = (0x10000 + 8);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3518</i> */
		public static final int CODEC_ID_PCM_S32BE = (0x10000 + 9);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3519</i> */
		public static final int CODEC_ID_PCM_U32LE = (0x10000 + 10);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3520</i> */
		public static final int CODEC_ID_PCM_U32BE = (0x10000 + 11);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3521</i> */
		public static final int CODEC_ID_PCM_S24LE = (0x10000 + 12);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3522</i> */
		public static final int CODEC_ID_PCM_S24BE = (0x10000 + 13);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3523</i> */
		public static final int CODEC_ID_PCM_U24LE = (0x10000 + 14);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3524</i> */
		public static final int CODEC_ID_PCM_U24BE = (0x10000 + 15);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3525</i> */
		public static final int CODEC_ID_PCM_S24DAUD = (0x10000 + 16);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3526</i> */
		public static final int CODEC_ID_PCM_ZORK = (0x10000 + 17);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3527</i> */
		public static final int CODEC_ID_PCM_S16LE_PLANAR = (0x10000 + 18);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3528</i> */
		public static final int CODEC_ID_PCM_DVD = (0x10000 + 19);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3529</i> */
		public static final int CODEC_ID_PCM_F32BE = (0x10000 + 20);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3530</i> */
		public static final int CODEC_ID_PCM_F32LE = (0x10000 + 21);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3531</i> */
		public static final int CODEC_ID_PCM_F64BE = (0x10000 + 22);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3532</i> */
		public static final int CODEC_ID_PCM_F64LE = (0x10000 + 23);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3533</i> */
		public static final int CODEC_ID_PCM_BLURAY = (0x10000 + 24);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3534</i> */
		public static final int CODEC_ID_PCM_LXF = (0x10000 + 25);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3535</i> */
		public static final int CODEC_ID_S302M = (0x10000 + 26);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3536</i> */
		public static final int CODEC_ID_PCM_S8_PLANAR = (0x10000 + 27);
		/**
		 * various ADPCM codecs<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3538</i>
		 */
		public static final int CODEC_ID_ADPCM_IMA_QT = 0x11000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3539</i> */
		public static final int CODEC_ID_ADPCM_IMA_WAV = (0x11000 + 1);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3540</i> */
		public static final int CODEC_ID_ADPCM_IMA_DK3 = (0x11000 + 2);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3541</i> */
		public static final int CODEC_ID_ADPCM_IMA_DK4 = (0x11000 + 3);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3542</i> */
		public static final int CODEC_ID_ADPCM_IMA_WS = (0x11000 + 4);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3543</i> */
		public static final int CODEC_ID_ADPCM_IMA_SMJPEG = (0x11000 + 5);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3544</i> */
		public static final int CODEC_ID_ADPCM_MS = (0x11000 + 6);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3545</i> */
		public static final int CODEC_ID_ADPCM_4XM = (0x11000 + 7);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3546</i> */
		public static final int CODEC_ID_ADPCM_XA = (0x11000 + 8);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3547</i> */
		public static final int CODEC_ID_ADPCM_ADX = (0x11000 + 9);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3548</i> */
		public static final int CODEC_ID_ADPCM_EA = (0x11000 + 10);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3549</i> */
		public static final int CODEC_ID_ADPCM_G726 = (0x11000 + 11);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3550</i> */
		public static final int CODEC_ID_ADPCM_CT = (0x11000 + 12);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3551</i> */
		public static final int CODEC_ID_ADPCM_SWF = (0x11000 + 13);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3552</i> */
		public static final int CODEC_ID_ADPCM_YAMAHA = (0x11000 + 14);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3553</i> */
		public static final int CODEC_ID_ADPCM_SBPRO_4 = (0x11000 + 15);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3554</i> */
		public static final int CODEC_ID_ADPCM_SBPRO_3 = (0x11000 + 16);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3555</i> */
		public static final int CODEC_ID_ADPCM_SBPRO_2 = (0x11000 + 17);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3556</i> */
		public static final int CODEC_ID_ADPCM_THP = (0x11000 + 18);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3557</i> */
		public static final int CODEC_ID_ADPCM_IMA_AMV = (0x11000 + 19);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3558</i> */
		public static final int CODEC_ID_ADPCM_EA_R1 = (0x11000 + 20);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3559</i> */
		public static final int CODEC_ID_ADPCM_EA_R3 = (0x11000 + 21);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3560</i> */
		public static final int CODEC_ID_ADPCM_EA_R2 = (0x11000 + 22);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3561</i> */
		public static final int CODEC_ID_ADPCM_IMA_EA_SEAD = (0x11000 + 23);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3562</i> */
		public static final int CODEC_ID_ADPCM_IMA_EA_EACS = (0x11000 + 24);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3563</i> */
		public static final int CODEC_ID_ADPCM_EA_XAS = (0x11000 + 25);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3564</i> */
		public static final int CODEC_ID_ADPCM_EA_MAXIS_XA = (0x11000 + 26);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3565</i> */
		public static final int CODEC_ID_ADPCM_IMA_ISS = (0x11000 + 27);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3566</i> */
		public static final int CODEC_ID_ADPCM_G722 = (0x11000 + 28);
		/**
		 * AMR<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3568</i>
		 */
		public static final int CODEC_ID_AMR_NB = 0x12000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3569</i> */
		public static final int CODEC_ID_AMR_WB = (0x12000 + 1);
		/**
		 * RealAudio codecs<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3571</i>
		 */
		public static final int CODEC_ID_RA_144 = 0x13000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3572</i> */
		public static final int CODEC_ID_RA_288 = (0x13000 + 1);
		/**
		 * various DPCM codecs<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3574</i>
		 */
		public static final int CODEC_ID_ROQ_DPCM = 0x14000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3575</i> */
		public static final int CODEC_ID_INTERPLAY_DPCM = (0x14000 + 1);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3576</i> */
		public static final int CODEC_ID_XAN_DPCM = (0x14000 + 2);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3577</i> */
		public static final int CODEC_ID_SOL_DPCM = (0x14000 + 3);
		/**
		 * audio codecs<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3579</i>
		 */
		public static final int CODEC_ID_MP2 = 0x15000;
		/**
		 * < preferred ID for decoding MPEG audio layer 1, 2 or 3<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3581</i>
		 */
		public static final int CODEC_ID_MP3 = (0x15000 + 1);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3582</i> */
		public static final int CODEC_ID_AAC = (0x15000 + 2);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3583</i> */
		public static final int CODEC_ID_AC3 = (0x15000 + 3);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3584</i> */
		public static final int CODEC_ID_DTS = (0x15000 + 4);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3585</i> */
		public static final int CODEC_ID_VORBIS = (0x15000 + 5);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3586</i> */
		public static final int CODEC_ID_DVAUDIO = (0x15000 + 6);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3587</i> */
		public static final int CODEC_ID_WMAV1 = (0x15000 + 7);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3588</i> */
		public static final int CODEC_ID_WMAV2 = (0x15000 + 8);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3589</i> */
		public static final int CODEC_ID_MACE3 = (0x15000 + 9);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3590</i> */
		public static final int CODEC_ID_MACE6 = (0x15000 + 10);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3591</i> */
		public static final int CODEC_ID_VMDAUDIO = (0x15000 + 11);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3592</i> */
		public static final int CODEC_ID_SONIC = (0x15000 + 12);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3593</i> */
		public static final int CODEC_ID_SONIC_LS = (0x15000 + 13);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3594</i> */
		public static final int CODEC_ID_FLAC = (0x15000 + 14);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3595</i> */
		public static final int CODEC_ID_MP3ADU = (0x15000 + 15);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3596</i> */
		public static final int CODEC_ID_MP3ON4 = (0x15000 + 16);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3597</i> */
		public static final int CODEC_ID_SHORTEN = (0x15000 + 17);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3598</i> */
		public static final int CODEC_ID_ALAC = (0x15000 + 18);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3599</i> */
		public static final int CODEC_ID_WESTWOOD_SND1 = (0x15000 + 19);
		/**
		 * < as in Berlin toast format<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3601</i>
		 */
		public static final int CODEC_ID_GSM = (0x15000 + 20);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3602</i> */
		public static final int CODEC_ID_QDM2 = (0x15000 + 21);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3603</i> */
		public static final int CODEC_ID_COOK = (0x15000 + 22);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3604</i> */
		public static final int CODEC_ID_TRUESPEECH = (0x15000 + 23);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3605</i> */
		public static final int CODEC_ID_TTA = (0x15000 + 24);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3606</i> */
		public static final int CODEC_ID_SMACKAUDIO = (0x15000 + 25);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3607</i> */
		public static final int CODEC_ID_QCELP = (0x15000 + 26);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3608</i> */
		public static final int CODEC_ID_WAVPACK = (0x15000 + 27);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3609</i> */
		public static final int CODEC_ID_DSICINAUDIO = (0x15000 + 28);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3610</i> */
		public static final int CODEC_ID_IMC = (0x15000 + 29);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3611</i> */
		public static final int CODEC_ID_MUSEPACK7 = (0x15000 + 30);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3612</i> */
		public static final int CODEC_ID_MLP = (0x15000 + 31);
		/**
		 * as found in WAV<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3613</i>
		 */
		public static final int CODEC_ID_GSM_MS = (0x15000 + 32);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3614</i> */
		public static final int CODEC_ID_ATRAC3 = (0x15000 + 33);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3615</i> */
		public static final int CODEC_ID_VOXWARE = (0x15000 + 34);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3616</i> */
		public static final int CODEC_ID_APE = (0x15000 + 35);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3617</i> */
		public static final int CODEC_ID_NELLYMOSER = (0x15000 + 36);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3618</i> */
		public static final int CODEC_ID_MUSEPACK8 = (0x15000 + 37);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3619</i> */
		public static final int CODEC_ID_SPEEX = (0x15000 + 38);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3620</i> */
		public static final int CODEC_ID_WMAVOICE = (0x15000 + 39);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3621</i> */
		public static final int CODEC_ID_WMAPRO = (0x15000 + 40);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3622</i> */
		public static final int CODEC_ID_WMALOSSLESS = (0x15000 + 41);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3623</i> */
		public static final int CODEC_ID_ATRAC3P = (0x15000 + 42);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3624</i> */
		public static final int CODEC_ID_EAC3 = (0x15000 + 43);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3625</i> */
		public static final int CODEC_ID_SIPR = (0x15000 + 44);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3626</i> */
		public static final int CODEC_ID_MP1 = (0x15000 + 45);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3627</i> */
		public static final int CODEC_ID_TWINVQ = (0x15000 + 46);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3628</i> */
		public static final int CODEC_ID_TRUEHD = (0x15000 + 47);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3629</i> */
		public static final int CODEC_ID_MP4ALS = (0x15000 + 48);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3630</i> */
		public static final int CODEC_ID_ATRAC1 = (0x15000 + 49);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3631</i> */
		public static final int CODEC_ID_BINKAUDIO_RDFT = (0x15000 + 50);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3632</i> */
		public static final int CODEC_ID_BINKAUDIO_DCT = (0x15000 + 51);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3633</i> */
		public static final int CODEC_ID_AAC_LATM = (0x15000 + 52);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3634</i> */
		public static final int CODEC_ID_QDMC = (0x15000 + 53);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3635</i> */
		public static final int CODEC_ID_CELT = (0x15000 + 54);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3636</i> */
		public static final int CODEC_ID_BMV_AUDIO = (0x15000 + 55);
		/**
		 * subtitle codecs<br>
		 * < A dummy ID pointing at the start of subtitle codecs.<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3639</i>
		 */
		public static final int CODEC_ID_FIRST_SUBTITLE = 0x17000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3640</i> */
		public static final int CODEC_ID_DVD_SUBTITLE = 0x17000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3641</i> */
		public static final int CODEC_ID_DVB_SUBTITLE = (0x17000 + 1);
		/**
		 * < raw UTF-8 text<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3643</i>
		 */
		public static final int CODEC_ID_TEXT = (0x17000 + 2);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3644</i> */
		public static final int CODEC_ID_XSUB = (0x17000 + 3);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3645</i> */
		public static final int CODEC_ID_SSA = (0x17000 + 4);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3646</i> */
		public static final int CODEC_ID_MOV_TEXT = (0x17000 + 5);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3647</i> */
		public static final int CODEC_ID_HDMV_PGS_SUBTITLE = (0x17000 + 6);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3648</i> */
		public static final int CODEC_ID_DVB_TELETEXT = (0x17000 + 7);
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3649</i> */
		public static final int CODEC_ID_SRT = (0x17000 + 8);
		/**
		 * other specific kind of codecs (generally used for attachments)<br>
		 * < A dummy ID pointing at the start of various fake codecs.<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3652</i>
		 */
		public static final int CODEC_ID_FIRST_UNKNOWN = 0x18000;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3653</i> */
		public static final int CODEC_ID_TTF = 0x18000;
		/**
		 * < codec_id is not known (like CODEC_ID_NONE) but lavf should attempt to identify it<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3655</i>
		 */
		public static final int CODEC_ID_PROBE = 0x19000;
		/**
		 * < _FAKE_ codec to indicate a raw MPEG-2 TS<br>
		 * stream (only used by libavformat)<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3657</i>
		 */
		public static final int CODEC_ID_MPEG2TS = 0x20000;
		/**
		 * < _FAKE_ codec to indicate a MPEG-4 Systems<br>
		 * stream (only used by libavformat)<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3659</i>
		 */
		public static final int CODEC_ID_MPEG4SYSTEMS = 0x20001;
		/**
		 * < Dummy codec for streams containing only metadata information.<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3661</i>
		 */
		public static final int CODEC_ID_FFMETADATA = 0x21000;
	};
	/**
	 * motion estimation type.<br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3700</i><br>
	 * enum values
	 */
	public static interface Motion_Est_ID {
		/**
		 * < no search, that is use 0,0 vector whenever one is needed<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3684</i>
		 */
		public static final int ME_ZERO = 1;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3685</i> */
		public static final int ME_FULL = 2;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3686</i> */
		public static final int ME_LOG = 3;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3687</i> */
		public static final int ME_PHODS = 4;
		/**
		 * < enhanced predictive zonal search<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3689</i>
		 */
		public static final int ME_EPZS = 5;
		/**
		 * < reserved for experiments<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3691</i>
		 */
		public static final int ME_X1 = 6;
		/**
		 * < hexagon based search<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3693</i>
		 */
		public static final int ME_HEX = 7;
		/**
		 * < uneven multi-hexagon search<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3695</i>
		 */
		public static final int ME_UMH = 8;
		/**
		 * < iterative search<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3697</i>
		 */
		public static final int ME_ITER = 9;
		/**
		 * < transformed exhaustive search algorithm<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3699</i>
		 */
		public static final int ME_TESA = 10;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3718</i><br>
	 * enum values
	 */
	public static interface AVDiscard {
		/**
		 * We leave some space between them for extensions (drop some<br>
		 * keyframes for intra-only or drop just some bidir frames).<br>
		 * < discard nothing<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3707</i>
		 */
		public static final int AVDISCARD_NONE = -16;
		/**
		 * < discard useless packets like 0 size packets in avi<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3709</i>
		 */
		public static final int AVDISCARD_DEFAULT = 0;
		/**
		 * < discard all non reference<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3711</i>
		 */
		public static final int AVDISCARD_NONREF = 8;
		/**
		 * < discard all bidirectional frames<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3713</i>
		 */
		public static final int AVDISCARD_BIDIR = 16;
		/**
		 * < discard all frames except keyframes<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3715</i>
		 */
		public static final int AVDISCARD_NONKEY = 32;
		/**
		 * < discard all<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3717</i>
		 */
		public static final int AVDISCARD_ALL = 48;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3733</i><br>
	 * enum values
	 */
	public static interface AVColorPrimaries {
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3721</i>
		 */
		public static final int AVCOL_PRI_BT709 = 1;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3722</i> */
		public static final int AVCOL_PRI_UNSPECIFIED = 2;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3723</i> */
		public static final int AVCOL_PRI_BT470M = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3725</i>
		 */
		public static final int AVCOL_PRI_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3727</i>
		 */
		public static final int AVCOL_PRI_SMPTE170M = 6;
		/**
		 * < functionally identical to above<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3729</i>
		 */
		public static final int AVCOL_PRI_SMPTE240M = 7;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3730</i> */
		public static final int AVCOL_PRI_FILM = 8;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3732</i>
		 */
		public static final int AVCOL_PRI_NB = 9;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3744</i><br>
	 * enum values
	 */
	public static interface AVColorTransferCharacteristic {
		/**
		 * < also ITU-R BT1361<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3736</i>
		 */
		public static final int AVCOL_TRC_BT709 = 1;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3737</i> */
		public static final int AVCOL_TRC_UNSPECIFIED = 2;
		/**
		 * < also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3739</i>
		 */
		public static final int AVCOL_TRC_GAMMA22 = 4;
		/**
		 * < also ITU-R BT470BG<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3741</i>
		 */
		public static final int AVCOL_TRC_GAMMA28 = 5;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3743</i>
		 */
		public static final int AVCOL_TRC_NB = 6;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3758</i><br>
	 * enum values
	 */
	public static interface AVColorSpace {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3746</i> */
		public static final int AVCOL_SPC_RGB = 0;
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3748</i>
		 */
		public static final int AVCOL_SPC_BT709 = 1;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3749</i> */
		public static final int AVCOL_SPC_UNSPECIFIED = 2;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3750</i> */
		public static final int AVCOL_SPC_FCC = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3752</i>
		 */
		public static final int AVCOL_SPC_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3754</i>
		 */
		public static final int AVCOL_SPC_SMPTE170M = 6;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3755</i> */
		public static final int AVCOL_SPC_SMPTE240M = 7;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3757</i>
		 */
		public static final int AVCOL_SPC_NB = 8;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3767</i><br>
	 * enum values
	 */
	public static interface AVColorRange {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3760</i> */
		public static final int AVCOL_RANGE_UNSPECIFIED = 0;
		/**
		 * < the normal 219*2^(n-8) "MPEG" YUV ranges<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3762</i>
		 */
		public static final int AVCOL_RANGE_MPEG = 1;
		/**
		 * < the normal     2^n-1   "JPEG" YUV ranges<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3764</i>
		 */
		public static final int AVCOL_RANGE_JPEG = 2;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3766</i>
		 */
		public static final int AVCOL_RANGE_NB = 3;
	};
	/**
	 * X   X      3 4 X      X are luma samples,<br>
	 *             1 2        1-6 are possible chroma positions<br>
	 *  X   X      5 6 X      0 is undefined/unknown position<br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3786</i><br>
	 * enum values
	 */
	public static interface AVChromaLocation {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3774</i> */
		public static final int AVCHROMA_LOC_UNSPECIFIED = 0;
		/**
		 * < mpeg2/4, h264 default<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3776</i>
		 */
		public static final int AVCHROMA_LOC_LEFT = 1;
		/**
		 * < mpeg1, jpeg, h263<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3778</i>
		 */
		public static final int AVCHROMA_LOC_CENTER = 2;
		/**
		 * < DV<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3780</i>
		 */
		public static final int AVCHROMA_LOC_TOPLEFT = 3;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3781</i> */
		public static final int AVCHROMA_LOC_TOP = 4;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3782</i> */
		public static final int AVCHROMA_LOC_BOTTOMLEFT = 5;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3783</i> */
		public static final int AVCHROMA_LOC_BOTTOM = 6;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3785</i>
		 */
		public static final int AVCHROMA_LOC_NB = 7;
	};
	/**
	 * LPC analysis type<br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3801</i><br>
	 * enum values
	 */
	public static interface AVLPCType {
		/**
		 * < use the codec default LPC type<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3790</i>
		 */
		public static final int AV_LPC_TYPE_DEFAULT = -1;
		/**
		 * < do not use LPC prediction or use all zero coefficients<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3792</i>
		 */
		public static final int AV_LPC_TYPE_NONE = 0;
		/**
		 * < fixed LPC coefficients<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3794</i>
		 */
		public static final int AV_LPC_TYPE_FIXED = 1;
		/**
		 * < Levinson-Durbin recursion<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3796</i>
		 */
		public static final int AV_LPC_TYPE_LEVINSON = 2;
		/**
		 * < Cholesky factorization<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3798</i>
		 */
		public static final int AV_LPC_TYPE_CHOLESKY = 3;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3800</i>
		 */
		public static final int AV_LPC_TYPE_NB = 4;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3814</i><br>
	 * enum values
	 */
	public static interface AVAudioServiceType {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3803</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_MAIN = 0;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3804</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_EFFECTS = 1;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3805</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3806</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3807</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3808</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3809</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3810</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3811</i> */
		public static final int AV_AUDIO_SERVICE_TYPE_KARAOKE = 8;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3813</i>
		 */
		public static final int AV_AUDIO_SERVICE_TYPE_NB = 9;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3852</i><br>
	 * enum values
	 */
	public static interface AVPacketSideDataType {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3849</i> */
		public static final int AV_PKT_DATA_PALETTE = 0;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3850</i> */
		public static final int AV_PKT_DATA_NEW_EXTRADATA = 1;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3851</i> */
		public static final int AV_PKT_DATA_PARAM_CHANGE = 2;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:3921</i><br>
	 * enum values
	 */
	public static interface AVSideDataParamChangeFlags {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3917</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 0x0001;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3918</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3919</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 0x0004;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:3920</i> */
		public static final int AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 0x0008;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:4221</i><br>
	 * enum values
	 */
	public static interface AVFieldOrder {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:4211</i> */
		public static final int AV_FIELD_UNKNOWN = 0;
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:4212</i> */
		public static final int AV_FIELD_PROGRESSIVE = 1;
		/**
		 * < Top coded_first, top displayed first<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:4214</i>
		 */
		public static final int AV_FIELD_TT = 2;
		/**
		 * < Bottom coded first, bottom displayed first<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:4216</i>
		 */
		public static final int AV_FIELD_BB = 3;
		/**
		 * < Top coded first, bottom displayed first<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:4218</i>
		 */
		public static final int AV_FIELD_TB = 4;
		/**
		 * < Bottom coded first, top displayed first<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:4220</i>
		 */
		public static final int AV_FIELD_BT = 5;
	};
	/**
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5874</i><br>
	 * enum values
	 */
	public static interface AVSubtitleType {
		/** <i>native declaration : /usr/include/libavcodec/avcodec.h:5861</i> */
		public static final int SUBTITLE_NONE = 0;
		/**
		 * < A bitmap, pict will be set<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5863</i>
		 */
		public static final int SUBTITLE_BITMAP = 1;
		/**
		 * Plain text, the text field must be set by the decoder and is<br>
		 * authoritative. ass and pict fields may contain approximations.<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5868</i>
		 */
		public static final int SUBTITLE_TEXT = 2;
		/**
		 * Formatted text, the ass field must be set by the decoder and is<br>
		 * authoritative. pict and text fields may contain approximations.<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5873</i>
		 */
		public static final int SUBTITLE_ASS = 3;
	};
	/**
	 * Lock operation used by lockmgr<br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6907</i><br>
	 * enum values
	 */
	public static interface AVLockOp {
		/**
		 * < Create a mutex<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6900</i>
		 */
		public static final int AV_LOCK_CREATE = 0;
		/**
		 * < Lock the mutex<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6902</i>
		 */
		public static final int AV_LOCK_OBTAIN = 1;
		/**
		 * < Unlock the mutex<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6904</i>
		 */
		public static final int AV_LOCK_RELEASE = 2;
		/**
		 * < Free mutex resources<br>
		 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6906</i>
		 */
		public static final int AV_LOCK_DESTROY = 3;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_CLOSED_GOP = (int)0x80000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_STRICT_GOP = (int)0x00000002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_ALTIVEC = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_CHROMA = (int)256;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_MAIN = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SS = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = (int)9;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_BUFFERS = (int)0x00008000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_CBP_RD = (int)0x04000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_BUGS = (int)0x00001000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_TOP_FRONT_CENTER = (int)0x00002000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int X264_PART_I8X8 = (int)0x002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_AA_FLOAT = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_AMV = (int)32;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_EF_EXPLODE = (int)(1 << 3);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_ER = (int)0x00000400;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_GRAY = (int)0x2000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_16x8 = (int)0x0010;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_RLE = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_MB_DECISION_BITS = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_VLC = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_7POINT1_WIDE = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000040 | 0x00000080);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AVPALETTE_SIZE = (int)1024;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_QPEL_CHROMA2 = (int)256;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_EMU_EDGE = (int)0x4000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_MLIB = (int)6;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int X264_PART_P4X4 = (int)0x020;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_MB_DECISION_SIMPLE = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_SVCD_SCAN_OFFSET = (int)0x40000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ER_CAREFUL = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_CORE_SCALABLE = (int)10;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_MIXED_REFS = (int)0x00000040;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_FRONT_LEFT_OF_CENTER = (int)0x00000040;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_AUD = (int)0x00000200;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_INT = (int)(53 << 16 | 35 << 8 | 0);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_VERY_STRICT = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_NUM_DATA_POINTERS = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DTG_AFD_16_9_SP_14_9 = (int)14;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_TYPE_INTERNAL = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_P0L1 = (int)0x4000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_8x16 = (int)0x0020;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444 = (int)144;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH = (int)100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int SLICE_FLAG_ALLOW_PLANE = (int)0x0004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_HD_HRA = (int)50;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_LOSS_RESOLUTION = (int)0x0001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_SSE = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_TRUNCATED = (int)0x00010000;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_AVCODEC_INIT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_STARTCODE = (int)0x00000100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_PSNR = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_HINTS_PRESERVE = (int)0x04;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_PART = (int)0x0080;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS = (int)20;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_GET_ALPHA_INFO = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444_INTRA = (int)(244 | (1 << 11));
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_422 = (int)122;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_STUDIO = (int)14;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_LEVEL_UNKNOWN = (int)-99;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DTG_AFD_14_9 = (int)11;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_FRAME_THREADS = (int)0x1000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_QUAD = (int)((0x00000001 | 0x00000002) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_OPT_H = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_NO_OUTPUT = (int)0x00000004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_BITEXACT = (int)0x00800000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SH4 = (int)9;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_LOSS_CHROMA = (int)0x0020;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_ES = (int)30;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_INT = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_INPUT_BUFFER_PADDING_SIZE = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_THREAD_FRAME = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DTG_AFD_16_9 = (int)10;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_VARIABLE_FRAME_SIZE = (int)0x10000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_AUTO = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_BACK_RIGHT = (int)0x00000020;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_DATA_POINTERS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_H263P_SLICE_STRUCT = (int)0x10000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_INTERLACED_DCT = (int)0x00040000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_CHANNEL_CONF = (int)0x0400;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_LOW_DELAY = (int)0x00080000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_MV = (int)32;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_SURROUND = (int)((0x00000001 | 0x00000002) | 0x00000004);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_P0L0 = (int)0x1000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_96_24 = (int)40;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_SNOW_GLOBAL_OPTS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_INTERLACED_ME = (int)0x20000000;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_OLD_DECODE_AUDIO = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_PASS2 = (int)0x0400;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_PASS1 = (int)0x0200;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_THREAD_SLICE = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_DTS_HD_MA = (int)60;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_LOSS_DEPTH = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_MPEGVIDEO_GLOBAL_OPTS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEMMX = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_OLD_FF_PICT_TYPES = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = (int)13;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_PALETTE_CONTROL = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PRED_PLANE = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MB_TYPE = (int)0x00004000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_BACK_CENTER = (int)0x00000100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ER_COMPLIANT = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_EA = (int)21;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_VSSE = (int)9;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARMV5TE = (int)16;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_NSSE = (int)10;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_QP = (int)16;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_MPEG1 = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_MPEG2 = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_ARM = (int)7;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_RC = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_IPP = (int)13;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DCT_MMX = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int PARSER_FLAG_COMPLETE_FRAMES = (int)0x0001;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_OLD_AUDIOCONVERT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_422 = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_XVIDMMX = (int)14;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_QUANT = (int)0x00010000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_EF_BITSTREAM = (int)(1 << 1);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_SATD = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_SIDE_LEFT = (int)0x00000200;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_RD = (int)6;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SNR_SCALABLE = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_WPRED = (int)0x00000020;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_X264_GLOBAL_OPTS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ER_EXPLODE = (int)5;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int X264_PART_I4X4 = (int)0x001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_FRONT_CENTER = (int)0x00000004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_STEREO_RIGHT = (int)0x40000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_DRAW_HORIZ_BAND = (int)0x0001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_DCT_COEFF = (int)0x00000040;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_SAD = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_TRUNCATED = (int)16384;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DCT_MLIB = (int)4;
	/**
	 * define<br>
	 * Conversion Error : 53.35.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : /usr/include/libavcodec/version.h:0</i><br>
	 * 53.35.
	 */
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_SKIP_RD = (int)0x00004000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_XVID_ILACE = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_CAVS = (int)15;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_LOSS_COLORQUANT = (int)0x0010;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_RAW = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int SLICE_FLAG_ALLOW_FIELD = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_THREADS = (int)0x00010000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_HINTS_REUSABLE = (int)0x08;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_444_PREDICTIVE = (int)244;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_MB_TYPE = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DCT_AUTO = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_HYBRID = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_RC_STRATEGY_XVID = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_INTRA4x4 = (int)0x0001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_SSIM = (int)0x00100000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_DEFLATE = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LTP = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ER_AGGRESSIVE = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_CBP = (int)0x00020000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEVIS = (int)18;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_INTERNAL_CONTEXT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_NEG_LINESIZES = (int)0x0800;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_EF_BUFFER = (int)(1 << 2);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_TRUNCATED = (int)0x0008;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_ALT_SCAN = (int)0x00100000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = (int)15;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_AA_AUTO = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_PARSER_PTS_NB = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_VP56 = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_LOSS_ALPHA = (int)0x0008;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_N_BIT = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEFAULT_QUANT_BIAS = (int)999999;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_MAIN = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_LOW = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_BASELINE = (int)66;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_TOP_BACK_RIGHT = (int)0x00020000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_GMC = (int)0x0400;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_AUTO_THREADS = (int)0x8000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_SUBFRAMES = (int)0x0100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_MBTREE = (int)0x00040000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AVCODEC_MAX_AUDIO_FRAME_SIZE = (int)192000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_EXTERN_HUFF = (int)0x1000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int PARSER_FLAG_ONCE = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_4MV = (int)0x0004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_LOCAL_HEADER = (int)0x00000008;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_EXPERIMENTAL = (int)0x0200;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_INTRA_VLC = (int)0x00000800;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_AA_FASTINT = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_OLD_MSMPEG4 = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_PICT_INFO = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DCT_INT = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLENEON = (int)22;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_B_BACK = (int)0x00000004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_PS2 = (int)5;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_BRDO = (int)0x00000400;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_NORMALIZE_AQP = (int)0x00020000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_SIMPLE = (int)5;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_TOP_BACK_CENTER = (int)0x00010000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ASPECT_EXTENDED = (int)15;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_MAX_B_FRAMES = (int)16;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = (int)6;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_MINOR = (int)35;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_MIN_BUFFER_SIZE = (int)16384;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_MB_DECISION_RD = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_DC_CLIP = (int)4096;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_W97 = (int)12;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARMV6 = (int)17;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_8x8 = (int)0x0040;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_FLAC_GLOBAL_OPTS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CODER_TYPE_AC = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_PSY = (int)0x00080000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_CAVLC_444 = (int)44;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_CORE = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_4POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int SLICE_FLAG_CODED_ORDER = (int)0x0001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_NON_LINEAR_QUANT = (int)0x00010000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_P1L1 = (int)0x8000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_P1L0 = (int)0x2000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_SIMPLE = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_TOP_CENTER = (int)0x00000800;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_ADVANCED = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_DR1 = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_INTRA_REFRESH = (int)0x00200000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_10 = (int)110;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final String LIBAVCODEC_IDENT = (String)"Lavc";
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_BINK = (int)24;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_MV0 = (int)0x0040;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_INTERLACED = (int)0x0080;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_STEREO_LEFT = (int)0x20000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_CODING = (int)11;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_QPEL_CHROMA = (int)64;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_5POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_5POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_UNOFFICIAL = (int)-1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_B_FOR = (int)0x00000002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int PARSER_FLAG_FETCHED_OFFSET = (int)0x0004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_W53 = (int)11;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_TIFFENC_COMPLEVEL = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_422_INTRA = (int)(122 | (1 << 11));
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_PKT_FLAG_KEY = (int)0x0001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_MEMC_ONLY = (int)0x00001000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_STD_QPEL = (int)128;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_DRC_SCALE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DTG_AFD_SP_4_3 = (int)15;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_MMCO = (int)0x00000800;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = (int)7;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_WMV2 = (int)19;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_AA_INT = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_STRICT = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_AVFRAME_AGE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_L0L1 = (int)((0x1000 | 0x2000) | (0x4000 | 0x8000));
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_HPEL_CHROMA = (int)2048;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_INTRA16x16 = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_QP = (int)0x00002000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_BITSTREAM = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_DCT264 = (int)14;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_MONO = (int)(0x00000004);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_EC_DEBLOCK = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_RESERVED = (int)-100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_16x16 = (int)0x0008;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_MAIN = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_EDGE = (int)1024;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_VP3 = (int)12;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_HWACCEL_VDPAU = (int)0x0080;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DTG_AFD_SAME = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_FAST = (int)0x00000001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_TYPE_USER = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_CHUNKS = (int)0x00008000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_PKT_FLAG_CORRUPT = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_H263P_UMV = (int)0x02000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEALPHA = (int)23;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_MS = (int)8192;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_BIT_RESERVOIR = (int)0x00020000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_QSCALE = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_ACPRED = (int)0x0200;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_QP_RD = (int)0x08000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_FAAN = (int)20;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_INTRA = (int)(1 << 11);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_TYPE_COPY = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_HINTS_VALID = (int)0x01;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_DIRECT2 = (int)0x0100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_2_2 = (int)((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_2_1 = (int)((0x00000001 | 0x00000002) | 0x00000100);
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_AVCODEC_OPEN = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PRED_LEFT = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_INPUT_PRESERVED = (int)0x0100;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_OLD_SAMPLE_FMT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AVPALETTE_COUNT = (int)256;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_COMPRESSION_DEFAULT = (int)-1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG2_HIGH = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_HINTS_READABLE = (int)0x02;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ER_VERY_AGGRESSIVE = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_OLD_ENCODE_AUDIO = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_EXTENDED = (int)88;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_QPEL = (int)0x0010;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_7POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_7POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_LIBMPEG2MMX = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_NORMAL = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_L0 = (int)(0x1000 | 0x2000);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_HWACCEL = (int)0x0010;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_FRONT_LEFT = (int)0x00000001;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_ER = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_L1 = (int)(0x4000 | 0x8000);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_MAIN = (int)77;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUFFER_TYPE_SHARED = (int)4;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_DELAY = (int)0x0020;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = (int)5;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_FASTPSKIP = (int)0x00000100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_AUTODETECT = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_OBMC = (int)0x00000001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_VC1_COMPLEX = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_TOP_BACK_LEFT = (int)0x00008000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_COMPLIANCE_EXPERIMENTAL = (int)-2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_SIDE_RIGHT = (int)0x00000400;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_VIS_MV_P_FOR = (int)0x00000001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_DCT = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLEARM = (int)10;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_THREAD_INIT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_SIMPLE = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final int LIBAVCODEC_BUILD = (int)(53 << 16 | 35 << 8 | 0);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_BPYRAMID = (int)0x00000010;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_MAIN = (int)3;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_AAC_SSR = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_GLOBAL_HEADER = (int)0x00400000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_STEREO_DOWNMIX = (int)(0x20000000 | 0x40000000);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_STEREO = (int)(0x00000001 | 0x00000002);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_BACK_LEFT = (int)0x00000010;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_MAJOR = (int)53;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_PSNR = (int)0x8000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_SMALL_LAST_FRAME = (int)0x0040;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_SKIP = (int)0x0800;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_HIGH_10_INTRA = (int)(110 | (1 << 11));
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int X264_PART_P8X8 = (int)0x010;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_H263P_AIV = (int)0x00000008;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_LOSS_COLORSPACE = (int)0x0004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int AV_EF_CRCCHECK = (int)(1 << 0);
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_GET_PIX_FMT_NAME = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DCT_FAAN = (int)6;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_H264 = (int)11;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_FRONT_RIGHT = (int)0x00000002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_8X8DCT = (int)0x00000080;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LOW_FREQUENCY = (int)0x00000008;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_5POINT1_BACK = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ALPHA_SEMI_TRANSP = (int)0x0002;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_QSCALE_TYPE_H264 = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_TOP_FRONT_RIGHT = (int)0x00004000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_SKIP = (int)0x00000080;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_CONSTRAINED_BASELINE = (int)(66 | (1 << 9));
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DTG_AFD_4_3_SP_14_9 = (int)13;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DCT_ALTIVEC = (int)5;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_MJPEG_GLOBAL_OPTS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_BIT = (int)5;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_AC_VLC = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DEBUG_PTS = (int)0x00000200;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DTG_AFD_4_3 = (int)9;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_NO_PADDING = (int)16;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_LOOP_FILTER = (int)0x00000800;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_ANTIALIAS_ALGO = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_DCTMAX = (int)13;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_IDCT_SIMPLE = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_PARSE_FRAME = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_UNKNOWN = (int)-99;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_VSAD = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_TOP_FRONT_LEFT = (int)0x00001000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_PARAM_CHANGE = (int)0x4000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_SLICE_THREADS = (int)0x2000;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_ALLOC_CONTEXT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_MPEG4_ADVANCED_CORE = (int)12;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int MB_TYPE_INTRA_PCM = (int)0x0004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final long CH_LAYOUT_NATIVE = (long)0x8000000000000000L;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_CAP_PARSE_ONLY = (int)0x0004;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG2_DROP_FRAME_TIMECODE = (int)0x00002000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_DCT_FASTINT = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_AC_PRED = (int)0x01000000;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_UMP4 = (int)8;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int X264_PART_B8X8 = (int)0x100;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_CMP_ZERO = (int)7;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PRED_MEDIAN = (int)2;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_PROFILE_H264_CONSTRAINED = (int)(1 << 9);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CODEC_FLAG_GMC = (int)0x0020;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_FRONT_RIGHT_OF_CENTER = (int)0x00000080;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_ALPHA_TRANSP = (int)0x0001;
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int FF_EC_GUESS_MVS = (int)1;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_REQUEST_CHANNELS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h</i> */
	public static final int CH_LAYOUT_5POINT0_BACK = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final int LIBAVCODEC_VERSION_MICRO = (int)0;
	/** <i>native declaration : /usr/include/libavcodec/version.h</i> */
	public static final boolean FF_API_LAME_GLOBAL_OPTS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h:8815</i> */
	public interface avcodec_default_execute_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg2);
	};
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h:8816</i> */
	public interface avcodec_default_execute2_func_callback extends Callback {
		int apply(AVCodecContext c2, Pointer arg2, int int1, int int2);
	};
	/** <i>native declaration : /usr/include/libavcodec/avcodec.h:8831</i> */
	public interface av_lockmgr_register_cb_callback extends Callback {
		int apply(PointerByReference mutex, int op);
	};
	/**
	 * @deprecated use NULL instead<br>
	 * Original signature : <code>void av_destruct_packet_nofree(AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5916</i>
	 */
	void av_destruct_packet_nofree(AVPacket pkt);
	/**
	 * Default packet destructor.<br>
	 * Original signature : <code>void av_destruct_packet(AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5921</i>
	 */
	void av_destruct_packet(AVPacket pkt);
	/**
	 * Initialize optional fields of a packet with default values.<br>
	 * * @param pkt packet<br>
	 * Original signature : <code>void av_init_packet(AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5927</i>
	 */
	void av_init_packet(AVPacket pkt);
	/**
	 * Allocate the payload of a packet and initialize its fields with<br>
	 * default values.<br>
	 * * @param pkt packet<br>
	 * @param size wanted payload size<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_new_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5936</i>
	 */
	int av_new_packet(AVPacket pkt, int size);
	/**
	 * Reduce packet size, correctly zeroing padding<br>
	 * * @param pkt packet<br>
	 * @param size new size<br>
	 * Original signature : <code>void av_shrink_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5943</i>
	 */
	void av_shrink_packet(AVPacket pkt, int size);
	/**
	 * Increase packet size, correctly zeroing padding<br>
	 * * @param pkt packet<br>
	 * @param grow_by number of bytes by which to increase the size of the packet<br>
	 * Original signature : <code>int av_grow_packet(AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5950</i>
	 */
	int av_grow_packet(AVPacket pkt, int grow_by);
	/**
	 * @warning This is a hack - the packet memory allocation stuff is broken. The<br>
	 * packet is allocated if it was not really allocated.<br>
	 * Original signature : <code>int av_dup_packet(AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5956</i>
	 */
	int av_dup_packet(AVPacket pkt);
	/**
	 * Free a packet.<br>
	 * * @param pkt packet to free<br>
	 * Original signature : <code>void av_free_packet(AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5962</i>
	 */
	void av_free_packet(AVPacket pkt);
	/**
	 * Allocate new information of a packet.<br>
	 * * @param pkt packet<br>
	 * @param type side information type<br>
	 * @param size side information size<br>
	 * @return pointer to fresh allocated data or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_new_side_data(AVPacket*, AVPacketSideDataType, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5971</i>
	 */
	Pointer av_packet_new_side_data(AVPacket pkt, int type, int size);
	/**
	 * Get side information from packet.<br>
	 * * @param pkt packet<br>
	 * @param type desired side information type<br>
	 * @param size pointer for side information size to store (optional)<br>
	 * @return pointer to data if present or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_get_side_data(AVPacket*, AVPacketSideDataType, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5980</i><br>
	 * @deprecated use the safer methods {@link #av_packet_get_side_data(acuitus.wrapffmpeg.AVPacket, int, java.nio.IntBuffer)} and {@link #av_packet_get_side_data(acuitus.wrapffmpeg.AVPacket, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	Pointer av_packet_get_side_data(AVPacket pkt, int type, IntByReference size);
	/**
	 * Get side information from packet.<br>
	 * * @param pkt packet<br>
	 * @param type desired side information type<br>
	 * @param size pointer for side information size to store (optional)<br>
	 * @return pointer to data if present or NULL otherwise<br>
	 * Original signature : <code>uint8_t* av_packet_get_side_data(AVPacket*, AVPacketSideDataType, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:5980</i>
	 */
	Pointer av_packet_get_side_data(AVPacket pkt, int type, IntBuffer size);
	/**
	 * Initialize audio resampling context.<br>
	 * * @param output_channels  number of output channels<br>
	 * @param input_channels   number of input channels<br>
	 * @param output_rate      output sample rate<br>
	 * @param input_rate       input sample rate<br>
	 * @param sample_fmt_out   requested output sample format<br>
	 * @param sample_fmt_in    input sample format<br>
	 * @param filter_length    length of each FIR filter in the filterbank relative to the cutoff frequency<br>
	 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
	 * @param linear           if 1 then the used FIR filter will be linearly interpolated<br>
	 * between the 2 closest, if 0 the closest will be used<br>
	 * @param cutoff           cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
	 * @return allocated ReSampleContext, NULL if error occurred<br>
	 * Original signature : <code>ReSampleContext* av_audio_resample_init(int, int, int, int, AVSampleFormat, AVSampleFormat, int, int, int, double)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6000</i>
	 */
	PointerByReference av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, int sample_fmt_out, int sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff);
	/**
	 * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6002</i><br>
	 * @deprecated use the safer methods {@link #audio_resample(com.sun.jna.ptr.PointerByReference, java.nio.ShortBuffer, java.nio.ShortBuffer, int)} and {@link #audio_resample(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.ShortByReference, int)} instead
	 */
	@Deprecated 
	int audio_resample(Pointer s, ShortByReference output, ShortByReference input, int nb_samples);
	/**
	 * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6002</i>
	 */
	int audio_resample(PointerByReference s, ShortBuffer output, ShortBuffer input, int nb_samples);
	/**
	 * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6002</i>
	 */
	int audio_resample(PointerByReference s, ShortByReference output, ShortByReference input, int nb_samples);
	/**
	 * Free resample context.<br>
	 * * @param s a non-NULL pointer to a resample context previously<br>
	 *          created with av_audio_resample_init()<br>
	 * Original signature : <code>void audio_resample_close(ReSampleContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6009</i><br>
	 * @deprecated use the safer method {@link #audio_resample_close(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void audio_resample_close(Pointer s);
	/**
	 * Free resample context.<br>
	 * * @param s a non-NULL pointer to a resample context previously<br>
	 *          created with av_audio_resample_init()<br>
	 * Original signature : <code>void audio_resample_close(ReSampleContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6009</i>
	 */
	void audio_resample_close(PointerByReference s);
	/**
	 * Initialize an audio resampler.<br>
	 * Note, if either rate is not an integer then simply scale both rates up so they are.<br>
	 * @param filter_length length of each FIR filter in the filterbank relative to the cutoff freq<br>
	 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
	 * @param linear If 1 then the used FIR filter will be linearly interpolated<br>
	 * between the 2 closest, if 0 the closest will be used<br>
	 * @param cutoff cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
	 * Original signature : <code>AVResampleContext* av_resample_init(int, int, int, int, int, double)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6020</i>
	 */
	AvcodecLibrary.AVResampleContext av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
	/**
	 * Resample an array of samples using a previously configured context.<br>
	 * @param src an array of unconsumed samples<br>
	 * @param consumed the number of samples of src which have been consumed are returned here<br>
	 * @param src_size the number of unconsumed samples available<br>
	 * @param dst_size the amount of space in samples available in dst<br>
	 * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.<br>
	 * @return the number of samples written in dst or -1 if an error occurred<br>
	 * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6031</i><br>
	 * @deprecated use the safer methods {@link #av_resample(acuitus.wrapffmpeg.AvcodecLibrary.AVResampleContext, java.nio.ShortBuffer, java.nio.ShortBuffer, java.nio.IntBuffer, int, int, int)} and {@link #av_resample(acuitus.wrapffmpeg.AvcodecLibrary.AVResampleContext, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference, int, int, int)} instead
	 */
	@Deprecated 
	int av_resample(AvcodecLibrary.AVResampleContext c, ShortByReference dst, ShortByReference src, IntByReference consumed, int src_size, int dst_size, int update_ctx);
	/**
	 * Resample an array of samples using a previously configured context.<br>
	 * @param src an array of unconsumed samples<br>
	 * @param consumed the number of samples of src which have been consumed are returned here<br>
	 * @param src_size the number of unconsumed samples available<br>
	 * @param dst_size the amount of space in samples available in dst<br>
	 * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.<br>
	 * @return the number of samples written in dst or -1 if an error occurred<br>
	 * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6031</i>
	 */
	int av_resample(AvcodecLibrary.AVResampleContext c, ShortBuffer dst, ShortBuffer src, IntBuffer consumed, int src_size, int dst_size, int update_ctx);
	/**
	 * Compensate samplerate/timestamp drift. The compensation is done by changing<br>
	 * the resampler parameters, so no audible clicks or similar distortions occur<br>
	 * @param compensation_distance distance in output samples over which the compensation should be performed<br>
	 * @param sample_delta number of output samples which should be output less<br>
	 * * example: av_resample_compensate(c, 10, 500)<br>
	 * here instead of 510 samples only 500 samples would be output<br>
	 * * note, due to rounding the actual compensation might be slightly different,<br>
	 * especially if the compensation_distance is large and the in_rate used during init is small<br>
	 * Original signature : <code>void av_resample_compensate(AVResampleContext*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6043</i>
	 */
	void av_resample_compensate(AvcodecLibrary.AVResampleContext c, int sample_delta, int compensation_distance);
	/**
	 * Original signature : <code>void av_resample_close(AVResampleContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6045</i>
	 */
	void av_resample_close(AvcodecLibrary.AVResampleContext c);
	/**
	 * Allocate memory for a picture.  Call avpicture_free() to free it.<br>
	 * * @see avpicture_fill()<br>
	 * * @param picture the picture to be filled in<br>
	 * @param pix_fmt the format of the picture<br>
	 * @param width the width of the picture<br>
	 * @param height the height of the picture<br>
	 * @return zero if successful, a negative value if not<br>
	 * Original signature : <code>int avpicture_alloc(AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6056</i>
	 */
	int avpicture_alloc(AVPicture picture, int pix_fmt, int width, int height);
	/**
	 * Free a picture previously allocated by avpicture_alloc().<br>
	 * The data buffer used by the AVPicture is freed, but the AVPicture structure<br>
	 * itself is not.<br>
	 * * @param picture the AVPicture to be freed<br>
	 * Original signature : <code>void avpicture_free(AVPicture*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6064</i>
	 */
	void avpicture_free(AVPicture picture);
	/**
	 * Fill in the AVPicture fields.<br>
	 * The fields of the given AVPicture are filled in by using the 'ptr' address<br>
	 * which points to the image data buffer. Depending on the specified picture<br>
	 * format, one or multiple image data pointers and line sizes will be set.<br>
	 * If a planar format is specified, several pointers will be set pointing to<br>
	 * the different picture planes and the line sizes of the different planes<br>
	 * will be stored in the lines_sizes array.<br>
	 * Call with ptr == NULL to get the required size for the ptr buffer.<br>
	 * * To allocate the buffer and fill in the AVPicture fields in one call,<br>
	 * use avpicture_alloc().<br>
	 * * @param picture AVPicture whose fields are to be filled in<br>
	 * @param ptr Buffer which will contain or contains the actual image data<br>
	 * @param pix_fmt The format in which the picture data is stored.<br>
	 * @param width the width of the image in pixels<br>
	 * @param height the height of the image in pixels<br>
	 * @return size of the image data in bytes<br>
	 * Original signature : <code>int avpicture_fill(AVPicture*, uint8_t*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6084</i><br>
	 * @deprecated use the safer methods {@link #avpicture_fill(acuitus.wrapffmpeg.AVPicture, java.nio.ByteBuffer, int, int, int)} and {@link #avpicture_fill(acuitus.wrapffmpeg.AVPicture, com.sun.jna.Pointer, int, int, int)} instead
	 */
	@Deprecated 
	int avpicture_fill(AVPicture picture, Pointer ptr, int pix_fmt, int width, int height);
	/**
	 * Fill in the AVPicture fields.<br>
	 * The fields of the given AVPicture are filled in by using the 'ptr' address<br>
	 * which points to the image data buffer. Depending on the specified picture<br>
	 * format, one or multiple image data pointers and line sizes will be set.<br>
	 * If a planar format is specified, several pointers will be set pointing to<br>
	 * the different picture planes and the line sizes of the different planes<br>
	 * will be stored in the lines_sizes array.<br>
	 * Call with ptr == NULL to get the required size for the ptr buffer.<br>
	 * * To allocate the buffer and fill in the AVPicture fields in one call,<br>
	 * use avpicture_alloc().<br>
	 * * @param picture AVPicture whose fields are to be filled in<br>
	 * @param ptr Buffer which will contain or contains the actual image data<br>
	 * @param pix_fmt The format in which the picture data is stored.<br>
	 * @param width the width of the image in pixels<br>
	 * @param height the height of the image in pixels<br>
	 * @return size of the image data in bytes<br>
	 * Original signature : <code>int avpicture_fill(AVPicture*, uint8_t*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6084</i>
	 */
	int avpicture_fill(AVPicture picture, ByteBuffer ptr, int pix_fmt, int width, int height);
	/**
	 * Copy pixel data from an AVPicture into a buffer.<br>
	 * The data is stored compactly, without any gaps for alignment or padding<br>
	 * which may be applied by avpicture_fill().<br>
	 * * @see avpicture_get_size()<br>
	 * * @param[in] src AVPicture containing image data<br>
	 * @param[in] pix_fmt The format in which the picture data is stored.<br>
	 * @param[in] width the width of the image in pixels.<br>
	 * @param[in] height the height of the image in pixels.<br>
	 * @param[out] dest A buffer into which picture data will be copied.<br>
	 * @param[in] dest_size The size of 'dest'.<br>
	 * @return The number of bytes written to dest, or a negative value (error code) on error.<br>
	 * Original signature : <code>int avpicture_layout(const AVPicture*, PixelFormat, int, int, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6099</i><br>
	 * @deprecated use the safer methods {@link #avpicture_layout(acuitus.wrapffmpeg.AVPicture, int, int, int, java.nio.ByteBuffer, int)} and {@link #avpicture_layout(acuitus.wrapffmpeg.AVPicture, int, int, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, Pointer dest, int dest_size);
	/**
	 * Copy pixel data from an AVPicture into a buffer.<br>
	 * The data is stored compactly, without any gaps for alignment or padding<br>
	 * which may be applied by avpicture_fill().<br>
	 * * @see avpicture_get_size()<br>
	 * * @param[in] src AVPicture containing image data<br>
	 * @param[in] pix_fmt The format in which the picture data is stored.<br>
	 * @param[in] width the width of the image in pixels.<br>
	 * @param[in] height the height of the image in pixels.<br>
	 * @param[out] dest A buffer into which picture data will be copied.<br>
	 * @param[in] dest_size The size of 'dest'.<br>
	 * @return The number of bytes written to dest, or a negative value (error code) on error.<br>
	 * Original signature : <code>int avpicture_layout(const AVPicture*, PixelFormat, int, int, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6099</i>
	 */
	int avpicture_layout(AVPicture src, int pix_fmt, int width, int height, ByteBuffer dest, int dest_size);
	/**
	 * Calculate the size in bytes that a picture of the given width and height<br>
	 * would occupy if stored in the given picture format.<br>
	 * Note that this returns the size of a compact representation as generated<br>
	 * by avpicture_layout(), which can be smaller than the size required for e.g.<br>
	 * avpicture_fill().<br>
	 * * @param pix_fmt the given picture format<br>
	 * @param width the width of the image<br>
	 * @param height the height of the image<br>
	 * @return Image data size in bytes or -1 on error (e.g. too large dimensions).<br>
	 * Original signature : <code>int avpicture_get_size(PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6112</i>
	 */
	int avpicture_get_size(int pix_fmt, int width, int height);
	/**
	 * Original signature : <code>void avcodec_get_chroma_sub_sample(PixelFormat, int*, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6114</i><br>
	 * @deprecated use the safer methods {@link #avcodec_get_chroma_sub_sample(int, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_get_chroma_sub_sample(int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	void avcodec_get_chroma_sub_sample(int pix_fmt, IntByReference h_shift, IntByReference v_shift);
	/**
	 * Original signature : <code>void avcodec_get_chroma_sub_sample(PixelFormat, int*, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6114</i>
	 */
	void avcodec_get_chroma_sub_sample(int pix_fmt, IntBuffer h_shift, IntBuffer v_shift);
	/**
	 * Original signature : <code>char* avcodec_get_pix_fmt_name(PixelFormat)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6116</i>
	 */
	String avcodec_get_pix_fmt_name(int pix_fmt);
	/**
	 * Original signature : <code>void avcodec_set_dimensions(AVCodecContext*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6118</i>
	 */
	void avcodec_set_dimensions(AVCodecContext s, int width, int height);
	/**
	 * Return a value representing the fourCC code associated to the<br>
	 * pixel format pix_fmt, or 0 if no associated fourCC code can be<br>
	 * found.<br>
	 * Original signature : <code>int avcodec_pix_fmt_to_codec_tag(PixelFormat)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6125</i>
	 */
	int avcodec_pix_fmt_to_codec_tag(int pix_fmt);
	/**
	 * Put a string representing the codec tag codec_tag in buf.<br>
	 * * @param buf_size size in bytes of buf<br>
	 * @return the length of the string that would have been generated if<br>
	 * enough space had been available, excluding the trailing null<br>
	 * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6133</i><br>
	 * @deprecated use the safer methods {@link #av_get_codec_tag_string(java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize, int)} and {@link #av_get_codec_tag_string(com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize, int)} instead
	 */
	@Deprecated 
	NativeSize av_get_codec_tag_string(Pointer buf, NativeSize buf_size, int codec_tag);
	/**
	 * Put a string representing the codec tag codec_tag in buf.<br>
	 * * @param buf_size size in bytes of buf<br>
	 * @return the length of the string that would have been generated if<br>
	 * enough space had been available, excluding the trailing null<br>
	 * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6133</i>
	 */
	NativeSize av_get_codec_tag_string(ByteBuffer buf, NativeSize buf_size, int codec_tag);
	/**
	 * Compute what kind of losses will occur when converting from one specific<br>
	 * pixel format to another.<br>
	 * When converting from one pixel format to another, information loss may occur.<br>
	 * For example, when converting from RGB24 to GRAY, the color information will<br>
	 * be lost. Similarly, other losses occur when converting from some formats to<br>
	 * other formats. These losses can involve loss of chroma, but also loss of<br>
	 * resolution, loss of color depth, loss due to the color space conversion, loss<br>
	 * of the alpha bits or loss due to color quantization.<br>
	 * avcodec_get_fix_fmt_loss() informs you about the various types of losses<br>
	 * which will occur when converting from one pixel format to another.<br>
	 * * @param[in] dst_pix_fmt destination pixel format<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @return Combination of flags informing you what kind of losses will occur.<br>
	 * Original signature : <code>int avcodec_get_pix_fmt_loss(PixelFormat, PixelFormat, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6151</i>
	 */
	int avcodec_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
	/**
	 * Find the best pixel format to convert to given a certain source pixel<br>
	 * format.  When converting from one pixel format to another, information loss<br>
	 * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
	 * information will be lost. Similarly, other losses occur when converting from<br>
	 * some formats to other formats. avcodec_find_best_pix_fmt() searches which of<br>
	 * the given pixel formats should be used to suffer the least amount of loss.<br>
	 * The pixel formats from which it chooses one, are determined by the<br>
	 * pix_fmt_mask parameter.<br>
	 * * @code<br>
	 * src_pix_fmt = PIX_FMT_YUV420P;<br>
	 * pix_fmt_mask = (1 << PIX_FMT_YUV422P) || (1 << PIX_FMT_RGB24);<br>
	 * dst_pix_fmt = avcodec_find_best_pix_fmt(pix_fmt_mask, src_pix_fmt, alpha, &loss);<br>
	 * @endcode<br>
	 * * @param[in] pix_fmt_mask bitmask determining which pixel format to choose from<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
	 * @return The best pixel format to convert to or -1 if none was found.<br>
	 * Original signature : <code>PixelFormat avcodec_find_best_pix_fmt(int64_t, PixelFormat, int, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6173</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_best_pix_fmt(long, int, int, java.nio.IntBuffer)} and {@link #avcodec_find_best_pix_fmt(long, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_find_best_pix_fmt(long pix_fmt_mask, int src_pix_fmt, int has_alpha, IntByReference loss_ptr);
	/**
	 * Find the best pixel format to convert to given a certain source pixel<br>
	 * format.  When converting from one pixel format to another, information loss<br>
	 * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
	 * information will be lost. Similarly, other losses occur when converting from<br>
	 * some formats to other formats. avcodec_find_best_pix_fmt() searches which of<br>
	 * the given pixel formats should be used to suffer the least amount of loss.<br>
	 * The pixel formats from which it chooses one, are determined by the<br>
	 * pix_fmt_mask parameter.<br>
	 * * @code<br>
	 * src_pix_fmt = PIX_FMT_YUV420P;<br>
	 * pix_fmt_mask = (1 << PIX_FMT_YUV422P) || (1 << PIX_FMT_RGB24);<br>
	 * dst_pix_fmt = avcodec_find_best_pix_fmt(pix_fmt_mask, src_pix_fmt, alpha, &loss);<br>
	 * @endcode<br>
	 * * @param[in] pix_fmt_mask bitmask determining which pixel format to choose from<br>
	 * @param[in] src_pix_fmt source pixel format<br>
	 * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
	 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
	 * @return The best pixel format to convert to or -1 if none was found.<br>
	 * Original signature : <code>PixelFormat avcodec_find_best_pix_fmt(int64_t, PixelFormat, int, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6173</i>
	 */
	int avcodec_find_best_pix_fmt(long pix_fmt_mask, int src_pix_fmt, int has_alpha, IntBuffer loss_ptr);
	/**
	 * Original signature : <code>int img_get_alpha_info(const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6175</i>
	 */
	int img_get_alpha_info(AVPicture src, int pix_fmt, int width, int height);
	/**
	 * deinterlace - if not supported return -1<br>
	 * Original signature : <code>int avpicture_deinterlace(AVPicture*, const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6180</i>
	 */
	int avpicture_deinterlace(AVPicture dst, AVPicture src, int pix_fmt, int width, int height);
	/**
	 * If c is NULL, returns the first registered codec,<br>
	 * if c is non-NULL, returns the next registered codec after c,<br>
	 * or NULL if c is the last one.<br>
	 * Original signature : <code>AVCodec* av_codec_next(AVCodec*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6187</i>
	 */
	AVCodec av_codec_next(AVCodec c);
	/**
	 * Return the LIBAVCODEC_VERSION_INT constant.<br>
	 * Original signature : <code>int avcodec_version()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6192</i>
	 */
	int avcodec_version();
	/**
	 * Return the libavcodec build-time configuration.<br>
	 * Original signature : <code>char* avcodec_configuration()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6197</i>
	 */
	String avcodec_configuration();
	/**
	 * Return the libavcodec license.<br>
	 * Original signature : <code>char* avcodec_license()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6202</i>
	 */
	String avcodec_license();
	/**
	 * Original signature : <code>void avcodec_init()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6204</i>
	 */
	void avcodec_init();
	/**
	 * Register the codec codec and initialize libavcodec.<br>
	 * * @warning either this function or avcodec_register_all() must be called<br>
	 * before any other libavcodec functions.<br>
	 * * @see avcodec_register_all()<br>
	 * Original signature : <code>void avcodec_register(AVCodec*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6212</i>
	 */
	void avcodec_register(AVCodec codec);
	/**
	 * Find a registered encoder with a matching codec ID.<br>
	 * * @param id CodecID of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder(CodecID)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6219</i>
	 */
	AVCodec avcodec_find_encoder(int id);
	/**
	 * Find a registered encoder with the specified name.<br>
	 * * @param name name of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6226</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_encoder_by_name(java.lang.String)} and {@link #avcodec_find_encoder_by_name(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	AVCodec avcodec_find_encoder_by_name(Pointer name);
	/**
	 * Find a registered encoder with the specified name.<br>
	 * * @param name name of the requested encoder<br>
	 * @return An encoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6226</i>
	 */
	AVCodec avcodec_find_encoder_by_name(String name);
	/**
	 * Find a registered decoder with a matching codec ID.<br>
	 * * @param id CodecID of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder(CodecID)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6233</i>
	 */
	AVCodec avcodec_find_decoder(int id);
	/**
	 * Find a registered decoder with the specified name.<br>
	 * * @param name name of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6240</i><br>
	 * @deprecated use the safer methods {@link #avcodec_find_decoder_by_name(java.lang.String)} and {@link #avcodec_find_decoder_by_name(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	AVCodec avcodec_find_decoder_by_name(Pointer name);
	/**
	 * Find a registered decoder with the specified name.<br>
	 * * @param name name of the requested decoder<br>
	 * @return A decoder if one was found, NULL otherwise.<br>
	 * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6240</i>
	 */
	AVCodec avcodec_find_decoder_by_name(String name);
	/**
	 * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6242</i><br>
	 * @deprecated use the safer methods {@link #avcodec_string(java.nio.ByteBuffer, int, acuitus.wrapffmpeg.AVCodecContext, int)} and {@link #avcodec_string(com.sun.jna.Pointer, int, acuitus.wrapffmpeg.AVCodecContext, int)} instead
	 */
	@Deprecated 
	void avcodec_string(Pointer buf, int buf_size, AVCodecContext enc, int encode);
	/**
	 * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6242</i>
	 */
	void avcodec_string(ByteBuffer buf, int buf_size, AVCodecContext enc, int encode);
	/**
	 * Return a name for the specified profile, if available.<br>
	 * * @param codec the codec that is searched for the given profile<br>
	 * @param profile the profile value for which a name is requested<br>
	 * @return A name for the profile if found, NULL otherwise.<br>
	 * Original signature : <code>char* av_get_profile_name(const AVCodec*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6250</i>
	 */
	String av_get_profile_name(AVCodec codec, int profile);
	/**
	 * Original signature : <code>void avcodec_get_context_defaults(AVCodecContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6252</i>
	 */
	void avcodec_get_context_defaults(AVCodecContext s);
	/**
	 * Original signature : <code>void avcodec_get_context_defaults2(AVCodecContext*, AVMediaType)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6254</i>
	 */
	void avcodec_get_context_defaults2(AVCodecContext s, int arg1);
	/**
	 * Set the fields of the given AVCodecContext to default values corresponding<br>
	 * to the given codec (defaults may be codec-dependent).<br>
	 * * Do not call this function if a non-NULL codec has been passed<br>
	 * to avcodec_alloc_context3() that allocated this AVCodecContext.<br>
	 * If codec is non-NULL, it is illegal to call avcodec_open2() with a<br>
	 * different codec on this AVCodecContext.<br>
	 * Original signature : <code>int avcodec_get_context_defaults3(AVCodecContext*, AVCodec*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6264</i>
	 */
	int avcodec_get_context_defaults3(AVCodecContext s, AVCodec codec);
	/**
	 * Original signature : <code>AVCodecContext* avcodec_alloc_context()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6266</i>
	 */
	AVCodecContext avcodec_alloc_context();
	/**
	 * Original signature : <code>AVCodecContext* avcodec_alloc_context2(AVMediaType)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6268</i>
	 */
	AVCodecContext avcodec_alloc_context2(int arg1);
	/**
	 * Allocate an AVCodecContext and set its fields to default values.  The<br>
	 * resulting struct can be deallocated by calling avcodec_close() on it followed<br>
	 * by av_free().<br>
	 * * @param codec if non-NULL, allocate private data and initialize defaults<br>
	 *              for the given codec. It is illegal to then call avcodec_open2()<br>
	 *              with a different codec.<br>
	 * * @return An AVCodecContext filled with default values or NULL on failure.<br>
	 * @see avcodec_get_context_defaults<br>
	 * Original signature : <code>AVCodecContext* avcodec_alloc_context3(AVCodec*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6280</i>
	 */
	AVCodecContext avcodec_alloc_context3(AVCodec codec);
	/**
	 * Copy the settings of the source AVCodecContext into the destination<br>
	 * AVCodecContext. The resulting destination codec context will be<br>
	 * unopened, i.e. you are required to call avcodec_open2() before you<br>
	 * can use this AVCodecContext to decode/encode video/audio data.<br>
	 * * @param dest target codec context, should be initialized with<br>
	 *             avcodec_alloc_context3(), but otherwise uninitialized<br>
	 * @param src source codec context<br>
	 * @return AVERROR() on error (e.g. memory allocation error), 0 on success<br>
	 * Original signature : <code>int avcodec_copy_context(AVCodecContext*, const AVCodecContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6292</i>
	 */
	int avcodec_copy_context(AVCodecContext dest, AVCodecContext src);
	/**
	 * Set the fields of the given AVFrame to default values.<br>
	 * * @param pic The AVFrame of which the fields should be set to default values.<br>
	 * Original signature : <code>void avcodec_get_frame_defaults(AVFrame*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6298</i>
	 */
	void avcodec_get_frame_defaults(AVFrame pic);
	/**
	 * Allocate an AVFrame and set its fields to default values.  The resulting<br>
	 * struct can be deallocated by simply calling av_free().<br>
	 * * @return An AVFrame filled with default values or NULL on failure.<br>
	 * @see avcodec_get_frame_defaults<br>
	 * Original signature : <code>AVFrame* avcodec_alloc_frame()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6306</i>
	 */
	AVFrame avcodec_alloc_frame();
	/**
	 * Original signature : <code>int avcodec_default_get_buffer(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6308</i>
	 */
	int avcodec_default_get_buffer(AVCodecContext s, AVFrame pic);
	/**
	 * Original signature : <code>void avcodec_default_release_buffer(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6310</i>
	 */
	void avcodec_default_release_buffer(AVCodecContext s, AVFrame pic);
	/**
	 * Original signature : <code>int avcodec_default_reget_buffer(AVCodecContext*, AVFrame*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6312</i>
	 */
	int avcodec_default_reget_buffer(AVCodecContext s, AVFrame pic);
	/**
	 * Return the amount of padding in pixels which the get_buffer callback must<br>
	 * provide around the edge of the image for codecs which do not have the<br>
	 * CODEC_FLAG_EMU_EDGE flag.<br>
	 * * @return Required padding in pixels.<br>
	 * Original signature : <code>int avcodec_get_edge_width()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6320</i>
	 */
	int avcodec_get_edge_width();
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you do not use any horizontal<br>
	 * padding.<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6330</i><br>
	 * @deprecated use the safer methods {@link #avcodec_align_dimensions(acuitus.wrapffmpeg.AVCodecContext, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_align_dimensions(acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	void avcodec_align_dimensions(AVCodecContext s, IntByReference width, IntByReference height);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you do not use any horizontal<br>
	 * padding.<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6330</i>
	 */
	void avcodec_align_dimensions(AVCodecContext s, IntBuffer width, IntBuffer height);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you also ensure that all<br>
	 * line sizes are a multiple of the respective linesize_align[i].<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[4])</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6340</i><br>
	 * @deprecated use the safer methods {@link #avcodec_align_dimensions2(acuitus.wrapffmpeg.AVCodecContext, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #avcodec_align_dimensions2(acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	void avcodec_align_dimensions2(AVCodecContext s, IntByReference width, IntByReference height, IntByReference linesize_align);
	/**
	 * Modify width and height values so that they will result in a memory<br>
	 * buffer that is acceptable for the codec if you also ensure that all<br>
	 * line sizes are a multiple of the respective linesize_align[i].<br>
	 * * May only be used if a codec with CODEC_CAP_DR1 has been opened.<br>
	 * If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been increased<br>
	 * according to avcodec_get_edge_width() before.<br>
	 * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[4])</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6340</i>
	 */
	void avcodec_align_dimensions2(AVCodecContext s, IntBuffer width, IntBuffer height, IntBuffer linesize_align);
	/**
	 * Original signature : <code>PixelFormat avcodec_default_get_format(AVCodecContext*, PixelFormat*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6342</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_get_format(acuitus.wrapffmpeg.AVCodecContext, java.nio.IntBuffer)} and {@link #avcodec_default_get_format(acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_default_get_format(AVCodecContext s, IntByReference fmt);
	/**
	 * Original signature : <code>PixelFormat avcodec_default_get_format(AVCodecContext*, PixelFormat*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6342</i>
	 */
	int avcodec_default_get_format(AVCodecContext s, IntBuffer fmt);
	/**
	 * Original signature : <code>int avcodec_thread_init(AVCodecContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6344</i>
	 */
	int avcodec_thread_init(AVCodecContext s, int thread_count);
	/**
	 * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6346</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_execute(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AvcodecLibrary.avcodec_default_execute_func_callback, com.sun.jna.Pointer, java.nio.IntBuffer, int, int)} and {@link #avcodec_default_execute(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AvcodecLibrary.avcodec_default_execute_func_callback, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int, int)} instead
	 */
	@Deprecated 
	int avcodec_default_execute(AVCodecContext c, AvcodecLibrary.avcodec_default_execute_func_callback func, Pointer arg, IntByReference ret, int count, int size);
	/**
	 * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6346</i>
	 */
	int avcodec_default_execute(AVCodecContext c, AvcodecLibrary.avcodec_default_execute_func_callback func, Pointer arg, IntBuffer ret, int count, int size);
	/**
	 * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6348</i><br>
	 * @deprecated use the safer methods {@link #avcodec_default_execute2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AvcodecLibrary.avcodec_default_execute2_func_callback, com.sun.jna.Pointer, java.nio.IntBuffer, int)} and {@link #avcodec_default_execute2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AvcodecLibrary.avcodec_default_execute2_func_callback, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated 
	int avcodec_default_execute2(AVCodecContext c, AvcodecLibrary.avcodec_default_execute2_func_callback func, Pointer arg, IntByReference ret, int count);
	/**
	 * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6348</i>
	 */
	int avcodec_default_execute2(AVCodecContext c, AvcodecLibrary.avcodec_default_execute2_func_callback func, Pointer arg, IntBuffer ret, int count);
	/**
	 * Original signature : <code>int avcodec_open(AVCodecContext*, AVCodec*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6350</i>
	 */
	int avcodec_open(AVCodecContext avctx, AVCodec codec);
	/**
	 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
	 * function the context has to be allocated with avcodec_alloc_context3().<br>
	 * * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
	 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
	 * retrieving a codec.<br>
	 * * @warning This function is not thread safe!<br>
	 * * @code<br>
	 * avcodec_register_all();<br>
	 * av_dict_set(&opts, "b", "2.5M", 0);<br>
	 * codec = avcodec_find_decoder(CODEC_ID_H264);<br>
	 * if (!codec)<br>
	 *     exit(1);<br>
	 * * context = avcodec_alloc_context3(codec);<br>
	 * * if (avcodec_open2(context, codec, opts) < 0)<br>
	 *     exit(1);<br>
	 * @endcode<br>
	 * * @param avctx The context to initialize.<br>
	 * @param codec The codec to open this context for. If a non-NULL codec has been<br>
	 *              previously passed to avcodec_alloc_context3() or<br>
	 *              avcodec_get_context_defaults3() for this context, then this<br>
	 *              parameter MUST be either NULL or equal to the previously passed<br>
	 *              codec.<br>
	 * @param options A dictionary filled with AVCodecContext and codec-private options.<br>
	 *                On return this object will be filled with options that were not found.<br>
	 * * @return zero on success, a negative value on error<br>
	 * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),<br>
	 *      av_dict_set(), av_opt_find().<br>
	 * Original signature : <code>int avcodec_open2(AVCodecContext*, AVCodec*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6381</i>
	 */
	int avcodec_open2(AVCodecContext avctx, AVCodec codec, PointerByReference options);
	/**
	 * Wrapper function which calls avcodec_decode_audio4.<br>
	 * * @deprecated Use avcodec_decode_audio4 instead.<br>
	 * * Decode the audio frame of size avpkt->size from avpkt->data into samples.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame. In this case,<br>
	 * avcodec_decode_audio3 has to be called again with an AVPacket that contains<br>
	 * the remaining data in order to decode the second frame etc.<br>
	 * If no frame<br>
	 * could be outputted, frame_size_ptr is zero. Otherwise, it is the<br>
	 * decompressed frame size in bytes.<br>
	 * * @warning You must set frame_size_ptr to the allocated size of the<br>
	 * output buffer before calling avcodec_decode_audio3().<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer avpkt->data should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @warning You must not provide a custom get_buffer() when using<br>
	 * avcodec_decode_audio3().  Doing so will override it with<br>
	 * avcodec_default_get_buffer.  Use avcodec_decode_audio4() instead,<br>
	 * which does allow the application to provide a custom get_buffer().<br>
	 * * @note You might have to align the input buffer avpkt->data and output buffer<br>
	 * samples. The alignment requirements depend on the CPU: On some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum and<br>
	 * samples should be 16 byte aligned unless the CPU doesn't need it<br>
	 * (AltiVec and SSE do).<br>
	 * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
	 * between input and output, these need to be fed with avpkt->data=NULL,<br>
	 * avpkt->size=0 at the end to return the remaining frames.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] samples the output buffer, sample type in avctx->sample_fmt<br>
	 *                     If the sample format is planar, each channel plane will<br>
	 *                     be the same size, with no padding between channels.<br>
	 * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields.<br>
	 *            All decoders are designed to use the least fields possible though.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame data was decompressed (used) from the input AVPacket.<br>
	 * Original signature : <code>int avcodec_decode_audio3(AVCodecContext*, int16_t*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6427</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_audio3(acuitus.wrapffmpeg.AVCodecContext, java.nio.ShortBuffer, java.nio.IntBuffer, acuitus.wrapffmpeg.AVPacket)} and {@link #avcodec_decode_audio3(acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference, acuitus.wrapffmpeg.AVPacket)} instead
	 */
	@Deprecated 
	int avcodec_decode_audio3(AVCodecContext avctx, ShortByReference samples, IntByReference frame_size_ptr, AVPacket avpkt);
	/**
	 * Wrapper function which calls avcodec_decode_audio4.<br>
	 * * @deprecated Use avcodec_decode_audio4 instead.<br>
	 * * Decode the audio frame of size avpkt->size from avpkt->data into samples.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame. In this case,<br>
	 * avcodec_decode_audio3 has to be called again with an AVPacket that contains<br>
	 * the remaining data in order to decode the second frame etc.<br>
	 * If no frame<br>
	 * could be outputted, frame_size_ptr is zero. Otherwise, it is the<br>
	 * decompressed frame size in bytes.<br>
	 * * @warning You must set frame_size_ptr to the allocated size of the<br>
	 * output buffer before calling avcodec_decode_audio3().<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer avpkt->data should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @warning You must not provide a custom get_buffer() when using<br>
	 * avcodec_decode_audio3().  Doing so will override it with<br>
	 * avcodec_default_get_buffer.  Use avcodec_decode_audio4() instead,<br>
	 * which does allow the application to provide a custom get_buffer().<br>
	 * * @note You might have to align the input buffer avpkt->data and output buffer<br>
	 * samples. The alignment requirements depend on the CPU: On some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum and<br>
	 * samples should be 16 byte aligned unless the CPU doesn't need it<br>
	 * (AltiVec and SSE do).<br>
	 * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
	 * between input and output, these need to be fed with avpkt->data=NULL,<br>
	 * avpkt->size=0 at the end to return the remaining frames.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] samples the output buffer, sample type in avctx->sample_fmt<br>
	 *                     If the sample format is planar, each channel plane will<br>
	 *                     be the same size, with no padding between channels.<br>
	 * @param[in,out] frame_size_ptr the output buffer size in bytes<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields.<br>
	 *            All decoders are designed to use the least fields possible though.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame data was decompressed (used) from the input AVPacket.<br>
	 * Original signature : <code>int avcodec_decode_audio3(AVCodecContext*, int16_t*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6427</i>
	 */
	int avcodec_decode_audio3(AVCodecContext avctx, ShortBuffer samples, IntBuffer frame_size_ptr, AVPacket avpkt);
	/**
	 * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
	 * * Some decoders may support multiple frames in a single AVPacket. Such<br>
	 * decoders would then just decode the first frame. In this case,<br>
	 * avcodec_decode_audio4 has to be called again with an AVPacket containing<br>
	 * the remaining data in order to decode the second frame, etc...<br>
	 * Even if no frames are returned, the packet needs to be fed to the decoder<br>
	 * with remaining data until it is completely consumed or an error occurs.<br>
	 * * @warning The input buffer, avpkt->data must be FF_INPUT_BUFFER_PADDING_SIZE<br>
	 *          larger than the actual read bytes because some optimized bitstream<br>
	 *          readers read 32 or 64 bits at once and could read over the end.<br>
	 * * @note You might have to align the input buffer. The alignment requirements<br>
	 *       depend on the CPU and the decoder.<br>
	 * * @param      avctx the codec context<br>
	 * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
	 *                   Decoders request a buffer of a particular size by setting<br>
	 *                   AVFrame.nb_samples prior to calling get_buffer(). The<br>
	 *                   decoder may, however, only utilize part of the buffer by<br>
	 *                   setting AVFrame.nb_samples to a smaller value in the<br>
	 *                   output frame.<br>
	 * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
	 *                           non-zero.<br>
	 * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
	 *                   At least avpkt->data and avpkt->size should be set. Some<br>
	 *                   decoders might also require additional fields to be set.<br>
	 * @return A negative error code is returned if an error occurred during<br>
	 *         decoding, otherwise the number of bytes consumed from the input<br>
	 *         AVPacket is returned.<br>
	 * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6458</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_audio4(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVFrame, java.nio.IntBuffer, acuitus.wrapffmpeg.AVPacket)} and {@link #avcodec_decode_audio4(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVFrame, com.sun.jna.ptr.IntByReference, acuitus.wrapffmpeg.AVPacket)} instead
	 */
	@Deprecated 
	int avcodec_decode_audio4(AVCodecContext avctx, AVFrame frame, IntByReference got_frame_ptr, AVPacket avpkt);
	/**
	 * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
	 * * Some decoders may support multiple frames in a single AVPacket. Such<br>
	 * decoders would then just decode the first frame. In this case,<br>
	 * avcodec_decode_audio4 has to be called again with an AVPacket containing<br>
	 * the remaining data in order to decode the second frame, etc...<br>
	 * Even if no frames are returned, the packet needs to be fed to the decoder<br>
	 * with remaining data until it is completely consumed or an error occurs.<br>
	 * * @warning The input buffer, avpkt->data must be FF_INPUT_BUFFER_PADDING_SIZE<br>
	 *          larger than the actual read bytes because some optimized bitstream<br>
	 *          readers read 32 or 64 bits at once and could read over the end.<br>
	 * * @note You might have to align the input buffer. The alignment requirements<br>
	 *       depend on the CPU and the decoder.<br>
	 * * @param      avctx the codec context<br>
	 * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
	 *                   Decoders request a buffer of a particular size by setting<br>
	 *                   AVFrame.nb_samples prior to calling get_buffer(). The<br>
	 *                   decoder may, however, only utilize part of the buffer by<br>
	 *                   setting AVFrame.nb_samples to a smaller value in the<br>
	 *                   output frame.<br>
	 * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
	 *                           non-zero.<br>
	 * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
	 *                   At least avpkt->data and avpkt->size should be set. Some<br>
	 *                   decoders might also require additional fields to be set.<br>
	 * @return A negative error code is returned if an error occurred during<br>
	 *         decoding, otherwise the number of bytes consumed from the input<br>
	 *         AVPacket is returned.<br>
	 * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6458</i>
	 */
	int avcodec_decode_audio4(AVCodecContext avctx, AVFrame frame, IntBuffer got_frame_ptr, AVPacket avpkt);
	/**
	 * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame.<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @note You might have to align the input buffer avpkt->data.<br>
	 * The alignment requirements depend on the CPU: on some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum.<br>
	 * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
	 * between input and output, these need to be fed with avpkt->data=NULL,<br>
	 * avpkt->size=0 at the end to return the remaining frames.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 *             Use avcodec_alloc_frame to get an AVFrame, the codec will<br>
	 *             allocate memory for the actual bitmap.<br>
	 *             with default get/release_buffer(), the decoder frees/reuses the bitmap as it sees fit.<br>
	 *             with overridden get/release_buffer() (needs CODEC_CAP_DR1) the user decides into what buffer the decoder<br>
	 *                   decodes and the decoder tells the user once it does not need the data anymore,<br>
	 *                   the user app can at this point free/reuse/keep the memory as it sees fit.<br>
	 * * @param[in] avpkt The input AVpacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields like<br>
	 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
	 *            fields possible.<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6494</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_video2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVFrame, java.nio.IntBuffer, acuitus.wrapffmpeg.AVPacket)} and {@link #avcodec_decode_video2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVFrame, com.sun.jna.ptr.IntByReference, acuitus.wrapffmpeg.AVPacket)} instead
	 */
	@Deprecated 
	int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntByReference got_picture_ptr, AVPacket avpkt);
	/**
	 * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
	 * Some decoders may support multiple frames in a single AVPacket, such<br>
	 * decoders would then just decode the first frame.<br>
	 * * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than<br>
	 * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
	 * bits at once and could read over the end.<br>
	 * * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
	 * no overreading happens for damaged MPEG streams.<br>
	 * * @note You might have to align the input buffer avpkt->data.<br>
	 * The alignment requirements depend on the CPU: on some CPUs it isn't<br>
	 * necessary at all, on others it won't work at all if not aligned and on others<br>
	 * it will work but it will have an impact on performance.<br>
	 * * In practice, avpkt->data should have 4 byte alignment at minimum.<br>
	 * * @note Codecs which have the CODEC_CAP_DELAY capability set have a delay<br>
	 * between input and output, these need to be fed with avpkt->data=NULL,<br>
	 * avpkt->size=0 at the end to return the remaining frames.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
	 *             Use avcodec_alloc_frame to get an AVFrame, the codec will<br>
	 *             allocate memory for the actual bitmap.<br>
	 *             with default get/release_buffer(), the decoder frees/reuses the bitmap as it sees fit.<br>
	 *             with overridden get/release_buffer() (needs CODEC_CAP_DR1) the user decides into what buffer the decoder<br>
	 *                   decodes and the decoder tells the user once it does not need the data anymore,<br>
	 *                   the user app can at this point free/reuse/keep the memory as it sees fit.<br>
	 * * @param[in] avpkt The input AVpacket containing the input buffer.<br>
	 *            You can create such packet with av_init_packet() and by then setting<br>
	 *            data and size, some decoders might in addition need other fields like<br>
	 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
	 *            fields possible.<br>
	 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
	 * @return On error a negative value is returned, otherwise the number of bytes<br>
	 * used or zero if no frame could be decompressed.<br>
	 * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6494</i>
	 */
	int avcodec_decode_video2(AVCodecContext avctx, AVFrame picture, IntBuffer got_picture_ptr, AVPacket avpkt);
	/**
	 * Decode a subtitle message.<br>
	 * Return a negative value on error, otherwise return the number of bytes used.<br>
	 * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
	 * Otherwise, the subtitle is stored in *sub.<br>
	 * Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
	 * simplicity, because the performance difference is expect to be negligible<br>
	 * and reusing a get_buffer written for video codecs would probably perform badly<br>
	 * due to a potentially very different allocation pattern.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] sub The AVSubtitle in which the decoded subtitle will be stored, must be<br>
	 * freed with avsubtitle_free if *got_sub_ptr is set.<br>
	 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6511</i><br>
	 * @deprecated use the safer methods {@link #avcodec_decode_subtitle2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVSubtitle, java.nio.IntBuffer, acuitus.wrapffmpeg.AVPacket)} and {@link #avcodec_decode_subtitle2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVSubtitle, com.sun.jna.ptr.IntByReference, acuitus.wrapffmpeg.AVPacket)} instead
	 */
	@Deprecated 
	int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntByReference got_sub_ptr, AVPacket avpkt);
	/**
	 * Decode a subtitle message.<br>
	 * Return a negative value on error, otherwise return the number of bytes used.<br>
	 * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
	 * Otherwise, the subtitle is stored in *sub.<br>
	 * Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
	 * simplicity, because the performance difference is expect to be negligible<br>
	 * and reusing a get_buffer written for video codecs would probably perform badly<br>
	 * due to a potentially very different allocation pattern.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] sub The AVSubtitle in which the decoded subtitle will be stored, must be<br>
	 * freed with avsubtitle_free if *got_sub_ptr is set.<br>
	 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
	 * @param[in] avpkt The input AVPacket containing the input buffer.<br>
	 * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6511</i>
	 */
	int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub, IntBuffer got_sub_ptr, AVPacket avpkt);
	/**
	 * Free all allocated data in the given subtitle struct.<br>
	 * * @param sub AVSubtitle to free.<br>
	 * Original signature : <code>void avsubtitle_free(AVSubtitle*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6517</i>
	 */
	void avsubtitle_free(AVSubtitle sub);
	/**
	 * Encode an audio frame from samples into buf.<br>
	 * * @deprecated Use avcodec_encode_audio2 instead.<br>
	 * * @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.<br>
	 * However, for codecs with avctx->frame_size equal to 0 (e.g. PCM) the user<br>
	 * will know how much space is needed because it depends on the value passed<br>
	 * in buf_size as described below. In that case a lower value can be used.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer<br>
	 * @param[in] buf_size the output buffer size<br>
	 * @param[in] samples the input buffer containing the samples<br>
	 * The number of samples read from this buffer is frame_size*channels,<br>
	 * both of which are defined in avctx.<br>
	 * For codecs which have avctx->frame_size equal to 0 (e.g. PCM) the number of<br>
	 * samples read from samples is equal to:<br>
	 * buf_size * 8 / (avctx->channels * av_get_bits_per_sample(avctx->codec_id))<br>
	 * This also implies that av_get_bits_per_sample() must not return 0 for these<br>
	 * codecs.<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used to encode the data read from the input buffer.<br>
	 * Original signature : <code>int avcodec_encode_audio(AVCodecContext*, uint8_t*, int, const short*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6540</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_audio(acuitus.wrapffmpeg.AVCodecContext, java.nio.ByteBuffer, int, short[])} and {@link #avcodec_encode_audio(acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.Pointer, int, com.sun.jna.ptr.ShortByReference)} instead
	 */
	@Deprecated 
	int avcodec_encode_audio(AVCodecContext avctx, Pointer buf, int buf_size, ShortByReference samples);
	/**
	 * Encode an audio frame from samples into buf.<br>
	 * * @deprecated Use avcodec_encode_audio2 instead.<br>
	 * * @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.<br>
	 * However, for codecs with avctx->frame_size equal to 0 (e.g. PCM) the user<br>
	 * will know how much space is needed because it depends on the value passed<br>
	 * in buf_size as described below. In that case a lower value can be used.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer<br>
	 * @param[in] buf_size the output buffer size<br>
	 * @param[in] samples the input buffer containing the samples<br>
	 * The number of samples read from this buffer is frame_size*channels,<br>
	 * both of which are defined in avctx.<br>
	 * For codecs which have avctx->frame_size equal to 0 (e.g. PCM) the number of<br>
	 * samples read from samples is equal to:<br>
	 * buf_size * 8 / (avctx->channels * av_get_bits_per_sample(avctx->codec_id))<br>
	 * This also implies that av_get_bits_per_sample() must not return 0 for these<br>
	 * codecs.<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used to encode the data read from the input buffer.<br>
	 * Original signature : <code>int avcodec_encode_audio(AVCodecContext*, uint8_t*, int, const short*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6540</i>
	 */
	int avcodec_encode_audio(AVCodecContext avctx, ByteBuffer buf, int buf_size, short samples[]);
	/**
	 * Encode a frame of audio.<br>
	 * * Takes input samples from frame and writes the next output packet, if<br>
	 * available, to avpkt. The output packet does not necessarily contain data for<br>
	 * the most recent frame, as encoders can delay, split, and combine input frames<br>
	 * internally as needed.<br>
	 * * @param avctx     codec context<br>
	 * @param avpkt     output AVPacket.<br>
	 *                  The user can supply an output buffer by setting<br>
	 *                  avpkt->data and avpkt->size prior to calling the<br>
	 *                  function, but if the size of the user-provided data is not<br>
	 *                  large enough, encoding will fail. All other AVPacket fields<br>
	 *                  will be reset by the encoder using av_init_packet(). If<br>
	 *                  avpkt->data is NULL, the encoder will allocate it.<br>
	 *                  The encoder will set avpkt->size to the size of the<br>
	 *                  output packet.<br>
	 * @param[in] frame AVFrame containing the raw audio data to be encoded.<br>
	 *                  May be NULL when flushing an encoder that has the<br>
	 *                  CODEC_CAP_DELAY capability set.<br>
	 *                  There are 2 codec capabilities that affect the allowed<br>
	 *                  values of frame->nb_samples.<br>
	 *                  If CODEC_CAP_SMALL_LAST_FRAME is set, then only the final<br>
	 *                  frame may be smaller than avctx->frame_size, and all other<br>
	 *                  frames must be equal to avctx->frame_size.<br>
	 *                  If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
	 *                  can have any number of samples.<br>
	 *                  If neither is set, frame->nb_samples must be equal to<br>
	 *                  avctx->frame_size for all frames.<br>
	 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
	 *                            output packet is non-empty, and to 0 if it is<br>
	 *                            empty. If the function returns an error, the<br>
	 *                            packet can be assumed to be invalid, and the<br>
	 *                            value of got_packet_ptr is undefined and should<br>
	 *                            not be used.<br>
	 * @return          0 on success, negative error code on failure<br>
	 * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6578</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_audio2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVPacket, acuitus.wrapffmpeg.AVFrame, java.nio.IntBuffer)} and {@link #avcodec_encode_audio2(acuitus.wrapffmpeg.AVCodecContext, acuitus.wrapffmpeg.AVPacket, acuitus.wrapffmpeg.AVFrame, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int avcodec_encode_audio2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntByReference got_packet_ptr);
	/**
	 * Encode a frame of audio.<br>
	 * * Takes input samples from frame and writes the next output packet, if<br>
	 * available, to avpkt. The output packet does not necessarily contain data for<br>
	 * the most recent frame, as encoders can delay, split, and combine input frames<br>
	 * internally as needed.<br>
	 * * @param avctx     codec context<br>
	 * @param avpkt     output AVPacket.<br>
	 *                  The user can supply an output buffer by setting<br>
	 *                  avpkt->data and avpkt->size prior to calling the<br>
	 *                  function, but if the size of the user-provided data is not<br>
	 *                  large enough, encoding will fail. All other AVPacket fields<br>
	 *                  will be reset by the encoder using av_init_packet(). If<br>
	 *                  avpkt->data is NULL, the encoder will allocate it.<br>
	 *                  The encoder will set avpkt->size to the size of the<br>
	 *                  output packet.<br>
	 * @param[in] frame AVFrame containing the raw audio data to be encoded.<br>
	 *                  May be NULL when flushing an encoder that has the<br>
	 *                  CODEC_CAP_DELAY capability set.<br>
	 *                  There are 2 codec capabilities that affect the allowed<br>
	 *                  values of frame->nb_samples.<br>
	 *                  If CODEC_CAP_SMALL_LAST_FRAME is set, then only the final<br>
	 *                  frame may be smaller than avctx->frame_size, and all other<br>
	 *                  frames must be equal to avctx->frame_size.<br>
	 *                  If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
	 *                  can have any number of samples.<br>
	 *                  If neither is set, frame->nb_samples must be equal to<br>
	 *                  avctx->frame_size for all frames.<br>
	 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
	 *                            output packet is non-empty, and to 0 if it is<br>
	 *                            empty. If the function returns an error, the<br>
	 *                            packet can be assumed to be invalid, and the<br>
	 *                            value of got_packet_ptr is undefined and should<br>
	 *                            not be used.<br>
	 * @return          0 on success, negative error code on failure<br>
	 * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6578</i>
	 */
	int avcodec_encode_audio2(AVCodecContext avctx, AVPacket avpkt, AVFrame frame, IntBuffer got_packet_ptr);
	/**
	 * Fill audio frame data and linesize.<br>
	 * AVFrame extended_data channel pointers are allocated if necessary for<br>
	 * planar audio.<br>
	 * * @param frame       the AVFrame<br>
	 *                    frame->nb_samples must be set prior to calling the<br>
	 *                    function. This function fills in frame->data,<br>
	 *                    frame->extended_data, frame->linesize[0].<br>
	 * @param nb_channels channel count<br>
	 * @param sample_fmt  sample format<br>
	 * @param buf         buffer to use for frame data<br>
	 * @param buf_size    size of buffer<br>
	 * @param align       plane size sample alignment<br>
	 * @return            0 on success, negative error code on failure<br>
	 * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6595</i><br>
	 * @deprecated use the safer methods {@link #avcodec_fill_audio_frame(acuitus.wrapffmpeg.AVFrame, int, int, byte[], int, int)} and {@link #avcodec_fill_audio_frame(acuitus.wrapffmpeg.AVFrame, int, int, com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	int avcodec_fill_audio_frame(AVFrame frame, int nb_channels, int sample_fmt, Pointer buf, int buf_size, int align);
	/**
	 * Fill audio frame data and linesize.<br>
	 * AVFrame extended_data channel pointers are allocated if necessary for<br>
	 * planar audio.<br>
	 * * @param frame       the AVFrame<br>
	 *                    frame->nb_samples must be set prior to calling the<br>
	 *                    function. This function fills in frame->data,<br>
	 *                    frame->extended_data, frame->linesize[0].<br>
	 * @param nb_channels channel count<br>
	 * @param sample_fmt  sample format<br>
	 * @param buf         buffer to use for frame data<br>
	 * @param buf_size    size of buffer<br>
	 * @param align       plane size sample alignment<br>
	 * @return            0 on success, negative error code on failure<br>
	 * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6595</i>
	 */
	int avcodec_fill_audio_frame(AVFrame frame, int nb_channels, int sample_fmt, ByteBuffer buf, int buf_size, int align);
	/**
	 * Encode a video frame from pict into buf.<br>
	 * The input picture should be<br>
	 * stored using a specific format, namely avctx.pix_fmt.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer for the bitstream of encoded frame<br>
	 * @param[in] buf_size the size of the output buffer in bytes<br>
	 * @param[in] pict the input picture to encode<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used from the output buffer.<br>
	 * Original signature : <code>int avcodec_encode_video(AVCodecContext*, uint8_t*, int, const AVFrame*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6608</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_video(acuitus.wrapffmpeg.AVCodecContext, java.nio.ByteBuffer, int, acuitus.wrapffmpeg.AVFrame)} and {@link #avcodec_encode_video(acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.Pointer, int, acuitus.wrapffmpeg.AVFrame)} instead
	 */
	@Deprecated 
	int avcodec_encode_video(AVCodecContext avctx, Pointer buf, int buf_size, AVFrame pict);
	/**
	 * Encode a video frame from pict into buf.<br>
	 * The input picture should be<br>
	 * stored using a specific format, namely avctx.pix_fmt.<br>
	 * * @param avctx the codec context<br>
	 * @param[out] buf the output buffer for the bitstream of encoded frame<br>
	 * @param[in] buf_size the size of the output buffer in bytes<br>
	 * @param[in] pict the input picture to encode<br>
	 * @return On error a negative value is returned, on success zero or the number<br>
	 * of bytes used from the output buffer.<br>
	 * Original signature : <code>int avcodec_encode_video(AVCodecContext*, uint8_t*, int, const AVFrame*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6608</i>
	 */
	int avcodec_encode_video(AVCodecContext avctx, ByteBuffer buf, int buf_size, AVFrame pict);
	/**
	 * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6610</i><br>
	 * @deprecated use the safer methods {@link #avcodec_encode_subtitle(acuitus.wrapffmpeg.AVCodecContext, java.nio.ByteBuffer, int, acuitus.wrapffmpeg.AVSubtitle)} and {@link #avcodec_encode_subtitle(acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.Pointer, int, acuitus.wrapffmpeg.AVSubtitle)} instead
	 */
	@Deprecated 
	int avcodec_encode_subtitle(AVCodecContext avctx, Pointer buf, int buf_size, AVSubtitle sub);
	/**
	 * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6610</i>
	 */
	int avcodec_encode_subtitle(AVCodecContext avctx, ByteBuffer buf, int buf_size, AVSubtitle sub);
	/**
	 * Close a given AVCodecContext and free all the data associated with it<br>
	 * (but not the AVCodecContext itself).<br>
	 * * Calling this function on an AVCodecContext that hasn't been opened will free<br>
	 * the codec-specific data allocated in avcodec_alloc_context3() /<br>
	 * avcodec_get_context_defaults3() with a non-NULL codec. Subsequent calls will<br>
	 * do nothing.<br>
	 * Original signature : <code>int avcodec_close(AVCodecContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6620</i>
	 */
	int avcodec_close(AVCodecContext avctx);
	/**
	 * Register all the codecs, parsers and bitstream filters which were enabled at<br>
	 * configuration time. If you do not call this function you can select exactly<br>
	 * which formats you want to support, by using the individual registration<br>
	 * functions.<br>
	 * * @see avcodec_register<br>
	 * @see av_register_codec_parser<br>
	 * @see av_register_bitstream_filter<br>
	 * Original signature : <code>void avcodec_register_all()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6631</i>
	 */
	void avcodec_register_all();
	/**
	 * Flush buffers, should be called when seeking or when switching to a different stream.<br>
	 * Original signature : <code>void avcodec_flush_buffers(AVCodecContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6636</i>
	 */
	void avcodec_flush_buffers(AVCodecContext avctx);
	/**
	 * Original signature : <code>void avcodec_default_free_buffers(AVCodecContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6638</i>
	 */
	void avcodec_default_free_buffers(AVCodecContext s);
	/**
	 * Original signature : <code>char av_get_pict_type_char(int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6640</i>
	 */
	byte av_get_pict_type_char(int pict_type);
	/**
	 * Return codec bits per sample.<br>
	 * * @param[in] codec_id the codec<br>
	 * @return Number of bits per sample or zero if unknown for the given codec.<br>
	 * Original signature : <code>int av_get_bits_per_sample(CodecID)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6647</i>
	 */
	int av_get_bits_per_sample(int codec_id);
	/**
	 * Original signature : <code>int av_get_bits_per_sample_format(AVSampleFormat)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6649</i>
	 */
	int av_get_bits_per_sample_format(int sample_fmt);
	/**
	 * Original signature : <code>AVCodecParser* av_parser_next(AVCodecParser*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6759</i>
	 */
	AVCodecParser av_parser_next(AVCodecParser c);
	/**
	 * Original signature : <code>void av_register_codec_parser(AVCodecParser*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6761</i>
	 */
	void av_register_codec_parser(AVCodecParser parser);
	/**
	 * Original signature : <code>AVCodecParserContext* av_parser_init(int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6763</i>
	 */
	AVCodecParserContext av_parser_init(int codec_id);
	/**
	 * Parse a packet.<br>
	 * * @param s             parser context.<br>
	 * @param avctx         codec context.<br>
	 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
	 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
	 * @param buf           input buffer.<br>
	 * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).<br>
	 * @param pts           input presentation timestamp.<br>
	 * @param dts           input decoding timestamp.<br>
	 * @param pos           input byte position in stream.<br>
	 * @return the number of bytes of the input bitstream used.<br>
	 * * Example:<br>
	 * @code<br>
	 *   while(in_len){<br>
	 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
	 *                                        in_data, in_len,<br>
	 *                                        pts, dts, pos);<br>
	 *       in_data += len;<br>
	 *       in_len  -= len;<br>
	 * *       if(size)<br>
	 *          decode_frame(data, size);<br>
	 *   }<br>
	 * @endcode<br>
	 * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6790</i><br>
	 * @deprecated use the safer methods {@link #av_parser_parse2(acuitus.wrapffmpeg.AVCodecParserContext, acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, byte[], int, long, long, long)} and {@link #av_parser_parse2(acuitus.wrapffmpeg.AVCodecParserContext, acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, long, long, long)} instead
	 */
	@Deprecated 
	int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, long pts, long dts, long pos);
	/**
	 * Parse a packet.<br>
	 * * @param s             parser context.<br>
	 * @param avctx         codec context.<br>
	 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
	 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
	 * @param buf           input buffer.<br>
	 * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).<br>
	 * @param pts           input presentation timestamp.<br>
	 * @param dts           input decoding timestamp.<br>
	 * @param pos           input byte position in stream.<br>
	 * @return the number of bytes of the input bitstream used.<br>
	 * * Example:<br>
	 * @code<br>
	 *   while(in_len){<br>
	 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
	 *                                        in_data, in_len,<br>
	 *                                        pts, dts, pos);<br>
	 *       in_data += len;<br>
	 *       in_len  -= len;<br>
	 * *       if(size)<br>
	 *          decode_frame(data, size);<br>
	 *   }<br>
	 * @endcode<br>
	 * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6790</i>
	 */
	int av_parser_parse2(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, long pts, long dts, long pos);
	/**
	 * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6792</i><br>
	 * @deprecated use the safer methods {@link #av_parser_change(acuitus.wrapffmpeg.AVCodecParserContext, acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, byte[], int, int)} and {@link #av_parser_change(acuitus.wrapffmpeg.AVCodecParserContext, acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
	/**
	 * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6792</i>
	 */
	int av_parser_change(AVCodecParserContext s, AVCodecContext avctx, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, int keyframe);
	/**
	 * Original signature : <code>void av_parser_close(AVCodecParserContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6794</i>
	 */
	void av_parser_close(AVCodecParserContext s);
	/**
	 * Original signature : <code>void av_register_bitstream_filter(AVBitStreamFilter*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6811</i>
	 */
	void av_register_bitstream_filter(AVBitStreamFilter bsf);
	/**
	 * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6813</i><br>
	 * @deprecated use the safer methods {@link #av_bitstream_filter_init(java.lang.String)} and {@link #av_bitstream_filter_init(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	AVBitStreamFilterContext av_bitstream_filter_init(Pointer name);
	/**
	 * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6813</i>
	 */
	AVBitStreamFilterContext av_bitstream_filter_init(String name);
	/**
	 * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6815</i><br>
	 * @deprecated use the safer methods {@link #av_bitstream_filter_filter(acuitus.wrapffmpeg.AVBitStreamFilterContext, acuitus.wrapffmpeg.AVCodecContext, java.lang.String, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, byte[], int, int)} and {@link #av_bitstream_filter_filter(acuitus.wrapffmpeg.AVBitStreamFilterContext, acuitus.wrapffmpeg.AVCodecContext, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, Pointer args, PointerByReference poutbuf, IntByReference poutbuf_size, Pointer buf, int buf_size, int keyframe);
	/**
	 * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6815</i>
	 */
	int av_bitstream_filter_filter(AVBitStreamFilterContext bsfc, AVCodecContext avctx, String args, PointerByReference poutbuf, IntBuffer poutbuf_size, byte buf[], int buf_size, int keyframe);
	/**
	 * Original signature : <code>void av_bitstream_filter_close(AVBitStreamFilterContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6817</i>
	 */
	void av_bitstream_filter_close(AVBitStreamFilterContext bsf);
	/**
	 * Original signature : <code>AVBitStreamFilter* av_bitstream_filter_next(AVBitStreamFilter*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6819</i>
	 */
	AVBitStreamFilter av_bitstream_filter_next(AVBitStreamFilter f);
	/**
	 * Reallocate the given block if it is not large enough, otherwise do nothing.<br>
	 * * @see av_realloc<br>
	 * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6825</i><br>
	 * @deprecated use the safer methods {@link #av_fast_realloc(com.sun.jna.Pointer, java.nio.IntBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_fast_realloc(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Deprecated 
	Pointer av_fast_realloc(Pointer ptr, IntByReference size, NativeSize min_size);
	/**
	 * Reallocate the given block if it is not large enough, otherwise do nothing.<br>
	 * * @see av_realloc<br>
	 * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6825</i>
	 */
	Pointer av_fast_realloc(Pointer ptr, IntBuffer size, NativeSize min_size);
	/**
	 * Allocate a buffer, reusing the given one if large enough.<br>
	 * * Contrary to av_fast_realloc the current buffer contents might not be<br>
	 * preserved and on error the old buffer is freed, thus no special<br>
	 * handling to avoid memleaks is necessary.<br>
	 * * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer<br>
	 * @param size size of the buffer *ptr points to<br>
	 * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and<br>
	 *                 *size 0 if an error occurred.<br>
	 * Original signature : <code>void av_fast_malloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6837</i><br>
	 * @deprecated use the safer methods {@link #av_fast_malloc(com.sun.jna.Pointer, java.nio.IntBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_fast_malloc(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Deprecated 
	void av_fast_malloc(Pointer ptr, IntByReference size, NativeSize min_size);
	/**
	 * Allocate a buffer, reusing the given one if large enough.<br>
	 * * Contrary to av_fast_realloc the current buffer contents might not be<br>
	 * preserved and on error the old buffer is freed, thus no special<br>
	 * handling to avoid memleaks is necessary.<br>
	 * * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer<br>
	 * @param size size of the buffer *ptr points to<br>
	 * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and<br>
	 *                 *size 0 if an error occurred.<br>
	 * Original signature : <code>void av_fast_malloc(void*, unsigned int*, size_t)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6837</i>
	 */
	void av_fast_malloc(Pointer ptr, IntBuffer size, NativeSize min_size);
	/**
	 * Copy image src to dst. Wraps av_picture_data_copy() above.<br>
	 * Original signature : <code>void av_picture_copy(AVPicture*, const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6842</i>
	 */
	void av_picture_copy(AVPicture dst, AVPicture src, int pix_fmt, int width, int height);
	/**
	 * Crop image top and left side.<br>
	 * Original signature : <code>int av_picture_crop(AVPicture*, const AVPicture*, PixelFormat, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6847</i>
	 */
	int av_picture_crop(AVPicture dst, AVPicture src, int pix_fmt, int top_band, int left_band);
	/**
	 * Pad image.<br>
	 * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, PixelFormat, int, int, int, int, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6852</i><br>
	 * @deprecated use the safer methods {@link #av_picture_pad(acuitus.wrapffmpeg.AVPicture, acuitus.wrapffmpeg.AVPicture, int, int, int, int, int, int, int, java.nio.IntBuffer)} and {@link #av_picture_pad(acuitus.wrapffmpeg.AVPicture, acuitus.wrapffmpeg.AVPicture, int, int, int, int, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntByReference color);
	/**
	 * Pad image.<br>
	 * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, PixelFormat, int, int, int, int, int*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6852</i>
	 */
	int av_picture_pad(AVPicture dst, AVPicture src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, IntBuffer color);
	/**
	 * Encode extradata length to a buffer. Used by xiph codecs.<br>
	 * * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
	 * @param v size of extradata in bytes<br>
	 * @return number of bytes written to the buffer.<br>
	 * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6860</i><br>
	 * @deprecated use the safer methods {@link #av_xiphlacing(java.nio.ByteBuffer, int)} and {@link #av_xiphlacing(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_xiphlacing(Pointer s, int v);
	/**
	 * Encode extradata length to a buffer. Used by xiph codecs.<br>
	 * * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
	 * @param v size of extradata in bytes<br>
	 * @return number of bytes written to the buffer.<br>
	 * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6860</i>
	 */
	int av_xiphlacing(ByteBuffer s, int v);
	/**
	 * Log a generic warning message about a missing feature. This function is<br>
	 * intended to be used internally by Libav (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] feature string containing the name of the missing feature<br>
	 * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
	 * If want_sample is non-zero, additional verbage will be added to the log<br>
	 * message which tells the user how to report samples to the development<br>
	 * mailing list.<br>
	 * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6874</i><br>
	 * @deprecated use the safer methods {@link #av_log_missing_feature(com.sun.jna.Pointer, java.lang.String, int)} and {@link #av_log_missing_feature(com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void av_log_missing_feature(Pointer avc, Pointer feature, int want_sample);
	/**
	 * Log a generic warning message about a missing feature. This function is<br>
	 * intended to be used internally by Libav (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] feature string containing the name of the missing feature<br>
	 * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
	 * If want_sample is non-zero, additional verbage will be added to the log<br>
	 * message which tells the user how to report samples to the development<br>
	 * mailing list.<br>
	 * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6874</i>
	 */
	void av_log_missing_feature(Pointer avc, String feature, int want_sample);
	/**
	 * Log a generic warning message asking for a sample. This function is<br>
	 * intended to be used internally by Libav (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] msg string containing an optional message, or NULL if no message<br>
	 * Original signature : <code>void av_log_ask_for_sample(void*, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6884</i><br>
	 * @deprecated use the safer methods {@link #av_log_ask_for_sample(com.sun.jna.Pointer, java.lang.String, java.lang.Object)} and {@link #av_log_ask_for_sample(com.sun.jna.Pointer, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	void av_log_ask_for_sample(Pointer avc, Pointer msg, Object... varargs);
	/**
	 * Log a generic warning message asking for a sample. This function is<br>
	 * intended to be used internally by Libav (libavcodec, libavformat, etc.)<br>
	 * only, and would normally not be used by applications.<br>
	 * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
	 * a pointer to an AVClass struct<br>
	 * @param[in] msg string containing an optional message, or NULL if no message<br>
	 * Original signature : <code>void av_log_ask_for_sample(void*, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6884</i>
	 */
	void av_log_ask_for_sample(Pointer avc, String msg, Object... varargs);
	/**
	 * Register the hardware accelerator hwaccel.<br>
	 * Original signature : <code>void av_register_hwaccel(AVHWAccel*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6889</i>
	 */
	void av_register_hwaccel(AVHWAccel hwaccel);
	/**
	 * If hwaccel is NULL, returns the first registered hardware accelerator,<br>
	 * if hwaccel is non-NULL, returns the next registered hardware accelerator<br>
	 * after hwaccel, or NULL if hwaccel is the last one.<br>
	 * Original signature : <code>AVHWAccel* av_hwaccel_next(AVHWAccel*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6896</i>
	 */
	AVHWAccel av_hwaccel_next(AVHWAccel hwaccel);
	/**
	 * Register a user provided lock manager supporting the operations<br>
	 * specified by AVLockOp. mutex points to a (void *) where the<br>
	 * lockmgr should store/get a pointer to a user allocated mutex. It's<br>
	 * NULL upon AV_LOCK_CREATE and != NULL for all other ops.<br>
	 * * @param cb User defined callback. Note: Libav may invoke calls to this<br>
	 *           callback during the call to av_lockmgr_register().<br>
	 *           Thus, the application must be prepared to handle that.<br>
	 *           If cb is set to NULL the lockmgr will be unregistered.<br>
	 *           Also note that during unregistration the previously registered<br>
	 *           lockmgr callback may also be invoked.<br>
	 * Original signature : <code>int av_lockmgr_register(av_lockmgr_register_cb_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6921</i>
	 */
	int av_lockmgr_register(AvcodecLibrary.av_lockmgr_register_cb_callback cb);
	/**
	 * Get the type of the given codec.<br>
	 * Original signature : <code>AVMediaType avcodec_get_type(CodecID)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6926</i>
	 */
	int avcodec_get_type(int codec_id);
	/**
	 * Get the AVClass for AVCodecContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* avcodec_get_class()</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6933</i>
	 */
	AVClass avcodec_get_class();
	/**
	 * @return a positive value if s is open (i.e. avcodec_open2() was called on it<br>
	 * with no corresponding avcodec_close()), 0 otherwise.<br>
	 * Original signature : <code>int avcodec_is_open(AVCodecContext*)</code><br>
	 * <i>native declaration : /usr/include/libavcodec/avcodec.h:6939</i>
	 */
	int avcodec_is_open(AVCodecContext s);
	public static class AVCodecInternal extends PointerType {
		public AVCodecInternal(Pointer address) {
			super(address);
		}
		public AVCodecInternal() {
			super();
		}
	};
	public static class AVCodecDefault extends PointerType {
		public AVCodecDefault(Pointer address) {
			super(address);
		}
		public AVCodecDefault() {
			super();
		}
	};
	public static class AVResampleContext extends PointerType {
		public AVResampleContext(Pointer address) {
			super(address);
		}
		public AVResampleContext() {
			super();
		}
	};
	public static class ReSampleContext extends PointerType {
		public ReSampleContext(Pointer address) {
			super(address);
		}
		public ReSampleContext() {
			super();
		}
	};
}
