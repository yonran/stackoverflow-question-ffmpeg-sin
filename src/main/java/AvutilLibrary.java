
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

/**
 * JNA Wrapper for library <b>avutil</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AvutilLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "avutil";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(AvutilLibrary.JNA_LIBRARY_NAME);
	public static final AvutilLibrary INSTANCE = (AvutilLibrary)Native.loadLibrary(AvutilLibrary.JNA_LIBRARY_NAME, AvutilLibrary.class);
	/**
	 * <i>native declaration : /usr/include/libavutil/avutil.h:26</i><br>
	 * enum values
	 */
	public static interface AVMediaType {
		/**
		 * < Usually treated as AVMEDIA_TYPE_DATA<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:17</i>
		 */
		public static final int AVMEDIA_TYPE_UNKNOWN = -1;
		/** <i>native declaration : /usr/include/libavutil/avutil.h:18</i> */
		public static final int AVMEDIA_TYPE_VIDEO = 0;
		/** <i>native declaration : /usr/include/libavutil/avutil.h:19</i> */
		public static final int AVMEDIA_TYPE_AUDIO = 1;
		/**
		 * < Opaque data information usually continuous<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:21</i>
		 */
		public static final int AVMEDIA_TYPE_DATA = 2;
		/** <i>native declaration : /usr/include/libavutil/avutil.h:22</i> */
		public static final int AVMEDIA_TYPE_SUBTITLE = 3;
		/**
		 * < Opaque data information usually sparse<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:24</i>
		 */
		public static final int AVMEDIA_TYPE_ATTACHMENT = 4;
		/** <i>native declaration : /usr/include/libavutil/avutil.h:25</i> */
		public static final int AVMEDIA_TYPE_NB = 5;
	};
	/**
	 * <i>native declaration : /usr/include/libavutil/avutil.h:42</i><br>
	 * enum values
	 */
	public static interface AVPictureType {
		/**
		 * < Intra<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:29</i>
		 */
		public static final int AV_PICTURE_TYPE_I = 1;
		/**
		 * < Predicted<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:31</i>
		 */
		public static final int AV_PICTURE_TYPE_P = 2;
		/**
		 * < Bi-dir predicted<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:33</i>
		 */
		public static final int AV_PICTURE_TYPE_B = 3;
		/**
		 * < S(GMC)-VOP MPEG4<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:35</i>
		 */
		public static final int AV_PICTURE_TYPE_S = 4;
		/**
		 * < Switching Intra<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:37</i>
		 */
		public static final int AV_PICTURE_TYPE_SI = 5;
		/**
		 * < Switching Predicted<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:39</i>
		 */
		public static final int AV_PICTURE_TYPE_SP = 6;
		/**
		 * < BI type<br>
		 * <i>native declaration : /usr/include/libavutil/avutil.h:41</i>
		 */
		public static final int AV_PICTURE_TYPE_BI = 7;
	};
	/**
	 * <i>native declaration : /usr/include/libavutil/mathematics.h:2831</i><br>
	 * enum values
	 */
	public static interface AVRounding {
		/**
		 * < Round toward zero.<br>
		 * <i>native declaration : /usr/include/libavutil/mathematics.h:2822</i>
		 */
		public static final int AV_ROUND_ZERO = 0;
		/**
		 * < Round away from zero.<br>
		 * <i>native declaration : /usr/include/libavutil/mathematics.h:2824</i>
		 */
		public static final int AV_ROUND_INF = 1;
		/**
		 * < Round toward -infinity.<br>
		 * <i>native declaration : /usr/include/libavutil/mathematics.h:2826</i>
		 */
		public static final int AV_ROUND_DOWN = 2;
		/**
		 * < Round toward +infinity.<br>
		 * <i>native declaration : /usr/include/libavutil/mathematics.h:2828</i>
		 */
		public static final int AV_ROUND_UP = 3;
		/**
		 * < Round to nearest and halfway cases away from zero.<br>
		 * <i>native declaration : /usr/include/libavutil/mathematics.h:2830</i>
		 */
		public static final int AV_ROUND_NEAR_INF = 5;
	};
	/**
	 * all in native-endian format<br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2900</i><br>
	 * enum values
	 */
	public static interface AVSampleFormat {
		/** <i>native declaration : /usr/include/libavutil/samplefmt.h:2877</i> */
		public static final int AV_SAMPLE_FMT_NONE = -1;
		/**
		 * < unsigned 8 bits<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2879</i>
		 */
		public static final int AV_SAMPLE_FMT_U8 = 0;
		/**
		 * < signed 16 bits<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2881</i>
		 */
		public static final int AV_SAMPLE_FMT_S16 = 1;
		/**
		 * < signed 32 bits<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2883</i>
		 */
		public static final int AV_SAMPLE_FMT_S32 = 2;
		/**
		 * < float<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2885</i>
		 */
		public static final int AV_SAMPLE_FMT_FLT = 3;
		/**
		 * < double<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2887</i>
		 */
		public static final int AV_SAMPLE_FMT_DBL = 4;
		/**
		 * < unsigned 8 bits, planar<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2889</i>
		 */
		public static final int AV_SAMPLE_FMT_U8P = 5;
		/**
		 * < signed 16 bits, planar<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2891</i>
		 */
		public static final int AV_SAMPLE_FMT_S16P = 6;
		/**
		 * < signed 32 bits, planar<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2893</i>
		 */
		public static final int AV_SAMPLE_FMT_S32P = 7;
		/**
		 * < float, planar<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2895</i>
		 */
		public static final int AV_SAMPLE_FMT_FLTP = 8;
		/**
		 * < double, planar<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2897</i>
		 */
		public static final int AV_SAMPLE_FMT_DBLP = 9;
		/**
		 * < Number of sample formats. DO NOT USE if linking dynamically<br>
		 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2899</i>
		 */
		public static final int AV_SAMPLE_FMT_NB = 10;
	};
	/**
	 * Pixel format.<br>
	 * * @note<br>
	 * PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA<br>
	 * color is put together as:<br>
	 *  (A << 24) | (R << 16) | (G << 8) | B<br>
	 * This is stored as BGRA on little-endian CPU architectures and ARGB on<br>
	 * big-endian CPUs.<br>
	 * * @par<br>
	 * When the pixel format is palettized RGB (PIX_FMT_PAL8), the palettized<br>
	 * image data is stored in AVFrame.data[0]. The palette is transported in<br>
	 * AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is<br>
	 * formatted the same as in PIX_FMT_RGB32 described above (i.e., it is<br>
	 * also endian-specific). Note also that the individual RGB palette<br>
	 * components stored in AVFrame.data[1] should be in the range 0..255.<br>
	 * This is important as many custom PAL8 video codecs that were designed<br>
	 * to run on the IBM VGA graphics adapter use 6-bit palette components.<br>
	 * * @par<br>
	 * For all the 8bit per pixel formats, an RGB32 palette is in data[1] like<br>
	 * for pal8. This palette is filled in automatically by the function<br>
	 * allocating the picture.<br>
	 * * @note<br>
	 * make sure that all newly added big endian formats have pix_fmt&1==1<br>
	 * and that all newly added little endian formats have pix_fmt&1==0<br>
	 * this allows simpler detection of big vs little endian.<br>
	 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3326</i><br>
	 * enum values
	 */
	public static interface PixelFormat {
		/** <i>native declaration : /usr/include/libavutil/pixfmt.h:3146</i> */
		public static final int PIX_FMT_NONE = -1;
		/**
		 * < planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3148</i>
		 */
		public static final int PIX_FMT_YUV420P = 0;
		/**
		 * < packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3150</i>
		 */
		public static final int PIX_FMT_YUYV422 = 1;
		/**
		 * < packed RGB 8:8:8, 24bpp, RGBRGB...<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3152</i>
		 */
		public static final int PIX_FMT_RGB24 = 2;
		/**
		 * < packed RGB 8:8:8, 24bpp, BGRBGR...<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3154</i>
		 */
		public static final int PIX_FMT_BGR24 = 3;
		/**
		 * < planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3156</i>
		 */
		public static final int PIX_FMT_YUV422P = 4;
		/**
		 * < planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3158</i>
		 */
		public static final int PIX_FMT_YUV444P = 5;
		/**
		 * < planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3160</i>
		 */
		public static final int PIX_FMT_YUV410P = 6;
		/**
		 * < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3162</i>
		 */
		public static final int PIX_FMT_YUV411P = 7;
		/**
		 * <        Y        ,  8bpp<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3164</i>
		 */
		public static final int PIX_FMT_GRAY8 = 8;
		/**
		 * <        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3166</i>
		 */
		public static final int PIX_FMT_MONOWHITE = 9;
		/**
		 * <        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3168</i>
		 */
		public static final int PIX_FMT_MONOBLACK = 10;
		/**
		 * < 8 bit with PIX_FMT_RGB32 palette<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3170</i>
		 */
		public static final int PIX_FMT_PAL8 = 11;
		/**
		 * < planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV420P and setting color_range<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3172</i>
		 */
		public static final int PIX_FMT_YUVJ420P = 12;
		/**
		 * < planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV422P and setting color_range<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3174</i>
		 */
		public static final int PIX_FMT_YUVJ422P = 13;
		/**
		 * < planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV444P and setting color_range<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3176</i>
		 */
		public static final int PIX_FMT_YUVJ444P = 14;
		/**
		 * < XVideo Motion Acceleration via common packet passing<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3178</i>
		 */
		public static final int PIX_FMT_XVMC_MPEG2_MC = 15;
		/** <i>native declaration : /usr/include/libavutil/pixfmt.h:3179</i> */
		public static final int PIX_FMT_XVMC_MPEG2_IDCT = 16;
		/**
		 * < packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3181</i>
		 */
		public static final int PIX_FMT_UYVY422 = 17;
		/**
		 * < packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3183</i>
		 */
		public static final int PIX_FMT_UYYVYY411 = 18;
		/**
		 * < packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3185</i>
		 */
		public static final int PIX_FMT_BGR8 = 19;
		/**
		 * < packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3187</i>
		 */
		public static final int PIX_FMT_BGR4 = 20;
		/**
		 * < packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3189</i>
		 */
		public static final int PIX_FMT_BGR4_BYTE = 21;
		/**
		 * < packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3191</i>
		 */
		public static final int PIX_FMT_RGB8 = 22;
		/**
		 * < packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3193</i>
		 */
		public static final int PIX_FMT_RGB4 = 23;
		/**
		 * < packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3195</i>
		 */
		public static final int PIX_FMT_RGB4_BYTE = 24;
		/**
		 * < planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3197</i>
		 */
		public static final int PIX_FMT_NV12 = 25;
		/**
		 * < as above, but U and V bytes are swapped<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3199</i>
		 */
		public static final int PIX_FMT_NV21 = 26;
		/**
		 * < packed ARGB 8:8:8:8, 32bpp, ARGBARGB...<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3201</i>
		 */
		public static final int PIX_FMT_ARGB = 27;
		/**
		 * < packed RGBA 8:8:8:8, 32bpp, RGBARGBA...<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3203</i>
		 */
		public static final int PIX_FMT_RGBA = 28;
		/**
		 * < packed ABGR 8:8:8:8, 32bpp, ABGRABGR...<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3205</i>
		 */
		public static final int PIX_FMT_ABGR = 29;
		/**
		 * < packed BGRA 8:8:8:8, 32bpp, BGRABGRA...<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3207</i>
		 */
		public static final int PIX_FMT_BGRA = 30;
		/**
		 * <        Y        , 16bpp, big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3209</i>
		 */
		public static final int PIX_FMT_GRAY16BE = 31;
		/**
		 * <        Y        , 16bpp, little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3211</i>
		 */
		public static final int PIX_FMT_GRAY16LE = 32;
		/**
		 * < planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3213</i>
		 */
		public static final int PIX_FMT_YUV440P = 33;
		/**
		 * < planar YUV 4:4:0 full scale (JPEG), deprecated in favor of PIX_FMT_YUV440P and setting color_range<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3215</i>
		 */
		public static final int PIX_FMT_YUVJ440P = 34;
		/**
		 * < planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3217</i>
		 */
		public static final int PIX_FMT_YUVA420P = 35;
		/**
		 * < H.264 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3219</i>
		 */
		public static final int PIX_FMT_VDPAU_H264 = 36;
		/**
		 * < MPEG-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3221</i>
		 */
		public static final int PIX_FMT_VDPAU_MPEG1 = 37;
		/**
		 * < MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3223</i>
		 */
		public static final int PIX_FMT_VDPAU_MPEG2 = 38;
		/**
		 * < WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3225</i>
		 */
		public static final int PIX_FMT_VDPAU_WMV3 = 39;
		/**
		 * < VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3227</i>
		 */
		public static final int PIX_FMT_VDPAU_VC1 = 40;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3229</i>
		 */
		public static final int PIX_FMT_RGB48BE = 41;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3231</i>
		 */
		public static final int PIX_FMT_RGB48LE = 42;
		/**
		 * < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3233</i>
		 */
		public static final int PIX_FMT_RGB565BE = 43;
		/**
		 * < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3235</i>
		 */
		public static final int PIX_FMT_RGB565LE = 44;
		/**
		 * < packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), big-endian, most significant bit to 0<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3237</i>
		 */
		public static final int PIX_FMT_RGB555BE = 45;
		/**
		 * < packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), little-endian, most significant bit to 0<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3239</i>
		 */
		public static final int PIX_FMT_RGB555LE = 46;
		/**
		 * < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3241</i>
		 */
		public static final int PIX_FMT_BGR565BE = 47;
		/**
		 * < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3243</i>
		 */
		public static final int PIX_FMT_BGR565LE = 48;
		/**
		 * < packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), big-endian, most significant bit to 1<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3245</i>
		 */
		public static final int PIX_FMT_BGR555BE = 49;
		/**
		 * < packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), little-endian, most significant bit to 1<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3247</i>
		 */
		public static final int PIX_FMT_BGR555LE = 50;
		/**
		 * < HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3249</i>
		 */
		public static final int PIX_FMT_VAAPI_MOCO = 51;
		/**
		 * < HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3251</i>
		 */
		public static final int PIX_FMT_VAAPI_IDCT = 52;
		/**
		 * < HW decoding through VA API, Picture.data[3] contains a vaapi_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3253</i>
		 */
		public static final int PIX_FMT_VAAPI_VLD = 53;
		/**
		 * < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3255</i>
		 */
		public static final int PIX_FMT_YUV420P16LE = 54;
		/**
		 * < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3257</i>
		 */
		public static final int PIX_FMT_YUV420P16BE = 55;
		/**
		 * < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3259</i>
		 */
		public static final int PIX_FMT_YUV422P16LE = 56;
		/**
		 * < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3261</i>
		 */
		public static final int PIX_FMT_YUV422P16BE = 57;
		/**
		 * < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3263</i>
		 */
		public static final int PIX_FMT_YUV444P16LE = 58;
		/**
		 * < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3265</i>
		 */
		public static final int PIX_FMT_YUV444P16BE = 59;
		/**
		 * < MPEG4 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3267</i>
		 */
		public static final int PIX_FMT_VDPAU_MPEG4 = 60;
		/**
		 * < HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3269</i>
		 */
		public static final int PIX_FMT_DXVA2_VLD = 61;
		/**
		 * < packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), little-endian, most significant bits to 0<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3271</i>
		 */
		public static final int PIX_FMT_RGB444LE = 62;
		/**
		 * < packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), big-endian, most significant bits to 0<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3273</i>
		 */
		public static final int PIX_FMT_RGB444BE = 63;
		/**
		 * < packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), little-endian, most significant bits to 1<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3275</i>
		 */
		public static final int PIX_FMT_BGR444LE = 64;
		/**
		 * < packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), big-endian, most significant bits to 1<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3277</i>
		 */
		public static final int PIX_FMT_BGR444BE = 65;
		/**
		 * < 8bit gray, 8bit alpha<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3279</i>
		 */
		public static final int PIX_FMT_Y400A = 66;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3281</i>
		 */
		public static final int PIX_FMT_BGR48BE = 67;
		/**
		 * < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3283</i>
		 */
		public static final int PIX_FMT_BGR48LE = 68;
		/**
		 * < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3285</i>
		 */
		public static final int PIX_FMT_YUV420P9BE = 69;
		/**
		 * < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3287</i>
		 */
		public static final int PIX_FMT_YUV420P9LE = 70;
		/**
		 * < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3289</i>
		 */
		public static final int PIX_FMT_YUV420P10BE = 71;
		/**
		 * < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3291</i>
		 */
		public static final int PIX_FMT_YUV420P10LE = 72;
		/**
		 * < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3293</i>
		 */
		public static final int PIX_FMT_YUV422P10BE = 73;
		/**
		 * < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3295</i>
		 */
		public static final int PIX_FMT_YUV422P10LE = 74;
		/**
		 * < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3297</i>
		 */
		public static final int PIX_FMT_YUV444P9BE = 75;
		/**
		 * < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3299</i>
		 */
		public static final int PIX_FMT_YUV444P9LE = 76;
		/**
		 * < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3301</i>
		 */
		public static final int PIX_FMT_YUV444P10BE = 77;
		/**
		 * < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3303</i>
		 */
		public static final int PIX_FMT_YUV444P10LE = 78;
		/**
		 * < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3305</i>
		 */
		public static final int PIX_FMT_YUV422P9BE = 79;
		/**
		 * < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3307</i>
		 */
		public static final int PIX_FMT_YUV422P9LE = 80;
		/**
		 * < hardware decoding through VDA<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3309</i>
		 */
		public static final int PIX_FMT_VDA_VLD = 81;
		/**
		 * < planar GBR 4:4:4 24bpp<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3311</i>
		 */
		public static final int PIX_FMT_GBRP = 82;
		/**
		 * < planar GBR 4:4:4 27bpp, big endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3313</i>
		 */
		public static final int PIX_FMT_GBRP9BE = 83;
		/**
		 * < planar GBR 4:4:4 27bpp, little endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3315</i>
		 */
		public static final int PIX_FMT_GBRP9LE = 84;
		/**
		 * < planar GBR 4:4:4 30bpp, big endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3317</i>
		 */
		public static final int PIX_FMT_GBRP10BE = 85;
		/**
		 * < planar GBR 4:4:4 30bpp, little endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3319</i>
		 */
		public static final int PIX_FMT_GBRP10LE = 86;
		/**
		 * < planar GBR 4:4:4 48bpp, big endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3321</i>
		 */
		public static final int PIX_FMT_GBRP16BE = 87;
		/**
		 * < planar GBR 4:4:4 48bpp, little endian<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3323</i>
		 */
		public static final int PIX_FMT_GBRP16LE = 88;
		/**
		 * < number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions<br>
		 * <i>native declaration : /usr/include/libavutil/pixfmt.h:3325</i>
		 */
		public static final int PIX_FMT_NB = 89;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2733</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_FILTER_NOT_FOUND = (int)(-((0xF8) | (('F') << 8) | (('I') << 16) | (('L') << 24)));
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_IWMMXT = (int)0x0100;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final boolean FF_API_OLD_AVOPTIONS = (boolean)(51 < 52);
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_OPTION_NOT_FOUND = (int)(-((0xF8) | (('O') << 8) | (('P') << 16) | (('T') << 24)));
	/** <i>native declaration : /usr/include/libavutil/dict.h</i> */
	public static final int AV_DICT_IGNORE_SUFFIX = (int)2;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_6POINT0_FRONT = (int)(((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_STEREO = (int)(0x00000001 | 0x00000002);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final long AV_CH_SURROUND_DIRECT_RIGHT = (long)0x0000000400000000L;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_FRONT_CENTER = (int)0x00000004;
	/** <i>native declaration : /usr/include/libavutil/mathematics.h</i> */
	public static final double M_LOG2_10 = (double)3.32192809488736234787;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_SIDE_LEFT = (int)0x00000200;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_SIDE_RIGHT = (int)0x00000400;
	/** <i>native declaration : /usr/include/libavutil/dict.h</i> */
	public static final int AV_DICT_APPEND = (int)32;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_AVX = (int)0x4000;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int FF_LAMBDA_MAX = (int)(256 * 128 - 1);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final long AV_CH_WIDE_LEFT = (long)0x0000000080000000L;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_FRONT_LEFT = (int)0x00000001;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final long AV_CH_WIDE_RIGHT = (long)0x0000000100000000L;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSSE3 = (int)0x0080;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_TOP_BACK_LEFT = (int)0x00008000;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_ATOM = (int)0x10000000;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_MMX = (int)0x0001;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final long AV_CH_SURROUND_DIRECT_LEFT = (long)0x0000000200000000L;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int LIBAVUTIL_VERSION_MICRO = (int)1;
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_SKIP_REPEATED = (int)1;
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_BUG = (int)(-(('B') | (('U') << 8) | (('G') << 16) | ((' ') << 24)));
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_STEREO_LEFT = (int)0x20000000;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_FRONT_RIGHT_OF_CENTER = (int)0x00000080;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_6POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000100);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000100);
	/** <i>native declaration : /usr/include/libavutil/avconfig.h</i> */
	public static final int AV_HAVE_FAST_UNALIGNED = (int)1;
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_INVALIDDATA = (int)(-(('I') | (('N') << 8) | (('D') << 16) | (('A') << 24)));
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_EOF = (int)(-(('E') | (('O') << 8) | (('F') << 16) | ((' ') << 24)));
	/** <i>native declaration : /usr/include/libavutil/mathematics.h</i> */
	public static final double M_PHI = (double)1.61803398874989484820;
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_PANIC = (int)0;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE2 = (int)0x0010;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_QUAD = (int)((0x00000001 | 0x00000002) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_XOP = (int)0x0400;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_STEREO_DOWNMIX = (int)(0x20000000 | 0x40000000);
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE3 = (int)0x0040;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE4 = (int)0x0100;
	/** <i>native declaration : /usr/include/libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_KEY = (int)4;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_5POINT1_BACK = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008);
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_DEBUG = (int)48;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1_WIDE = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000040 | 0x00000080);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_SURROUND = (int)((0x00000001 | 0x00000002) | 0x00000004);
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_WARNING = (int)24;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE2SLOW = (int)0x40000000;
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_PROTOCOL_NOT_FOUND = (int)(-((0xF8) | (('P') << 8) | (('R') << 16) | (('O') << 24)));
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_TOP_FRONT_CENTER = (int)0x00002000;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_7POINT0_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_VERBOSE = (int)40;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_STEREO_RIGHT = (int)0x40000000;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE3SLOW = (int)0x20000000;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int FF_QUALITY_SCALE = (int)(1 << 7);
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_INFO = (int)32;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int AV_TIME_BASE = (int)1000000;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_MMX2 = (int)0x0002;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_7POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_BACK_RIGHT = (int)0x00000020;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_TOP_FRONT_RIGHT = (int)0x00004000;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_5POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_5POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008);
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final boolean FF_API_GET_BITS_PER_SAMPLE_FMT = (boolean)(51 < 52);
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_DECODER_NOT_FOUND = (int)(-((0xF8) | (('D') << 8) | (('E') << 16) | (('C') << 24)));
	/**
	 * define<br>
	 * Conversion Error : 51.22.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : /usr/include/libavutil/avutil.h:0</i><br>
	 * 51.22.
	 */
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_STREAM_NOT_FOUND = (int)(-((0xF8) | (('S') << 8) | (('T') << 16) | (('R') << 24)));
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_QUIET = (int)-8;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_OCTAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000100 | 0x00000020);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_BACK_CENTER = (int)0x00000100;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_4POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100);
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int LIBAVUTIL_VERSION_MAJOR = (int)51;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_4POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100) | 0x00000008);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_FRONT_LEFT_OF_CENTER = (int)0x00000040;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_2_1 = (int)((0x00000001 | 0x00000002) | 0x00000100);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_2_2 = (int)((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_3POINT1 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000008);
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_UNKNOWN = (int)(-(('U') | (('N') << 8) | (('K') << 16) | (('N') << 24)));
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int LIBAVUTIL_VERSION_INT = (int)(51 << 16 | 22 << 8 | 1);
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int FF_LAMBDA_SCALE = (int)(1 << 7);
	/** <i>native declaration : /usr/include/libavutil/avconfig.h</i> */
	public static final int AV_HAVE_BIGENDIAN = (int)0;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_BACK_LEFT = (int)0x00000010;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int FF_QP2LAMBDA = (int)118;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final long AV_CH_LAYOUT_NATIVE = (long)0x8000000000000000L;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LOW_FREQUENCY = (int)0x00000008;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final boolean FF_API_AV_FIFO_PEEK = (boolean)(51 < 52);
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_EXIT = (int)(-(('E') | (('X') << 8) | (('I') << 16) | (('T') << 24)));
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int LIBAVUTIL_BUILD = (int)(51 << 16 | 22 << 8 | 1);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_2POINT1 = (int)((0x00000001 | 0x00000002) | 0x00000008);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_TOP_FRONT_LEFT = (int)0x00001000;
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_PATCHWELCOME = (int)(-(('P') | (('A') << 8) | (('W') << 16) | (('E') << 24)));
	/** <i>native declaration : /usr/include/libavutil/dict.h</i> */
	public static final int AV_DICT_MATCH_CASE = (int)1;
	/** <i>native declaration : /usr/include/libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_OVERWRITE = (int)16;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE42 = (int)0x0200;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1_BACK = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008) | 0x00000100);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_TOP_BACK_RIGHT = (int)0x00020000;
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_MUXER_NOT_FOUND = (int)(-((0xF8) | (('M') << 8) | (('U') << 16) | (('X') << 24)));
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_HEXAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000100);
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_DEMUXER_NOT_FOUND = (int)(-((0xF8) | (('D') << 8) | (('E') << 16) | (('M') << 24)));
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_FMA4 = (int)0x0800;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_3DNOW = (int)0x0004;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_MONO = (int)(0x00000004);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_TOP_BACK_CENTER = (int)0x00010000;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080) | 0x00000008);
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_FRONT_RIGHT = (int)0x00000002;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_TOP_CENTER = (int)0x00000800;
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_ERROR = (int)16;
	/** <i>native declaration : /usr/include/libavutil/audioconvert.h</i> */
	public static final int AV_CH_LAYOUT_5POINT0_BACK = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020);
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_FORCE = (int)0x80000000;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE = (int)0x0008;
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_BSF_NOT_FOUND = (int)(-((0xF8) | (('B') << 8) | (('S') << 16) | (('F') << 24)));
	/** <i>native declaration : /usr/include/libavutil/log.h</i> */
	public static final int AV_LOG_FATAL = (int)8;
	/** <i>native declaration : /usr/include/libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_VAL = (int)8;
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_3DNOWEXT = (int)0x0020;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int LIBAVUTIL_VERSION_MINOR = (int)22;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final String LIBAVUTIL_IDENT = (String)"Lavu";
	/** <i>native declaration : /usr/include/libavutil/error.h</i> */
	public static final int AVERROR_ENCODER_NOT_FOUND = (int)(-((0xF8) | (('E') << 8) | (('N') << 16) | (('C') << 24)));
	/** <i>native declaration : /usr/include/libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_ALTIVEC = (int)0x0001;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final int FF_LAMBDA_SHIFT = (int)7;
	/** <i>native declaration : /usr/include/libavutil/avutil.h</i> */
	public static final boolean FF_API_FIND_OPT = (boolean)(51 < 52);
	/** <i>native declaration : /usr/include/libavutil/log.h:8768</i> */
	public interface av_log_set_callback_arg1_callback extends Callback {
		void apply(Pointer voidPtr1, int int1, Pointer charPtr1, Pointer va_list1);
	};
	/**
	 * Return the LIBAVUTIL_VERSION_INT constant.<br>
	 * Original signature : <code>int avutil_version()</code><br>
	 * <i>native declaration : /usr/include/libavutil/avutil.h:4</i>
	 */
	int avutil_version();
	/**
	 * Return the libavutil build-time configuration.<br>
	 * Original signature : <code>char* avutil_configuration()</code><br>
	 * <i>native declaration : /usr/include/libavutil/avutil.h:9</i>
	 */
	String avutil_configuration();
	/**
	 * Return the libavutil license.<br>
	 * Original signature : <code>char* avutil_license()</code><br>
	 * <i>native declaration : /usr/include/libavutil/avutil.h:14</i>
	 */
	String avutil_license();
	/**
	 * Return a single letter to describe the given picture type<br>
	 * pict_type.<br>
	 * * @param[in] pict_type the picture type @return a single character<br>
	 * representing the picture type, '?' if pict_type is unknown<br>
	 * Original signature : <code>char av_get_picture_type_char(AVPictureType)</code><br>
	 * <i>native declaration : /usr/include/libavutil/avutil.h:50</i>
	 */
	byte av_get_picture_type_char(int pict_type);
	/**
	 * Allocate a block of size bytes with alignment suitable for all<br>
	 * memory accesses (including vectors if available on the CPU).<br>
	 * @param size Size in bytes for the memory block to be allocated.<br>
	 * @return Pointer to the allocated block, NULL if the block cannot<br>
	 * be allocated.<br>
	 * @see av_mallocz()<br>
	 * Original signature : <code>void* av_malloc(size_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mem.h:2652</i>
	 */
	Pointer av_malloc(NativeSize size);
	/**
	 * Allocate or reallocate a block of memory.<br>
	 * If ptr is NULL and size > 0, allocate a new block. If<br>
	 * size is zero, free the memory block pointed to by ptr.<br>
	 * @param ptr Pointer to a memory block already allocated with<br>
	 * av_malloc(z)() or av_realloc() or NULL.<br>
	 * @param size Size in bytes for the memory block to be allocated or<br>
	 * reallocated.<br>
	 * @return Pointer to a newly reallocated block or NULL if the block<br>
	 * cannot be reallocated or the function is used to free the memory block.<br>
	 * @see av_fast_realloc()<br>
	 * Original signature : <code>void* av_realloc(void*, size_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mem.h:2666</i>
	 */
	Pointer av_realloc(Pointer ptr, NativeSize size);
	/**
	 * Free a memory block which has been allocated with av_malloc(z)() or<br>
	 * av_realloc().<br>
	 * @param ptr Pointer to the memory block which should be freed.<br>
	 * @note ptr = NULL is explicitly allowed.<br>
	 * @note It is recommended that you use av_freep() instead.<br>
	 * @see av_freep()<br>
	 * Original signature : <code>void av_free(void*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mem.h:2676</i>
	 */
	void av_free(Pointer ptr);
	/**
	 * Allocate a block of size bytes with alignment suitable for all<br>
	 * memory accesses (including vectors if available on the CPU) and<br>
	 * zero all the bytes of the block.<br>
	 * @param size Size in bytes for the memory block to be allocated.<br>
	 * @return Pointer to the allocated block, NULL if it cannot be allocated.<br>
	 * @see av_malloc()<br>
	 * Original signature : <code>void* av_mallocz(size_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mem.h:2686</i>
	 */
	Pointer av_mallocz(NativeSize size);
	/**
	 * Duplicate the string s.<br>
	 * @param s string to be duplicated<br>
	 * @return Pointer to a newly allocated string containing a<br>
	 * copy of s or NULL if the string cannot be allocated.<br>
	 * Original signature : <code>char* av_strdup(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mem.h:2694</i><br>
	 * @deprecated use the safer methods {@link #av_strdup(java.lang.String)} and {@link #av_strdup(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer av_strdup(Pointer s);
	/**
	 * Duplicate the string s.<br>
	 * @param s string to be duplicated<br>
	 * @return Pointer to a newly allocated string containing a<br>
	 * copy of s or NULL if the string cannot be allocated.<br>
	 * Original signature : <code>char* av_strdup(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mem.h:2694</i>
	 */
	Pointer av_strdup(String s);
	/**
	 * Free a memory block which has been allocated with av_malloc(z)() or<br>
	 * av_realloc() and set the pointer pointing to it to NULL.<br>
	 * @param ptr Pointer to the pointer to the memory block which should<br>
	 * be freed.<br>
	 * @see av_free()<br>
	 * Original signature : <code>void av_freep(void*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mem.h:2703</i>
	 */
	void av_freep(Pointer ptr);
	/**
	 * Put a description of the AVERROR code errnum in errbuf.<br>
	 * In case of failure the global variable errno is set to indicate the<br>
	 * error. Even in case of failure av_strerror() will print a generic<br>
	 * error message indicating the errnum provided to errbuf.<br>
	 * * @param errnum      error code to describe<br>
	 * @param errbuf      buffer to which description is written<br>
	 * @param errbuf_size the size in bytes of errbuf<br>
	 * @return 0 on success, a negative value if a description for errnum<br>
	 * cannot be found<br>
	 * Original signature : <code>int av_strerror(int, char*, size_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/error.h:2716</i><br>
	 * @deprecated use the safer methods {@link #av_strerror(int, java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_strerror(int, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Deprecated 
	int av_strerror(int errnum, Pointer errbuf, NativeSize errbuf_size);
	/**
	 * Put a description of the AVERROR code errnum in errbuf.<br>
	 * In case of failure the global variable errno is set to indicate the<br>
	 * error. Even in case of failure av_strerror() will print a generic<br>
	 * error message indicating the errnum provided to errbuf.<br>
	 * * @param errnum      error code to describe<br>
	 * @param errbuf      buffer to which description is written<br>
	 * @param errbuf_size the size in bytes of errbuf<br>
	 * @return 0 on success, a negative value if a description for errnum<br>
	 * cannot be found<br>
	 * Original signature : <code>int av_strerror(int, char*, size_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/error.h:2716</i>
	 */
	int av_strerror(int errnum, ByteBuffer errbuf, NativeSize errbuf_size);
	/**
	 * Reduce a fraction.<br>
	 * This is useful for framerate calculations.<br>
	 * @param dst_num destination numerator<br>
	 * @param dst_den destination denominator<br>
	 * @param num source numerator<br>
	 * @param den source denominator<br>
	 * @param max the maximum allowed for dst_num & dst_den<br>
	 * @return 1 if exact, 0 otherwise<br>
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2765</i><br>
	 * @deprecated use the safer methods {@link #av_reduce(java.nio.IntBuffer, java.nio.IntBuffer, long, long, long)} and {@link #av_reduce(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, long, long, long)} instead
	 */
	@Deprecated 
	int av_reduce(IntByReference dst_num, IntByReference dst_den, long num, long den, long max);
	/**
	 * Reduce a fraction.<br>
	 * This is useful for framerate calculations.<br>
	 * @param dst_num destination numerator<br>
	 * @param dst_den destination denominator<br>
	 * @param num source numerator<br>
	 * @param den source denominator<br>
	 * @param max the maximum allowed for dst_num & dst_den<br>
	 * @return 1 if exact, 0 otherwise<br>
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2765</i>
	 */
	int av_reduce(IntBuffer dst_num, IntBuffer dst_den, long num, long den, long max);
	/**
	 * Multiply two rationals.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b*c<br>
	 * Original signature : <code>AVRational av_mul_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2773</i>
	 */
	AVRational.ByValue av_mul_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Divide one rational by another.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b/c<br>
	 * Original signature : <code>AVRational av_div_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2781</i>
	 */
	AVRational.ByValue av_div_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Add two rationals.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b+c<br>
	 * Original signature : <code>AVRational av_add_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2789</i>
	 */
	AVRational.ByValue av_add_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Subtract one rational from another.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b-c<br>
	 * Original signature : <code>AVRational av_sub_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2797</i>
	 */
	AVRational.ByValue av_sub_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Convert a double precision floating point number to a rational.<br>
	 * inf is expressed as {1,0} or {-1,0} depending on the sign.<br>
	 * * @param d double to convert<br>
	 * @param max the maximum allowed numerator and denominator<br>
	 * @return (AVRational) d<br>
	 * Original signature : <code>AVRational av_d2q(double, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2806</i>
	 */
	AVRational.ByValue av_d2q(double d, int max);
	/**
	 * @return 1 if q1 is nearer to q than q2, -1 if q2 is nearer<br>
	 * than q1, 0 if they have the same distance.<br>
	 * Original signature : <code>int av_nearer_q(AVRational, AVRational, AVRational)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2812</i>
	 */
	int av_nearer_q(AVRational.ByValue q, AVRational.ByValue q1, AVRational.ByValue q2);
	/**
	 * Find the nearest value in q_list to q.<br>
	 * @param q_list an array of rationals terminated by {0, 0}<br>
	 * @return the index of the nearest value found in the array<br>
	 * Original signature : <code>int av_find_nearest_q_idx(AVRational, const AVRational*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:2819</i>
	 */
	int av_find_nearest_q_idx(AVRational.ByValue q, AVRational q_list);
	/**
	 * Return the greatest common divisor of a and b.<br>
	 * If both a and b are 0 or either or both are <0 then behavior is<br>
	 * undefined.<br>
	 * Original signature : <code>int64_t av_gcd(int64_t, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mathematics.h:2838</i>
	 */
	long av_gcd(long a, long b);
	/**
	 * Rescale a 64-bit integer with rounding to nearest.<br>
	 * A simple a*b/c isn't possible as it can overflow.<br>
	 * Original signature : <code>int64_t av_rescale(int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mathematics.h:2844</i>
	 */
	long av_rescale(long a, long b, long c);
	/**
	 * Rescale a 64-bit integer with specified rounding.<br>
	 * A simple a*b/c isn't possible as it can overflow.<br>
	 * Original signature : <code>int64_t av_rescale_rnd(int64_t, int64_t, int64_t, AVRounding)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mathematics.h:2850</i>
	 */
	long av_rescale_rnd(long a, long b, long c, int arg1);
	/**
	 * Rescale a 64-bit integer by 2 rational numbers.<br>
	 * Original signature : <code>int64_t av_rescale_q(int64_t, AVRational, AVRational)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mathematics.h:2855</i>
	 */
	long av_rescale_q(long a, AVRational.ByValue bq, AVRational.ByValue cq);
	/**
	 * Compare 2 timestamps each in its own timebases.<br>
	 * The result of the function is undefined if one of the timestamps<br>
	 * is outside the int64_t range when represented in the others timebase.<br>
	 * @return -1 if ts_a is before ts_b, 1 if ts_a is after ts_b or 0 if they represent the same position<br>
	 * Original signature : <code>int av_compare_ts(int64_t, AVRational, int64_t, AVRational)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mathematics.h:2863</i>
	 */
	int av_compare_ts(long ts_a, AVRational.ByValue tb_a, long ts_b, AVRational.ByValue tb_b);
	/**
	 * Compare 2 integers modulo mod.<br>
	 * That is we compare integers a and b for which only the least<br>
	 * significant log2(mod) bits are known.<br>
	 * * @param mod must be a power of 2<br>
	 * @return a negative value if a is smaller than b<br>
	 *         a positive value if a is greater than b<br>
	 *         0                if a equals          b<br>
	 * Original signature : <code>int64_t av_compare_mod(uint64_t, uint64_t, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/mathematics.h:2874</i>
	 */
	long av_compare_mod(long a, long b, long mod);
	/**
	 * Return the name of sample_fmt, or NULL if sample_fmt is not<br>
	 * recognized.<br>
	 * Original signature : <code>char* av_get_sample_fmt_name(AVSampleFormat)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2906</i>
	 */
	String av_get_sample_fmt_name(int sample_fmt);
	/**
	 * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE<br>
	 * on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2912</i><br>
	 * @deprecated use the safer methods {@link #av_get_sample_fmt(java.lang.String)} and {@link #av_get_sample_fmt(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_get_sample_fmt(Pointer name);
	/**
	 * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE<br>
	 * on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2912</i>
	 */
	int av_get_sample_fmt(String name);
	/**
	 * Generate a string corresponding to the sample format with<br>
	 * sample_fmt, or a header if sample_fmt is negative.<br>
	 * * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param sample_fmt the number of the sample format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * @return the pointer to the filled buffer or NULL if sample_fmt is<br>
	 * unknown or in case of other errors<br>
	 * Original signature : <code>char* av_get_sample_fmt_string(char*, int, AVSampleFormat)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2925</i><br>
	 * @deprecated use the safer methods {@link #av_get_sample_fmt_string(java.nio.ByteBuffer, int, int)} and {@link #av_get_sample_fmt_string(com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	Pointer av_get_sample_fmt_string(Pointer buf, int buf_size, int sample_fmt);
	/**
	 * Generate a string corresponding to the sample format with<br>
	 * sample_fmt, or a header if sample_fmt is negative.<br>
	 * * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param sample_fmt the number of the sample format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * @return the pointer to the filled buffer or NULL if sample_fmt is<br>
	 * unknown or in case of other errors<br>
	 * Original signature : <code>char* av_get_sample_fmt_string(char*, int, AVSampleFormat)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2925</i>
	 */
	Pointer av_get_sample_fmt_string(ByteBuffer buf, int buf_size, int sample_fmt);
	/**
	 * Original signature : <code>int av_get_bits_per_sample_fmt(AVSampleFormat)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2927</i>
	 */
	int av_get_bits_per_sample_fmt(int sample_fmt);
	/**
	 * Return number of bytes per sample.<br>
	 * * @param sample_fmt the sample format<br>
	 * @return number of bytes per sample or zero if unknown for the given<br>
	 * sample format<br>
	 * Original signature : <code>int av_get_bytes_per_sample(AVSampleFormat)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2935</i>
	 */
	int av_get_bytes_per_sample(int sample_fmt);
	/**
	 * Check if the sample format is planar.<br>
	 * * @param sample_fmt the sample format to inspect<br>
	 * @return 1 if the sample format is planar, 0 if it is interleaved<br>
	 * Original signature : <code>int av_sample_fmt_is_planar(AVSampleFormat)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2942</i>
	 */
	int av_sample_fmt_is_planar(int sample_fmt);
	/**
	 * Get the required buffer size for the given audio parameters.<br>
	 * * @param[out] linesize calculated linesize, may be NULL<br>
	 * @param nb_channels   the number of channels<br>
	 * @param nb_samples    the number of samples in a single channel<br>
	 * @param sample_fmt    the sample format<br>
	 * @return              required buffer size, or negative error code on failure<br>
	 * Original signature : <code>int av_samples_get_buffer_size(int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2952</i><br>
	 * @deprecated use the safer methods {@link #av_samples_get_buffer_size(java.nio.IntBuffer, int, int, int, int)} and {@link #av_samples_get_buffer_size(com.sun.jna.ptr.IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_get_buffer_size(IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Get the required buffer size for the given audio parameters.<br>
	 * * @param[out] linesize calculated linesize, may be NULL<br>
	 * @param nb_channels   the number of channels<br>
	 * @param nb_samples    the number of samples in a single channel<br>
	 * @param sample_fmt    the sample format<br>
	 * @return              required buffer size, or negative error code on failure<br>
	 * Original signature : <code>int av_samples_get_buffer_size(int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2952</i>
	 */
	int av_samples_get_buffer_size(IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Fill channel data pointers and linesize for samples with sample<br>
	 * format sample_fmt.<br>
	 * * The pointers array is filled with the pointers to the samples data:<br>
	 * for planar, set the start point of each channel's data within the buffer,<br>
	 * for packed, set the start point of the entire buffer only.<br>
	 * * The linesize array is filled with the aligned size of each channel's data<br>
	 * buffer for planar layout, or the aligned size of the buffer for all channels<br>
	 * for packed layout.<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    calculated linesize<br>
	 * @param buf              the pointer to a buffer containing the samples<br>
	 * @param nb_channels      the number of channels<br>
	 * @param nb_samples       the number of samples in a single channel<br>
	 * @param sample_fmt       the sample format<br>
	 * @param align            buffer size alignment (1 = no alignment required)<br>
	 * @return                 0 on success or a negative error code on failure<br>
	 * Original signature : <code>int av_samples_fill_arrays(uint8_t**, int*, uint8_t*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2972</i><br>
	 * @deprecated use the safer methods {@link #av_samples_fill_arrays(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.ByteBuffer, int, int, int, int)} and {@link #av_samples_fill_arrays(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_fill_arrays(PointerByReference audio_data, IntByReference linesize, Pointer buf, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Fill channel data pointers and linesize for samples with sample<br>
	 * format sample_fmt.<br>
	 * * The pointers array is filled with the pointers to the samples data:<br>
	 * for planar, set the start point of each channel's data within the buffer,<br>
	 * for packed, set the start point of the entire buffer only.<br>
	 * * The linesize array is filled with the aligned size of each channel's data<br>
	 * buffer for planar layout, or the aligned size of the buffer for all channels<br>
	 * for packed layout.<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    calculated linesize<br>
	 * @param buf              the pointer to a buffer containing the samples<br>
	 * @param nb_channels      the number of channels<br>
	 * @param nb_samples       the number of samples in a single channel<br>
	 * @param sample_fmt       the sample format<br>
	 * @param align            buffer size alignment (1 = no alignment required)<br>
	 * @return                 0 on success or a negative error code on failure<br>
	 * Original signature : <code>int av_samples_fill_arrays(uint8_t**, int*, uint8_t*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2972</i>
	 */
	int av_samples_fill_arrays(PointerByReference audio_data, IntBuffer linesize, ByteBuffer buf, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a samples buffer for nb_samples samples, and fill data pointers and<br>
	 * linesize accordingly.<br>
	 * The allocated samples buffer can be freed by using av_freep(&audio_data[0])<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    aligned size for audio buffer(s)<br>
	 * @param nb_channels      number of audio channels<br>
	 * @param nb_samples       number of samples per channel<br>
	 * @param align            buffer size alignment (1 = no alignment required)<br>
	 * @return                 0 on success or a negative error code on failure<br>
	 * @see av_samples_fill_arrays()<br>
	 * Original signature : <code>int av_samples_alloc(uint8_t**, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2986</i><br>
	 * @deprecated use the safer methods {@link #av_samples_alloc(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, int, int, int, int)} and {@link #av_samples_alloc(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_alloc(PointerByReference audio_data, IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a samples buffer for nb_samples samples, and fill data pointers and<br>
	 * linesize accordingly.<br>
	 * The allocated samples buffer can be freed by using av_freep(&audio_data[0])<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    aligned size for audio buffer(s)<br>
	 * @param nb_channels      number of audio channels<br>
	 * @param nb_samples       number of samples per channel<br>
	 * @param align            buffer size alignment (1 = no alignment required)<br>
	 * @return                 0 on success or a negative error code on failure<br>
	 * @see av_samples_fill_arrays()<br>
	 * Original signature : <code>int av_samples_alloc(uint8_t**, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/samplefmt.h:2986</i>
	 */
	int av_samples_alloc(PointerByReference audio_data, IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Return the flags which specify extensions supported by the CPU.<br>
	 * Original signature : <code>int av_get_cpu_flags()</code><br>
	 * <i>native declaration : /usr/include/libavutil/cpu.h:2991</i>
	 */
	int av_get_cpu_flags();
	/**
	 * The following CPU-specific functions shall not be called directly.<br>
	 * Original signature : <code>int ff_get_cpu_flags_arm()</code><br>
	 * <i>native declaration : /usr/include/libavutil/cpu.h:2996</i>
	 */
	int ff_get_cpu_flags_arm();
	/**
	 * Original signature : <code>int ff_get_cpu_flags_ppc()</code><br>
	 * <i>native declaration : /usr/include/libavutil/cpu.h:2998</i>
	 */
	int ff_get_cpu_flags_ppc();
	/**
	 * Original signature : <code>int ff_get_cpu_flags_x86()</code><br>
	 * <i>native declaration : /usr/include/libavutil/cpu.h:3000</i>
	 */
	int ff_get_cpu_flags_x86();
	/**
	 * Get a dictionary entry with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found entry or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3014</i><br>
	 * @deprecated use the safer methods {@link #av_dict_get(com.sun.jna.ptr.PointerByReference, java.lang.String, AVDictionaryEntry, int)} and {@link #av_dict_get(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, AVDictionaryEntry, int)} instead
	 */
	@Deprecated 
	AVDictionaryEntry av_dict_get(Pointer m, Pointer key, AVDictionaryEntry prev, int flags);
	/**
	 * Get a dictionary entry with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found entry or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3014</i>
	 */
	AVDictionaryEntry av_dict_get(PointerByReference m, String key, AVDictionaryEntry prev, int flags);
	/**
	 * Get a dictionary entry with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found entry or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3014</i>
	 */
	AVDictionaryEntry av_dict_get(PointerByReference m, Pointer key, AVDictionaryEntry prev, int flags);
	/**
	 * Set the given entry in *pm, overwriting an existing entry.<br>
	 * * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
	 * a dictionary struct is allocated and put in *pm.<br>
	 * @param key entry key to add to *pm (will be av_strduped depending on flags)<br>
	 * @param value entry value to add to *pm (will be av_strduped depending on flags).<br>
	 *        Passing a NULL value will cause an existing tag to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3025</i><br>
	 * @deprecated use the safer methods {@link #av_dict_set(com.sun.jna.ptr.PointerByReference, java.lang.String, java.lang.String, int)} and {@link #av_dict_set(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_dict_set(PointerByReference pm, Pointer key, Pointer value, int flags);
	/**
	 * Set the given entry in *pm, overwriting an existing entry.<br>
	 * * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
	 * a dictionary struct is allocated and put in *pm.<br>
	 * @param key entry key to add to *pm (will be av_strduped depending on flags)<br>
	 * @param value entry value to add to *pm (will be av_strduped depending on flags).<br>
	 *        Passing a NULL value will cause an existing tag to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3025</i>
	 */
	int av_dict_set(PointerByReference pm, String key, String value, int flags);
	/**
	 * Copy entries from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting entries in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * Original signature : <code>void av_dict_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3035</i><br>
	 * @deprecated use the safer method {@link #av_dict_copy(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	void av_dict_copy(PointerByReference dst, Pointer src, int flags);
	/**
	 * Copy entries from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting entries in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * Original signature : <code>void av_dict_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3035</i>
	 */
	void av_dict_copy(PointerByReference dst, PointerByReference src, int flags);
	/**
	 * Free all the memory allocated for an AVDictionary struct<br>
	 * and all keys and values.<br>
	 * Original signature : <code>void av_dict_free(AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavutil/dict.h:3041</i>
	 */
	void av_dict_free(PointerByReference m);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different av_vlog callback<br>
	 * function.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 * subsequent arguments are converted to output.<br>
	 * @see av_vlog<br>
	 * Original signature : <code>void av_log(void*, int, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3104</i><br>
	 * @deprecated use the safer methods {@link #av_log(com.sun.jna.Pointer, int, java.lang.String, java.lang.Object)} and {@link #av_log(com.sun.jna.Pointer, int, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	void av_log(Pointer avcl, int level, Pointer fmt, Object... varargs);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different av_vlog callback<br>
	 * function.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 * subsequent arguments are converted to output.<br>
	 * @see av_vlog<br>
	 * Original signature : <code>void av_log(void*, int, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3104</i>
	 */
	void av_log(Pointer avcl, int level, String fmt, Object... varargs);
	/**
	 * Original signature : <code>void av_vlog(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3106</i><br>
	 * @deprecated use the safer methods {@link #av_vlog(com.sun.jna.Pointer, int, java.lang.String, AvutilLibrary.va_list)} and {@link #av_vlog(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void av_vlog(Pointer avcl, int level, Pointer fmt, Pointer va_list1);
	/**
	 * Original signature : <code>void av_vlog(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3106</i>
	 */
	void av_vlog(Pointer avcl, int level, String fmt, AvutilLibrary.va_list va_list1);
	/**
	 * Original signature : <code>int av_log_get_level()</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3108</i>
	 */
	int av_log_get_level();
	/**
	 * Original signature : <code>void av_log_set_level(int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3110</i>
	 */
	void av_log_set_level(int int1);
	/**
	 * Original signature : <code>void av_log_set_callback(av_log_set_callback_arg1_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3112</i>
	 */
	void av_log_set_callback(AvutilLibrary.av_log_set_callback_arg1_callback arg1);
	/**
	 * Original signature : <code>void av_log_default_callback(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3114</i><br>
	 * @deprecated use the safer methods {@link #av_log_default_callback(com.sun.jna.Pointer, int, java.lang.String, AvutilLibrary.va_list)} and {@link #av_log_default_callback(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void av_log_default_callback(Pointer ptr, int level, Pointer fmt, Pointer vl);
	/**
	 * Original signature : <code>void av_log_default_callback(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3114</i>
	 */
	void av_log_default_callback(Pointer ptr, int level, String fmt, AvutilLibrary.va_list vl);
	/**
	 * Original signature : <code>char* av_default_item_name(void*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3116</i>
	 */
	String av_default_item_name(Pointer ctx);
	/**
	 * Original signature : <code>void av_log_set_flags(int)</code><br>
	 * <i>native declaration : /usr/include/libavutil/log.h:3118</i>
	 */
	void av_log_set_flags(int arg);
	/**
	 * Return a channel layout id that matches name, 0 if no match.<br>
	 * Original signature : <code>uint64_t av_get_channel_layout(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/audioconvert.h:3667</i><br>
	 * @deprecated use the safer methods {@link #av_get_channel_layout(java.lang.String)} and {@link #av_get_channel_layout(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	long av_get_channel_layout(Pointer name);
	/**
	 * Return a channel layout id that matches name, 0 if no match.<br>
	 * Original signature : <code>uint64_t av_get_channel_layout(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavutil/audioconvert.h:3667</i>
	 */
	long av_get_channel_layout(String name);
	/**
	 * Return a description of a channel layout.<br>
	 * If nb_channels is <= 0, it is guessed from the channel_layout.<br>
	 * * @param buf put here the string containing the channel layout<br>
	 * @param buf_size size in bytes of the buffer<br>
	 * Original signature : <code>void av_get_channel_layout_string(char*, int, int, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/audioconvert.h:3675</i><br>
	 * @deprecated use the safer methods {@link #av_get_channel_layout_string(java.nio.ByteBuffer, int, int, long)} and {@link #av_get_channel_layout_string(com.sun.jna.Pointer, int, int, long)} instead
	 */
	@Deprecated 
	void av_get_channel_layout_string(Pointer buf, int buf_size, int nb_channels, long channel_layout);
	/**
	 * Return a description of a channel layout.<br>
	 * If nb_channels is <= 0, it is guessed from the channel_layout.<br>
	 * * @param buf put here the string containing the channel layout<br>
	 * @param buf_size size in bytes of the buffer<br>
	 * Original signature : <code>void av_get_channel_layout_string(char*, int, int, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/audioconvert.h:3675</i>
	 */
	void av_get_channel_layout_string(ByteBuffer buf, int buf_size, int nb_channels, long channel_layout);
	/**
	 * Return the number of channels in the channel layout.<br>
	 * Original signature : <code>int av_get_channel_layout_nb_channels(uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavutil/audioconvert.h:3680</i>
	 */
	int av_get_channel_layout_nb_channels(long channel_layout);
	/** misc math functions */
	public static final class ff_log2_tab {
		private static Pointer ff_log2_tab;
		public static synchronized Pointer get() {
			if ((ff_log2_tab == null)) 
				ff_log2_tab = AvutilLibrary.JNA_NATIVE_LIB.getGlobalVariableAddress("ff_log2_tab");
			return ff_log2_tab;
		}
	};
	public static final class av_reverse {
		private static Pointer av_reverse;
		public static synchronized Pointer get() {
			if ((av_reverse == null)) 
				av_reverse = AvutilLibrary.JNA_NATIVE_LIB.getGlobalVariableAddress("av_reverse");
			return av_reverse;
		}
	};
	public static class va_list extends PointerType {
		public va_list(Pointer address) {
			super(address);
		}
		public va_list() {
			super();
		}
	};
	public static class AVDictionary extends PointerType {
		public AVDictionary(Pointer address) {
			super(address);
		}
		public AVDictionary() {
			super();
		}
	};
	public static class AVOption extends PointerType {
		public AVOption(Pointer address) {
			super(address);
		}
		public AVOption() {
			super();
		}
	};
}
