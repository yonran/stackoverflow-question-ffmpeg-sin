
import com.ochafik.lang.jnaerator.runtime.globals.GlobalCallback;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
/**
 * JNA Wrapper for library <b>avformat</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AvformatLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "avformat";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(AvformatLibrary.JNA_LIBRARY_NAME);
	public static final AvformatLibrary INSTANCE = (AvformatLibrary)Native.loadLibrary(AvformatLibrary.JNA_LIBRARY_NAME, AvformatLibrary.class);
	/**
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7799</i><br>
	 * enum values
	 */
	public static interface AVStreamParseType {
		/** <i>native declaration : /usr/include/libavformat/avformat.h:7794</i> */
		public static final int AVSTREAM_PARSE_NONE = 0;
		/**
		 * < full parsing and repack<br>
		 * <i>native declaration : /usr/include/libavformat/avformat.h:7795</i>
		 */
		public static final int AVSTREAM_PARSE_FULL = 1;
		/**
		 * < Only parse headers, do not repack.<br>
		 * <i>native declaration : /usr/include/libavformat/avformat.h:7796</i>
		 */
		public static final int AVSTREAM_PARSE_HEADERS = 2;
		/**
		 * < full parsing and interpolation of timestamps for frames not starting on a packet boundary<br>
		 * <i>native declaration : /usr/include/libavformat/avformat.h:7797</i>
		 */
		public static final int AVSTREAM_PARSE_TIMESTAMPS = 3;
		/**
		 * < full parsing and repack of the first frame only, only implemented for H.264 currently<br>
		 * <i>native declaration : /usr/include/libavformat/avformat.h:7798</i>
		 */
		public static final int AVSTREAM_PARSE_FULL_ONCE = 4;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : /usr/include/libavutil/rational.h:0</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_AVSTREAM_QUALITY = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int URL_EOF = (int)(-1);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_SET_PTS_INFO = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVSEEK_FLAG_FRAME = (int)8;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int AVIO_FLAG_WRITE = (int)2;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NOFILE = (int)0x0001;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int RAW_PACKET_BUFFER_SIZE = (int)2500000;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_DUB = (int)0x0002;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_GENERIC_INDEX = (int)0x0100;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVSEEK_FLAG_BACKWARD = (int)1;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_NONBLOCK = (int)0x0004;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int AVSEEK_SIZE = (int)0x10000;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_DISCARD_CORRUPT = (int)0x0100;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final int LIBAVFORMAT_VERSION_MICRO = (int)1;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_SEEK_PUBLIC = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_FORMAT_PARAMETERS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NOSTREAMS = (int)0x1000;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_METADATA_DONT_OVERWRITE = (int)16;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVSEEK_FLAG_ANY = (int)4;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_LYRICS = (int)0x0010;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int MAX_STD_TIMEBASES = (int)(60 * 12 + 5);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_FLAG_RTP_HINT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_PROGRAM_RUNNING = (int)1;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_GUESS_IMG2_CODEC = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVSEEK_FLAG_BYTE = (int)2;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_CUSTOM_IO = (int)0x0080;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NOGENSEARCH = (int)0x4000;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_OLD_METADATA2 = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_VARIABLE_FPS = (int)0x0400;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_LOOP_OUTPUT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final int LIBAVFORMAT_VERSION_INT = (int)(53 << 16 | 21 << 8 | 1);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_FIND_INFO_TAG = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_NOFILLIN = (int)0x0010;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final String LIBAVFORMAT_IDENT = (String)"Lavf";
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_IGNIDX = (int)0x0002;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_STREAM_COPY = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final int LIBAVFORMAT_VERSION_MAJOR = (int)53;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_RTP_HINT = (int)0x0040;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_INFINITEOUTPUTLOOP = (int)0;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int MAX_PROBE_PACKETS = (int)2500;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_FILESIZE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NOOUTPUTLOOP = (int)-1;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_RTSP_URL_OPTIONS = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NO_BYTE_SEEK = (int)0x8000;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NEEDNUMBER = (int)0x0002;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int AVIO_FLAG_READ = (int)1;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_GENPTS = (int)0x0001;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_PKT_DUMP = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVINDEX_KEYFRAME = (int)0x0001;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMTCTX_NOHEADER = (int)0x0001;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_METADATA_IGNORE_SUFFIX = (int)2;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int URL_RDWR = (int)(1 | 2);
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int AVSEEK_FORCE = (int)0x20000;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_VISUAL_IMPAIRED = (int)0x0100;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_TIMESTAMP = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_METADATA_DONT_STRDUP_VAL = (int)8;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_SHOW_IDS = (int)0x0008;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_TS_DISCONT = (int)0x0200;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_COMMENT = (int)0x0008;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_NOPARSE = (int)0x0020;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_METADATA_DONT_STRDUP_KEY = (int)4;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVPROBE_SCORE_MAX = (int)100;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_PRELOAD = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int FF_FDEBUG_TS = (int)0x0001;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int AVIO_FLAG_READ_WRITE = (int)(1 | 2);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_KARAOKE = (int)0x0020;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final int LIBAVFORMAT_VERSION_MINOR = (int)21;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_OLD_AVIO = (boolean)(53 < 54);
	/**
	 * define<br>
	 * Conversion Error : 53.21.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : /usr/include/libavformat/version.h:0</i><br>
	 * 53.21.
	 */
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_ORIGINAL = (int)0x0004;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_FLAG_IGNDTS = (int)0x0008;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int URL_PROTOCOL_FLAG_NESTED_SCHEME = (int)1;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int URL_RDONLY = (int)1;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVPROBE_PADDING_SIZE = (int)32;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NOTIMESTAMPS = (int)0x0080;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_NEW_STREAM = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_DEFAULT = (int)0x0001;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NOBINSEARCH = (int)0x2000;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_SDP_CREATE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_LOOP_INPUT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final int LIBAVFORMAT_BUILD = (int)(53 << 16 | 21 << 8 | 1);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_HEARING_IMPAIRED = (int)0x0080;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_NODIMENSIONS = (int)0x0800;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_OLD_INTERRUPT_CB = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_MUXRATE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_PARSE_DATE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int MAX_REORDER_DELAY = (int)16;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int URL_FLAG_NONBLOCK = (int)8;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_FORCED = (int)0x0040;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int URL_PROTOCOL_FLAG_NETWORK = (int)2;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_RAWPICTURE = (int)0x0020;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_CLOSE_INPUT_FILE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int AVIO_FLAG_NONBLOCK = (int)8;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_DUMP_FORMAT = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int URL_WRONLY = (int)2;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_METADATA_MATCH_CASE = (int)1;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AV_DISPOSITION_CLEAN_EFFECTS = (int)0x0200;
	/** <i>native declaration : /usr/include/libavformat/avformat.h</i> */
	public static final int AVFMT_GLOBALHEADER = (int)0x0040;
	/** <i>native declaration : /usr/include/libavformat/avio.h</i> */
	public static final int AVIO_SEEKABLE_NORMAL = (int)0x0001;
	/** <i>native declaration : /usr/include/libavformat/version.h</i> */
	public static final boolean FF_API_REORDER_PRIVATE = (boolean)(53 < 54);
	/** <i>native declaration : /usr/include/libavformat/avio.h:7065</i> */
	public interface URLInterruptCB extends Callback {
		int apply();
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8836</i> */
	public interface url_set_interrupt_cb_interrupt_cb_callback extends Callback {
		int apply();
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8837</i> */
	public interface init_put_byte_read_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8838</i> */
	public interface init_put_byte_write_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8839</i> */
	public interface init_put_byte_seek_callback extends Callback {
		long apply(Pointer opaque, long offset, int whence);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8840</i> */
	public interface av_alloc_put_byte_read_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8841</i> */
	public interface av_alloc_put_byte_write_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8842</i> */
	public interface av_alloc_put_byte_seek_callback extends Callback {
		long apply(Pointer opaque, long offset, int whence);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8843</i> */
	public interface init_checksum_update_checksum_callback extends Callback {
		NativeLong apply(NativeLong c, Pointer p, int len);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8844</i> */
	public interface avio_set_interrupt_cb_interrupt_cb_callback extends Callback {
		int apply();
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8845</i> */
	public interface avio_alloc_context_read_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8846</i> */
	public interface avio_alloc_context_write_packet_callback extends Callback {
		int apply(Pointer opaque, Pointer buf, int buf_size);
	};
	/** <i>native declaration : /usr/include/libavformat/avio.h:8847</i> */
	public interface avio_alloc_context_seek_callback extends Callback {
		long apply(Pointer opaque, long offset, int whence);
	};
	/** <i>native declaration : /usr/include/libavformat/avformat.h:8852</i> */
	public interface av_gen_search_read_timestamp_callback extends Callback {
		long apply(AVFormatContext AVFormatContextPtr1, int int1, LongByReference int64_tPtr1, long int64_t1);
	};
	/**
	 * not implemented<br>
	 * Original signature : <code>int url_poll(URLPollEntry*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7064</i>
	 */
	int url_poll(URLPollEntry poll_table, int n, int timeout);
	/**
	 * @defgroup old_url_funcs Old url_* functions<br>
	 * The following functions are deprecated. Use the buffered API based on #AVIOContext instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int url_open_protocol(URLContext**, URLProtocol*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7074</i><br>
	 * @deprecated use the safer methods {@link #url_open_protocol(acuitus.wrapffmpeg.URLContext.ByReference[], acuitus.wrapffmpeg.URLProtocol, java.lang.String, int)} and {@link #url_open_protocol(acuitus.wrapffmpeg.URLContext.ByReference[], acuitus.wrapffmpeg.URLProtocol, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int url_open_protocol(PointerByReference puc, URLProtocol up, Pointer url, int flags);
	/**
	 * @defgroup old_url_funcs Old url_* functions<br>
	 * The following functions are deprecated. Use the buffered API based on #AVIOContext instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int url_open_protocol(URLContext**, URLProtocol*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7074</i>
	 */
	int url_open_protocol(URLContext.ByReference puc[], URLProtocol up, String url, int flags);
	/**
	 * @defgroup old_url_funcs Old url_* functions<br>
	 * The following functions are deprecated. Use the buffered API based on #AVIOContext instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int url_open_protocol(URLContext**, URLProtocol*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7074</i>
	 */
	int url_open_protocol(URLContext.ByReference puc[], URLProtocol up, Pointer url, int flags);
	/**
	 * Original signature : <code>int url_alloc(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7076</i><br>
	 * @deprecated use the safer methods {@link #url_alloc(acuitus.wrapffmpeg.URLContext.ByReference[], java.lang.String, int)} and {@link #url_alloc(acuitus.wrapffmpeg.URLContext.ByReference[], com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int url_alloc(PointerByReference h, Pointer url, int flags);
	/**
	 * Original signature : <code>int url_alloc(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7076</i>
	 */
	int url_alloc(URLContext.ByReference h[], String url, int flags);
	/**
	 * Original signature : <code>int url_alloc(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7076</i>
	 */
	int url_alloc(URLContext.ByReference h[], Pointer url, int flags);
	/**
	 * Original signature : <code>int url_connect(URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7078</i>
	 */
	int url_connect(URLContext h);
	/**
	 * Original signature : <code>int url_open(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7080</i><br>
	 * @deprecated use the safer methods {@link #url_open(acuitus.wrapffmpeg.URLContext.ByReference[], java.lang.String, int)} and {@link #url_open(acuitus.wrapffmpeg.URLContext.ByReference[], com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int url_open(PointerByReference h, Pointer url, int flags);
	/**
	 * Original signature : <code>int url_open(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7080</i>
	 */
	int url_open(URLContext.ByReference h[], String url, int flags);
	/**
	 * Original signature : <code>int url_open(URLContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7080</i>
	 */
	int url_open(URLContext.ByReference h[], Pointer url, int flags);
	/**
	 * Original signature : <code>int url_read(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7082</i><br>
	 * @deprecated use the safer methods {@link #url_read(acuitus.wrapffmpeg.URLContext, java.nio.ByteBuffer, int)} and {@link #url_read(acuitus.wrapffmpeg.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int url_read(URLContext h, Pointer buf, int size);
	/**
	 * Original signature : <code>int url_read(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7082</i>
	 */
	int url_read(URLContext h, ByteBuffer buf, int size);
	/**
	 * Original signature : <code>int url_read_complete(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7084</i><br>
	 * @deprecated use the safer methods {@link #url_read_complete(acuitus.wrapffmpeg.URLContext, java.nio.ByteBuffer, int)} and {@link #url_read_complete(acuitus.wrapffmpeg.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int url_read_complete(URLContext h, Pointer buf, int size);
	/**
	 * Original signature : <code>int url_read_complete(URLContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7084</i>
	 */
	int url_read_complete(URLContext h, ByteBuffer buf, int size);
	/**
	 * Original signature : <code>int url_write(URLContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7086</i><br>
	 * @deprecated use the safer methods {@link #url_write(acuitus.wrapffmpeg.URLContext, byte[], int)} and {@link #url_write(acuitus.wrapffmpeg.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int url_write(URLContext h, Pointer buf, int size);
	/**
	 * Original signature : <code>int url_write(URLContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7086</i>
	 */
	int url_write(URLContext h, byte buf[], int size);
	/**
	 * Original signature : <code>int64_t url_seek(URLContext*, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7088</i>
	 */
	long url_seek(URLContext h, long pos, int whence);
	/**
	 * Original signature : <code>int url_close(URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7090</i>
	 */
	int url_close(URLContext h);
	/**
	 * Original signature : <code>int64_t url_filesize(URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7092</i>
	 */
	long url_filesize(URLContext h);
	/**
	 * Original signature : <code>int url_get_file_handle(URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7094</i>
	 */
	int url_get_file_handle(URLContext h);
	/**
	 * Original signature : <code>int url_get_max_packet_size(URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7096</i>
	 */
	int url_get_max_packet_size(URLContext h);
	/**
	 * Original signature : <code>void url_get_filename(URLContext*, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7098</i><br>
	 * @deprecated use the safer methods {@link #url_get_filename(acuitus.wrapffmpeg.URLContext, java.nio.ByteBuffer, int)} and {@link #url_get_filename(acuitus.wrapffmpeg.URLContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void url_get_filename(URLContext h, Pointer buf, int buf_size);
	/**
	 * Original signature : <code>void url_get_filename(URLContext*, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7098</i>
	 */
	void url_get_filename(URLContext h, ByteBuffer buf, int buf_size);
	/**
	 * Original signature : <code>int av_url_read_pause(URLContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7100</i>
	 */
	int av_url_read_pause(URLContext h, int pause);
	/**
	 * Original signature : <code>int64_t av_url_read_seek(URLContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7102</i>
	 */
	long av_url_read_seek(URLContext h, int stream_index, long timestamp, int flags);
	/**
	 * Original signature : <code>void url_set_interrupt_cb(url_set_interrupt_cb_interrupt_cb_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7104</i>
	 */
	void url_set_interrupt_cb(AvformatLibrary.url_set_interrupt_cb_interrupt_cb_callback interrupt_cb);
	/**
	 * If protocol is NULL, returns the first registered protocol,<br>
	 * if protocol is non-NULL, returns the next registered protocol after protocol,<br>
	 * or NULL if protocol is the last one.<br>
	 * Original signature : <code>URLProtocol* av_protocol_next(URLProtocol*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7111</i>
	 */
	URLProtocol av_protocol_next(URLProtocol p);
	/**
	 * Register the URLProtocol protocol.<br>
	 * * @param size the size of the URLProtocol struct referenced<br>
	 * Original signature : <code>int av_register_protocol2(URLProtocol*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7117</i>
	 */
	int av_register_protocol2(URLProtocol protocol, int size);
	/**
	 * Original signature : <code>int init_put_byte(AVIOContext*, unsigned char*, int, int, void*, init_put_byte_read_packet_callback*, init_put_byte_write_packet_callback*, init_put_byte_seek_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7120</i><br>
	 * @deprecated use the safer methods {@link #init_put_byte(acuitus.wrapffmpeg.AVIOContext, java.nio.ByteBuffer, int, int, com.sun.jna.Pointer, acuitus.wrapffmpeg.AvformatLibrary.init_put_byte_read_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.init_put_byte_write_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.init_put_byte_seek_callback)} and {@link #init_put_byte(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int, int, com.sun.jna.Pointer, acuitus.wrapffmpeg.AvformatLibrary.init_put_byte_read_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.init_put_byte_write_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.init_put_byte_seek_callback)} instead
	 */
	@Deprecated 
	int init_put_byte(AVIOContext s, Pointer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.init_put_byte_read_packet_callback read_packet, AvformatLibrary.init_put_byte_write_packet_callback write_packet, AvformatLibrary.init_put_byte_seek_callback seek);
	/**
	 * Original signature : <code>int init_put_byte(AVIOContext*, unsigned char*, int, int, void*, init_put_byte_read_packet_callback*, init_put_byte_write_packet_callback*, init_put_byte_seek_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7120</i>
	 */
	int init_put_byte(AVIOContext s, ByteBuffer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.init_put_byte_read_packet_callback read_packet, AvformatLibrary.init_put_byte_write_packet_callback write_packet, AvformatLibrary.init_put_byte_seek_callback seek);
	/**
	 * Original signature : <code>AVIOContext* av_alloc_put_byte(unsigned char*, int, int, void*, av_alloc_put_byte_read_packet_callback*, av_alloc_put_byte_write_packet_callback*, av_alloc_put_byte_seek_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7122</i><br>
	 * @deprecated use the safer methods {@link #av_alloc_put_byte(java.nio.ByteBuffer, int, int, com.sun.jna.Pointer, acuitus.wrapffmpeg.AvformatLibrary.av_alloc_put_byte_read_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.av_alloc_put_byte_write_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.av_alloc_put_byte_seek_callback)} and {@link #av_alloc_put_byte(com.sun.jna.Pointer, int, int, com.sun.jna.Pointer, acuitus.wrapffmpeg.AvformatLibrary.av_alloc_put_byte_read_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.av_alloc_put_byte_write_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.av_alloc_put_byte_seek_callback)} instead
	 */
	@Deprecated 
	AVIOContext av_alloc_put_byte(Pointer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.av_alloc_put_byte_read_packet_callback read_packet, AvformatLibrary.av_alloc_put_byte_write_packet_callback write_packet, AvformatLibrary.av_alloc_put_byte_seek_callback seek);
	/**
	 * Original signature : <code>AVIOContext* av_alloc_put_byte(unsigned char*, int, int, void*, av_alloc_put_byte_read_packet_callback*, av_alloc_put_byte_write_packet_callback*, av_alloc_put_byte_seek_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7122</i>
	 */
	AVIOContext av_alloc_put_byte(ByteBuffer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.av_alloc_put_byte_read_packet_callback read_packet, AvformatLibrary.av_alloc_put_byte_write_packet_callback write_packet, AvformatLibrary.av_alloc_put_byte_seek_callback seek);
	/**
	 * @defgroup old_avio_funcs Old put_/get_*() functions<br>
	 * The following functions are deprecated. Use the "avio_"-prefixed functions instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int get_buffer(AVIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7130</i><br>
	 * @deprecated use the safer methods {@link #get_buffer(acuitus.wrapffmpeg.AVIOContext, java.nio.ByteBuffer, int)} and {@link #get_buffer(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int get_buffer(AVIOContext s, Pointer buf, int size);
	/**
	 * @defgroup old_avio_funcs Old put_/get_*() functions<br>
	 * The following functions are deprecated. Use the "avio_"-prefixed functions instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int get_buffer(AVIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7130</i>
	 */
	int get_buffer(AVIOContext s, ByteBuffer buf, int size);
	/**
	 * Original signature : <code>int get_partial_buffer(AVIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7132</i><br>
	 * @deprecated use the safer methods {@link #get_partial_buffer(acuitus.wrapffmpeg.AVIOContext, java.nio.ByteBuffer, int)} and {@link #get_partial_buffer(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int get_partial_buffer(AVIOContext s, Pointer buf, int size);
	/**
	 * Original signature : <code>int get_partial_buffer(AVIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7132</i>
	 */
	int get_partial_buffer(AVIOContext s, ByteBuffer buf, int size);
	/**
	 * Original signature : <code>int get_byte(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7134</i>
	 */
	int get_byte(AVIOContext s);
	/**
	 * Original signature : <code>int get_le16(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7136</i>
	 */
	int get_le16(AVIOContext s);
	/**
	 * Original signature : <code>int get_le24(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7138</i>
	 */
	int get_le24(AVIOContext s);
	/**
	 * Original signature : <code>int get_le32(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7140</i>
	 */
	int get_le32(AVIOContext s);
	/**
	 * Original signature : <code>uint64_t get_le64(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7142</i>
	 */
	long get_le64(AVIOContext s);
	/**
	 * Original signature : <code>int get_be16(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7144</i>
	 */
	int get_be16(AVIOContext s);
	/**
	 * Original signature : <code>int get_be24(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7146</i>
	 */
	int get_be24(AVIOContext s);
	/**
	 * Original signature : <code>int get_be32(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7148</i>
	 */
	int get_be32(AVIOContext s);
	/**
	 * Original signature : <code>uint64_t get_be64(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7150</i>
	 */
	long get_be64(AVIOContext s);
	/**
	 * Original signature : <code>void put_byte(AVIOContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7152</i>
	 */
	void put_byte(AVIOContext s, int b);
	/**
	 * Original signature : <code>void put_nbyte(AVIOContext*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7154</i>
	 */
	void put_nbyte(AVIOContext s, int b, int count);
	/**
	 * Original signature : <code>void put_buffer(AVIOContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7156</i><br>
	 * @deprecated use the safer methods {@link #put_buffer(acuitus.wrapffmpeg.AVIOContext, byte[], int)} and {@link #put_buffer(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void put_buffer(AVIOContext s, Pointer buf, int size);
	/**
	 * Original signature : <code>void put_buffer(AVIOContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7156</i>
	 */
	void put_buffer(AVIOContext s, byte buf[], int size);
	/**
	 * Original signature : <code>void put_le64(AVIOContext*, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7158</i>
	 */
	void put_le64(AVIOContext s, long val);
	/**
	 * Original signature : <code>void put_be64(AVIOContext*, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7160</i>
	 */
	void put_be64(AVIOContext s, long val);
	/**
	 * Original signature : <code>void put_le32(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7162</i>
	 */
	void put_le32(AVIOContext s, int val);
	/**
	 * Original signature : <code>void put_be32(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7164</i>
	 */
	void put_be32(AVIOContext s, int val);
	/**
	 * Original signature : <code>void put_le24(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7166</i>
	 */
	void put_le24(AVIOContext s, int val);
	/**
	 * Original signature : <code>void put_be24(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7168</i>
	 */
	void put_be24(AVIOContext s, int val);
	/**
	 * Original signature : <code>void put_le16(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7170</i>
	 */
	void put_le16(AVIOContext s, int val);
	/**
	 * Original signature : <code>void put_be16(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7172</i>
	 */
	void put_be16(AVIOContext s, int val);
	/**
	 * Original signature : <code>void put_tag(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7174</i><br>
	 * @deprecated use the safer methods {@link #put_tag(acuitus.wrapffmpeg.AVIOContext, java.lang.String)} and {@link #put_tag(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void put_tag(AVIOContext s, Pointer tag);
	/**
	 * Original signature : <code>void put_tag(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7174</i>
	 */
	void put_tag(AVIOContext s, String tag);
	/**
	 * Original signature : <code>int av_url_read_fpause(AVIOContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7176</i>
	 */
	int av_url_read_fpause(AVIOContext h, int pause);
	/**
	 * Original signature : <code>int64_t av_url_read_fseek(AVIOContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7178</i>
	 */
	long av_url_read_fseek(AVIOContext h, int stream_index, long timestamp, int flags);
	/**
	 * @defgroup old_url_f_funcs Old url_f* functions<br>
	 * The following functions are deprecated, use the "avio_"-prefixed functions instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int url_fopen(AVIOContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7186</i><br>
	 * @deprecated use the safer methods {@link #url_fopen(acuitus.wrapffmpeg.AVIOContext.ByReference[], java.lang.String, int)} and {@link #url_fopen(acuitus.wrapffmpeg.AVIOContext.ByReference[], com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int url_fopen(PointerByReference s, Pointer url, int flags);
	/**
	 * @defgroup old_url_f_funcs Old url_f* functions<br>
	 * The following functions are deprecated, use the "avio_"-prefixed functions instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int url_fopen(AVIOContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7186</i>
	 */
	int url_fopen(AVIOContext.ByReference s[], String url, int flags);
	/**
	 * @defgroup old_url_f_funcs Old url_f* functions<br>
	 * The following functions are deprecated, use the "avio_"-prefixed functions instead.<br>
	 * @{<br>
	 * @ingroup lavf_io<br>
	 * Original signature : <code>int url_fopen(AVIOContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7186</i>
	 */
	int url_fopen(AVIOContext.ByReference s[], Pointer url, int flags);
	/**
	 * Original signature : <code>int url_fclose(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7188</i>
	 */
	int url_fclose(AVIOContext s);
	/**
	 * Original signature : <code>int64_t url_fseek(AVIOContext*, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7190</i>
	 */
	long url_fseek(AVIOContext s, long offset, int whence);
	/**
	 * Original signature : <code>int url_fskip(AVIOContext*, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7192</i>
	 */
	int url_fskip(AVIOContext s, long offset);
	/**
	 * Original signature : <code>int64_t url_ftell(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7194</i>
	 */
	long url_ftell(AVIOContext s);
	/**
	 * Original signature : <code>int64_t url_fsize(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7196</i>
	 */
	long url_fsize(AVIOContext s);
	/**
	 * Original signature : <code>int url_fgetc(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7198</i>
	 */
	int url_fgetc(AVIOContext s);
	/**
	 * Original signature : <code>int url_setbufsize(AVIOContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7200</i>
	 */
	int url_setbufsize(AVIOContext s, int buf_size);
	/**
	 * Original signature : <code>int url_fprintf(AVIOContext*, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7202</i><br>
	 * @deprecated use the safer methods {@link #url_fprintf(acuitus.wrapffmpeg.AVIOContext, java.lang.String, java.lang.Object)} and {@link #url_fprintf(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	int url_fprintf(AVIOContext s, Pointer fmt, Object... varargs);
	/**
	 * Original signature : <code>int url_fprintf(AVIOContext*, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7202</i>
	 */
	int url_fprintf(AVIOContext s, String fmt, Object... varargs);
	/**
	 * Original signature : <code>void put_flush_packet(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7204</i>
	 */
	void put_flush_packet(AVIOContext s);
	/**
	 * Original signature : <code>int url_open_dyn_buf(AVIOContext**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7206</i><br>
	 * @deprecated use the safer method {@link #url_open_dyn_buf(acuitus.wrapffmpeg.AVIOContext.ByReference[])} instead
	 */
	@Deprecated 
	int url_open_dyn_buf(PointerByReference s);
	/**
	 * Original signature : <code>int url_open_dyn_buf(AVIOContext**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7206</i>
	 */
	int url_open_dyn_buf(AVIOContext.ByReference s[]);
	/**
	 * Original signature : <code>int url_open_dyn_packet_buf(AVIOContext**, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7208</i><br>
	 * @deprecated use the safer method {@link #url_open_dyn_packet_buf(acuitus.wrapffmpeg.AVIOContext.ByReference[], int)} instead
	 */
	@Deprecated 
	int url_open_dyn_packet_buf(PointerByReference s, int max_packet_size);
	/**
	 * Original signature : <code>int url_open_dyn_packet_buf(AVIOContext**, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7208</i>
	 */
	int url_open_dyn_packet_buf(AVIOContext.ByReference s[], int max_packet_size);
	/**
	 * Original signature : <code>int url_close_dyn_buf(AVIOContext*, uint8_t**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7210</i>
	 */
	int url_close_dyn_buf(AVIOContext s, PointerByReference pbuffer);
	/**
	 * Original signature : <code>int url_fdopen(AVIOContext**, URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7212</i><br>
	 * @deprecated use the safer method {@link #url_fdopen(acuitus.wrapffmpeg.AVIOContext.ByReference[], acuitus.wrapffmpeg.URLContext)} instead
	 */
	@Deprecated 
	int url_fdopen(PointerByReference s, URLContext h);
	/**
	 * Original signature : <code>int url_fdopen(AVIOContext**, URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7212</i>
	 */
	int url_fdopen(AVIOContext.ByReference s[], URLContext h);
	/**
	 * @deprecated use AVIOContext.eof_reached<br>
	 * Original signature : <code>int url_feof(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7217</i>
	 */
	int url_feof(AVIOContext s);
	/**
	 * Original signature : <code>int url_ferror(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7219</i>
	 */
	int url_ferror(AVIOContext s);
	/**
	 * Original signature : <code>int udp_set_remote_url(URLContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7221</i><br>
	 * @deprecated use the safer methods {@link #udp_set_remote_url(acuitus.wrapffmpeg.URLContext, java.lang.String)} and {@link #udp_set_remote_url(acuitus.wrapffmpeg.URLContext, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int udp_set_remote_url(URLContext h, Pointer uri);
	/**
	 * Original signature : <code>int udp_set_remote_url(URLContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7221</i>
	 */
	int udp_set_remote_url(URLContext h, String uri);
	/**
	 * Original signature : <code>int udp_get_local_port(URLContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7223</i>
	 */
	int udp_get_local_port(URLContext h);
	/**
	 * Original signature : <code>void init_checksum(AVIOContext*, init_checksum_update_checksum_callback*, unsigned long)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7225</i>
	 */
	void init_checksum(AVIOContext s, AvformatLibrary.init_checksum_update_checksum_callback update_checksum, NativeLong checksum);
	/**
	 * Original signature : <code>long get_checksum(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7227</i>
	 */
	NativeLong get_checksum(AVIOContext s);
	/**
	 * Original signature : <code>void put_strz(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7229</i><br>
	 * @deprecated use the safer methods {@link #put_strz(acuitus.wrapffmpeg.AVIOContext, java.lang.String)} and {@link #put_strz(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void put_strz(AVIOContext s, Pointer buf);
	/**
	 * Original signature : <code>void put_strz(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7229</i>
	 */
	void put_strz(AVIOContext s, String buf);
	/**
	 * @note unlike fgets, the EOL character is not returned and a whole<br>
	 * line is parsed. return NULL if first char read was EOF<br>
	 * Original signature : <code>char* url_fgets(AVIOContext*, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7235</i><br>
	 * @deprecated use the safer methods {@link #url_fgets(acuitus.wrapffmpeg.AVIOContext, java.nio.ByteBuffer, int)} and {@link #url_fgets(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	Pointer url_fgets(AVIOContext s, Pointer buf, int buf_size);
	/**
	 * @note unlike fgets, the EOL character is not returned and a whole<br>
	 * line is parsed. return NULL if first char read was EOF<br>
	 * Original signature : <code>char* url_fgets(AVIOContext*, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7235</i>
	 */
	Pointer url_fgets(AVIOContext s, ByteBuffer buf, int buf_size);
	/**
	 * @deprecated use avio_get_str instead<br>
	 * Original signature : <code>char* get_strz(AVIOContext*, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7240</i><br>
	 * @deprecated use the safer methods {@link #get_strz(acuitus.wrapffmpeg.AVIOContext, java.nio.ByteBuffer, int)} and {@link #get_strz(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	Pointer get_strz(AVIOContext s, Pointer buf, int maxlen);
	/**
	 * @deprecated use avio_get_str instead<br>
	 * Original signature : <code>char* get_strz(AVIOContext*, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7240</i>
	 */
	Pointer get_strz(AVIOContext s, ByteBuffer buf, int maxlen);
	/**
	 * Original signature : <code>URLContext* url_fileno(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7249</i>
	 */
	URLContext url_fileno(AVIOContext s);
	/**
	 * @deprecated use AVIOContext.max_packet_size directly.<br>
	 * Original signature : <code>int url_fget_max_packet_size(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7254</i>
	 */
	int url_fget_max_packet_size(AVIOContext s);
	/**
	 * Original signature : <code>int url_open_buf(AVIOContext**, uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7256</i><br>
	 * @deprecated use the safer methods {@link #url_open_buf(acuitus.wrapffmpeg.AVIOContext.ByReference[], java.nio.ByteBuffer, int, int)} and {@link #url_open_buf(acuitus.wrapffmpeg.AVIOContext.ByReference[], com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	int url_open_buf(PointerByReference s, Pointer buf, int buf_size, int flags);
	/**
	 * Original signature : <code>int url_open_buf(AVIOContext**, uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7256</i>
	 */
	int url_open_buf(AVIOContext.ByReference s[], ByteBuffer buf, int buf_size, int flags);
	/**
	 * Original signature : <code>int url_open_buf(AVIOContext**, uint8_t*, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7256</i>
	 */
	int url_open_buf(AVIOContext.ByReference s[], Pointer buf, int buf_size, int flags);
	/**
	 * return the written or read size<br>
	 * Original signature : <code>int url_close_buf(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7261</i>
	 */
	int url_close_buf(AVIOContext s);
	/**
	 * Return a non-zero value if the resource indicated by url<br>
	 * exists, 0 otherwise.<br>
	 * @deprecated Use avio_check instead.<br>
	 * Original signature : <code>int url_exist(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7268</i><br>
	 * @deprecated use the safer methods {@link #url_exist(java.lang.String)} and {@link #url_exist(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int url_exist(Pointer url);
	/**
	 * Return a non-zero value if the resource indicated by url<br>
	 * exists, 0 otherwise.<br>
	 * @deprecated Use avio_check instead.<br>
	 * Original signature : <code>int url_exist(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7268</i>
	 */
	int url_exist(String url);
	/**
	 * Return AVIO_FLAG_* access flags corresponding to the access permissions<br>
	 * of the resource in url, or a negative value corresponding to an<br>
	 * AVERROR code in case of failure. The returned access flags are<br>
	 * masked by the value in flags.<br>
	 * * @note This function is intrinsically unsafe, in the sense that the<br>
	 * checked resource may change its existence or permission status from<br>
	 * one call to another. Thus you should not trust the returned value,<br>
	 * unless you are sure that no other processes are accessing the<br>
	 * checked resource.<br>
	 * Original signature : <code>int avio_check(const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7281</i><br>
	 * @deprecated use the safer methods {@link #avio_check(java.lang.String, int)} and {@link #avio_check(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avio_check(Pointer url, int flags);
	/**
	 * Return AVIO_FLAG_* access flags corresponding to the access permissions<br>
	 * of the resource in url, or a negative value corresponding to an<br>
	 * AVERROR code in case of failure. The returned access flags are<br>
	 * masked by the value in flags.<br>
	 * * @note This function is intrinsically unsafe, in the sense that the<br>
	 * checked resource may change its existence or permission status from<br>
	 * one call to another. Thus you should not trust the returned value,<br>
	 * unless you are sure that no other processes are accessing the<br>
	 * checked resource.<br>
	 * Original signature : <code>int avio_check(const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7281</i>
	 */
	int avio_check(String url, int flags);
	/**
	 * The callback is called in blocking functions to test regulary if<br>
	 * asynchronous interruption is needed. AVERROR_EXIT is returned<br>
	 * in this case by the interrupted function. 'NULL' means no interrupt<br>
	 * callback is given.<br>
	 * @deprecated Use interrupt_callback in AVFormatContext/avio_open2<br>
	 *             instead.<br>
	 * Original signature : <code>void avio_set_interrupt_cb(avio_set_interrupt_cb_interrupt_cb_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7291</i>
	 */
	void avio_set_interrupt_cb(AvformatLibrary.avio_set_interrupt_cb_interrupt_cb_callback interrupt_cb);
	/**
	 * Allocate and initialize an AVIOContext for buffered I/O. It must be later<br>
	 * freed with av_free().<br>
	 * * @param buffer Memory block for input/output operations via AVIOContext.<br>
	 *        The buffer must be allocated with av_malloc() and friends.<br>
	 * @param buffer_size The buffer size is very important for performance.<br>
	 *        For protocols with fixed blocksize it should be set to this blocksize.<br>
	 *        For others a typical size is a cache page, e.g. 4kb.<br>
	 * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.<br>
	 * @param opaque An opaque pointer to user-specific data.<br>
	 * @param read_packet  A function for refilling the buffer, may be NULL.<br>
	 * @param write_packet A function for writing the buffer contents, may be NULL.<br>
	 * @param seek A function for seeking to specified byte position, may be NULL.<br>
	 * * @return Allocated AVIOContext or NULL on failure.<br>
	 * Original signature : <code>AVIOContext* avio_alloc_context(unsigned char*, int, int, void*, avio_alloc_context_read_packet_callback*, avio_alloc_context_write_packet_callback*, avio_alloc_context_seek_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7308</i><br>
	 * @deprecated use the safer methods {@link #avio_alloc_context(java.nio.ByteBuffer, int, int, com.sun.jna.Pointer, acuitus.wrapffmpeg.AvformatLibrary.avio_alloc_context_read_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.avio_alloc_context_write_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.avio_alloc_context_seek_callback)} and {@link #avio_alloc_context(com.sun.jna.Pointer, int, int, com.sun.jna.Pointer, acuitus.wrapffmpeg.AvformatLibrary.avio_alloc_context_read_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.avio_alloc_context_write_packet_callback, acuitus.wrapffmpeg.AvformatLibrary.avio_alloc_context_seek_callback)} instead
	 */
	@Deprecated 
	AVIOContext avio_alloc_context(Pointer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.avio_alloc_context_read_packet_callback read_packet, AvformatLibrary.avio_alloc_context_write_packet_callback write_packet, AvformatLibrary.avio_alloc_context_seek_callback seek);
	/**
	 * Allocate and initialize an AVIOContext for buffered I/O. It must be later<br>
	 * freed with av_free().<br>
	 * * @param buffer Memory block for input/output operations via AVIOContext.<br>
	 *        The buffer must be allocated with av_malloc() and friends.<br>
	 * @param buffer_size The buffer size is very important for performance.<br>
	 *        For protocols with fixed blocksize it should be set to this blocksize.<br>
	 *        For others a typical size is a cache page, e.g. 4kb.<br>
	 * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.<br>
	 * @param opaque An opaque pointer to user-specific data.<br>
	 * @param read_packet  A function for refilling the buffer, may be NULL.<br>
	 * @param write_packet A function for writing the buffer contents, may be NULL.<br>
	 * @param seek A function for seeking to specified byte position, may be NULL.<br>
	 * * @return Allocated AVIOContext or NULL on failure.<br>
	 * Original signature : <code>AVIOContext* avio_alloc_context(unsigned char*, int, int, void*, avio_alloc_context_read_packet_callback*, avio_alloc_context_write_packet_callback*, avio_alloc_context_seek_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7308</i>
	 */
	AVIOContext.ByReference avio_alloc_context(ByteBuffer buffer, int buffer_size, int write_flag, Pointer opaque, AvformatLibrary.avio_alloc_context_read_packet_callback read_packet, AvformatLibrary.avio_alloc_context_write_packet_callback write_packet, AvformatLibrary.avio_alloc_context_seek_callback seek);
	/**
	 * Original signature : <code>void avio_w8(AVIOContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7310</i>
	 */
	void avio_w8(AVIOContext s, int b);
	/**
	 * Original signature : <code>void avio_write(AVIOContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7312</i><br>
	 * @deprecated use the safer methods {@link #avio_write(acuitus.wrapffmpeg.AVIOContext, byte[], int)} and {@link #avio_write(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void avio_write(AVIOContext s, Pointer buf, int size);
	/**
	 * Original signature : <code>void avio_write(AVIOContext*, const unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7312</i>
	 */
	void avio_write(AVIOContext s, byte buf[], int size);
	/**
	 * Original signature : <code>void avio_wl64(AVIOContext*, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7314</i>
	 */
	void avio_wl64(AVIOContext s, long val);
	/**
	 * Original signature : <code>void avio_wb64(AVIOContext*, uint64_t)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7316</i>
	 */
	void avio_wb64(AVIOContext s, long val);
	/**
	 * Original signature : <code>void avio_wl32(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7318</i>
	 */
	void avio_wl32(AVIOContext s, int val);
	/**
	 * Original signature : <code>void avio_wb32(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7320</i>
	 */
	void avio_wb32(AVIOContext s, int val);
	/**
	 * Original signature : <code>void avio_wl24(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7322</i>
	 */
	void avio_wl24(AVIOContext s, int val);
	/**
	 * Original signature : <code>void avio_wb24(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7324</i>
	 */
	void avio_wb24(AVIOContext s, int val);
	/**
	 * Original signature : <code>void avio_wl16(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7326</i>
	 */
	void avio_wl16(AVIOContext s, int val);
	/**
	 * Original signature : <code>void avio_wb16(AVIOContext*, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7328</i>
	 */
	void avio_wb16(AVIOContext s, int val);
	/**
	 * Write a NULL-terminated string.<br>
	 * @return number of bytes written.<br>
	 * Original signature : <code>int avio_put_str(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7334</i><br>
	 * @deprecated use the safer methods {@link #avio_put_str(acuitus.wrapffmpeg.AVIOContext, java.lang.String)} and {@link #avio_put_str(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int avio_put_str(AVIOContext s, Pointer str);
	/**
	 * Write a NULL-terminated string.<br>
	 * @return number of bytes written.<br>
	 * Original signature : <code>int avio_put_str(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7334</i>
	 */
	int avio_put_str(AVIOContext s, String str);
	/**
	 * Convert an UTF-8 string to UTF-16LE and write it.<br>
	 * @return number of bytes written.<br>
	 * Original signature : <code>int avio_put_str16le(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7340</i><br>
	 * @deprecated use the safer methods {@link #avio_put_str16le(acuitus.wrapffmpeg.AVIOContext, java.lang.String)} and {@link #avio_put_str16le(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int avio_put_str16le(AVIOContext s, Pointer str);
	/**
	 * Convert an UTF-8 string to UTF-16LE and write it.<br>
	 * @return number of bytes written.<br>
	 * Original signature : <code>int avio_put_str16le(AVIOContext*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7340</i>
	 */
	int avio_put_str16le(AVIOContext s, String str);
	/**
	 * fseek() equivalent for AVIOContext.<br>
	 * @return new position or AVERROR.<br>
	 * Original signature : <code>int64_t avio_seek(AVIOContext*, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7346</i>
	 */
	long avio_seek(AVIOContext s, long offset, int whence);
	/**
	 * Get the filesize.<br>
	 * @return filesize or AVERROR<br>
	 * Original signature : <code>int64_t avio_size(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7368</i>
	 */
	long avio_size(AVIOContext s);
	/**
	 * @warning currently size is limited<br>
	 * Original signature : <code>int avio_printf(AVIOContext*, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7373</i><br>
	 * @deprecated use the safer methods {@link #avio_printf(acuitus.wrapffmpeg.AVIOContext, java.lang.String, java.lang.Object)} and {@link #avio_printf(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	int avio_printf(AVIOContext s, Pointer fmt, Object... varargs);
	/**
	 * @warning currently size is limited<br>
	 * Original signature : <code>int avio_printf(AVIOContext*, const char*, null)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7373</i>
	 */
	int avio_printf(AVIOContext s, String fmt, Object... varargs);
	/**
	 * Original signature : <code>void avio_flush(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7375</i>
	 */
	void avio_flush(AVIOContext s);
	/**
	 * Read size bytes from AVIOContext into buf.<br>
	 * @return number of bytes read or AVERROR<br>
	 * Original signature : <code>int avio_read(AVIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7381</i><br>
	 * @deprecated use the safer methods {@link #avio_read(acuitus.wrapffmpeg.AVIOContext, java.nio.ByteBuffer, int)} and {@link #avio_read(acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avio_read(AVIOContext s, Pointer buf, int size);
	/**
	 * Read size bytes from AVIOContext into buf.<br>
	 * @return number of bytes read or AVERROR<br>
	 * Original signature : <code>int avio_read(AVIOContext*, unsigned char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7381</i>
	 */
	int avio_read(AVIOContext s, ByteBuffer buf, int size);
	/**
	 * @name Functions for reading from AVIOContext<br>
	 * @{<br>
	 * * @note return 0 if EOF, so you cannot use it if EOF handling is<br>
	 *       necessary<br>
	 * Original signature : <code>int avio_r8(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7389</i>
	 */
	int avio_r8(AVIOContext s);
	/**
	 * Original signature : <code>int avio_rl16(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7391</i>
	 */
	int avio_rl16(AVIOContext s);
	/**
	 * Original signature : <code>int avio_rl24(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7393</i>
	 */
	int avio_rl24(AVIOContext s);
	/**
	 * Original signature : <code>int avio_rl32(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7395</i>
	 */
	int avio_rl32(AVIOContext s);
	/**
	 * Original signature : <code>uint64_t avio_rl64(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7397</i>
	 */
	long avio_rl64(AVIOContext s);
	/**
	 * Original signature : <code>int avio_rb16(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7399</i>
	 */
	int avio_rb16(AVIOContext s);
	/**
	 * Original signature : <code>int avio_rb24(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7401</i>
	 */
	int avio_rb24(AVIOContext s);
	/**
	 * Original signature : <code>int avio_rb32(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7403</i>
	 */
	int avio_rb32(AVIOContext s);
	/**
	 * Original signature : <code>uint64_t avio_rb64(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7405</i>
	 */
	long avio_rb64(AVIOContext s);
	/**
	 * Read a string from pb into buf. The reading will terminate when either<br>
	 * a NULL character was encountered, maxlen bytes have been read, or nothing<br>
	 * more can be read from pb. The result is guaranteed to be NULL-terminated, it<br>
	 * will be truncated if buf is too small.<br>
	 * Note that the string is not interpreted or validated in any way, it<br>
	 * might get truncated in the middle of a sequence for multi-byte encodings.<br>
	 * * @return number of bytes read (is always <= maxlen).<br>
	 * If reading ends on EOF or error, the return value will be one more than<br>
	 * bytes actually read.<br>
	 * Original signature : <code>int avio_get_str(AVIOContext*, int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7418</i><br>
	 * @deprecated use the safer methods {@link #avio_get_str(acuitus.wrapffmpeg.AVIOContext, int, java.nio.ByteBuffer, int)} and {@link #avio_get_str(acuitus.wrapffmpeg.AVIOContext, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avio_get_str(AVIOContext pb, int maxlen, Pointer buf, int buflen);
	/**
	 * Read a string from pb into buf. The reading will terminate when either<br>
	 * a NULL character was encountered, maxlen bytes have been read, or nothing<br>
	 * more can be read from pb. The result is guaranteed to be NULL-terminated, it<br>
	 * will be truncated if buf is too small.<br>
	 * Note that the string is not interpreted or validated in any way, it<br>
	 * might get truncated in the middle of a sequence for multi-byte encodings.<br>
	 * * @return number of bytes read (is always <= maxlen).<br>
	 * If reading ends on EOF or error, the return value will be one more than<br>
	 * bytes actually read.<br>
	 * Original signature : <code>int avio_get_str(AVIOContext*, int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7418</i>
	 */
	int avio_get_str(AVIOContext pb, int maxlen, ByteBuffer buf, int buflen);
	/**
	 * Read a UTF-16 string from pb and convert it to UTF-8.<br>
	 * The reading will terminate when either a null or invalid character was<br>
	 * encountered or maxlen bytes have been read.<br>
	 * @return number of bytes read (is always <= maxlen)<br>
	 * Original signature : <code>int avio_get_str16le(AVIOContext*, int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7426</i><br>
	 * @deprecated use the safer methods {@link #avio_get_str16le(acuitus.wrapffmpeg.AVIOContext, int, java.nio.ByteBuffer, int)} and {@link #avio_get_str16le(acuitus.wrapffmpeg.AVIOContext, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avio_get_str16le(AVIOContext pb, int maxlen, Pointer buf, int buflen);
	/**
	 * Read a UTF-16 string from pb and convert it to UTF-8.<br>
	 * The reading will terminate when either a null or invalid character was<br>
	 * encountered or maxlen bytes have been read.<br>
	 * @return number of bytes read (is always <= maxlen)<br>
	 * Original signature : <code>int avio_get_str16le(AVIOContext*, int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7426</i>
	 */
	int avio_get_str16le(AVIOContext pb, int maxlen, ByteBuffer buf, int buflen);
	/**
	 * Original signature : <code>int avio_get_str16be(AVIOContext*, int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7428</i><br>
	 * @deprecated use the safer methods {@link #avio_get_str16be(acuitus.wrapffmpeg.AVIOContext, int, java.nio.ByteBuffer, int)} and {@link #avio_get_str16be(acuitus.wrapffmpeg.AVIOContext, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avio_get_str16be(AVIOContext pb, int maxlen, Pointer buf, int buflen);
	/**
	 * Original signature : <code>int avio_get_str16be(AVIOContext*, int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7428</i>
	 */
	int avio_get_str16be(AVIOContext pb, int maxlen, ByteBuffer buf, int buflen);
	/**
	 * Create and initialize a AVIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the AVIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created AVIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int avio_open(AVIOContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7442</i><br>
	 * @deprecated use the safer methods {@link #avio_open(acuitus.wrapffmpeg.AVIOContext.ByReference[], java.lang.String, int)} and {@link #avio_open(acuitus.wrapffmpeg.AVIOContext.ByReference[], com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avio_open(PointerByReference s, Pointer url, int flags);
	/**
	 * Create and initialize a AVIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the AVIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created AVIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int avio_open(AVIOContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7442</i>
	 */
	int avio_open(AVIOContext.ByReference s[], String url, int flags);
	/**
	 * Create and initialize a AVIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the AVIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created AVIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int avio_open(AVIOContext**, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7442</i>
	 */
	int avio_open(AVIOContext.ByReference s[], Pointer url, int flags);
	/**
	 * Create and initialize a AVIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the AVIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created AVIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @param int_cb an interrupt callback to be used at the protocols level<br>
	 * @param options  A dictionary filled with protocol-private options. On return<br>
	 * this parameter will be destroyed and replaced with a dict containing options<br>
	 * that were not found. May be NULL.<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int avio_open2(AVIOContext**, const char*, int, const AVIOInterruptCB*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7460</i><br>
	 * @deprecated use the safer methods {@link #avio_open2(acuitus.wrapffmpeg.AVIOContext.ByReference[], java.lang.String, int, acuitus.wrapffmpeg.AVIOInterruptCB, com.sun.jna.ptr.PointerByReference)} and {@link #avio_open2(acuitus.wrapffmpeg.AVIOContext.ByReference[], com.sun.jna.Pointer, int, acuitus.wrapffmpeg.AVIOInterruptCB, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int avio_open2(PointerByReference s, Pointer url, int flags, AVIOInterruptCB int_cb, PointerByReference options);
	/**
	 * Create and initialize a AVIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the AVIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created AVIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @param int_cb an interrupt callback to be used at the protocols level<br>
	 * @param options  A dictionary filled with protocol-private options. On return<br>
	 * this parameter will be destroyed and replaced with a dict containing options<br>
	 * that were not found. May be NULL.<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int avio_open2(AVIOContext**, const char*, int, const AVIOInterruptCB*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7460</i>
	 */
	int avio_open2(AVIOContext.ByReference s[], String url, int flags, AVIOInterruptCB int_cb, PointerByReference options);
	/**
	 * Create and initialize a AVIOContext for accessing the<br>
	 * resource indicated by url.<br>
	 * @note When the resource indicated by url has been opened in<br>
	 * read+write mode, the AVIOContext can be used only for writing.<br>
	 * * @param s Used to return the pointer to the created AVIOContext.<br>
	 * In case of failure the pointed to value is set to NULL.<br>
	 * @param flags flags which control how the resource indicated by url<br>
	 * is to be opened<br>
	 * @param int_cb an interrupt callback to be used at the protocols level<br>
	 * @param options  A dictionary filled with protocol-private options. On return<br>
	 * this parameter will be destroyed and replaced with a dict containing options<br>
	 * that were not found. May be NULL.<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code in case of failure<br>
	 * Original signature : <code>int avio_open2(AVIOContext**, const char*, int, const AVIOInterruptCB*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7460</i>
	 */
	int avio_open2(AVIOContext.ByReference s[], Pointer url, int flags, AVIOInterruptCB int_cb, PointerByReference options);
	/**
	 * Close the resource accessed by the AVIOContext s and free it.<br>
	 * This function can only be used if s was opened by avio_open().<br>
	 * * @return 0 on success, an AVERROR < 0 on error.<br>
	 * Original signature : <code>int avio_close(AVIOContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7467</i>
	 */
	int avio_close(AVIOContext s);
	/**
	 * Open a write only memory stream.<br>
	 * * @param s new IO context<br>
	 * @return zero if no error.<br>
	 * Original signature : <code>int avio_open_dyn_buf(AVIOContext**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7474</i><br>
	 * @deprecated use the safer method {@link #avio_open_dyn_buf(acuitus.wrapffmpeg.AVIOContext.ByReference[])} instead
	 */
	@Deprecated 
	int avio_open_dyn_buf(PointerByReference s);
	/**
	 * Open a write only memory stream.<br>
	 * * @param s new IO context<br>
	 * @return zero if no error.<br>
	 * Original signature : <code>int avio_open_dyn_buf(AVIOContext**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7474</i>
	 */
	int avio_open_dyn_buf(AVIOContext.ByReference s[]);
	/**
	 * Return the written size and a pointer to the buffer. The buffer<br>
	 * must be freed with av_free().<br>
	 * Padding of FF_INPUT_BUFFER_PADDING_SIZE is added to the buffer.<br>
	 * * @param s IO context<br>
	 * @param pbuffer pointer to a byte buffer<br>
	 * @return the length of the byte buffer<br>
	 * Original signature : <code>int avio_close_dyn_buf(AVIOContext*, uint8_t**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7484</i>
	 */
	int avio_close_dyn_buf(AVIOContext s, PointerByReference pbuffer);
	/**
	 * Iterate through names of available protocols.<br>
	 * * @param opaque A private pointer representing current protocol.<br>
	 *        It must be a pointer to NULL on first iteration and will<br>
	 *        be updated by successive calls to avio_enum_protocols.<br>
	 * @param output If set to 1, iterate over output protocols,<br>
	 *               otherwise over input protocols.<br>
	 * * @return A static string containing the name of current protocol or NULL<br>
	 * Original signature : <code>char* avio_enum_protocols(void**, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7495</i>
	 */
	String avio_enum_protocols(PointerByReference opaque, int output);
	/**
	 * Pause and resume playing - only meaningful if using a network streaming<br>
	 * protocol (e.g. MMS).<br>
	 * @param pause 1 for pause, 0 for resume<br>
	 * Original signature : <code>int avio_pause(AVIOContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7502</i>
	 */
	int avio_pause(AVIOContext h, int pause);
	/**
	 * Seek to a given timestamp relative to some component stream.<br>
	 * Only meaningful if using a network streaming protocol (e.g. MMS.).<br>
	 * @param stream_index The stream index that the timestamp is relative to.<br>
	 *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE<br>
	 *        units from the beginning of the presentation.<br>
	 *        If a stream_index >= 0 is used and the protocol does not support<br>
	 *        seeking based on component streams, the call will fail with ENOTSUP.<br>
	 * @param timestamp timestamp in AVStream.time_base units<br>
	 *        or if there is no stream specified then in AV_TIME_BASE units.<br>
	 * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE<br>
	 *        and AVSEEK_FLAG_ANY. The protocol may silently ignore<br>
	 *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will<br>
	 *        fail with ENOTSUP if used and not supported.<br>
	 * @return >= 0 on success<br>
	 * @see AVInputFormat::read_seek<br>
	 * Original signature : <code>int64_t avio_seek_time(AVIOContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avio.h:7521</i>
	 */
	long avio_seek_time(AVIOContext h, int stream_index, long timestamp, int flags);
	/**
	 * Get a metadata element with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found tag or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_metadata_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7534</i><br>
	 * @deprecated use the safer methods {@link #av_metadata_get(com.sun.jna.ptr.PointerByReference, java.lang.String, acuitus.wrapffmpeg.AVDictionaryEntry, int)} and {@link #av_metadata_get(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, acuitus.wrapffmpeg.AVDictionaryEntry, int)} instead
	 */
	@Deprecated 
	AVDictionaryEntry av_metadata_get(Pointer m, Pointer key, AVDictionaryEntry prev, int flags);
	/**
	 * Get a metadata element with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found tag or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_metadata_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7534</i>
	 */
	AVDictionaryEntry av_metadata_get(PointerByReference m, String key, AVDictionaryEntry prev, int flags);
	/**
	 * Get a metadata element with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found tag or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_metadata_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7534</i>
	 */
	AVDictionaryEntry av_metadata_get(PointerByReference m, Pointer key, AVDictionaryEntry prev, int flags);
	/**
	 * Set the given tag in *pm, overwriting an existing tag.<br>
	 * * @param pm pointer to a pointer to a metadata struct. If *pm is NULL<br>
	 * a metadata struct is allocated and put in *pm.<br>
	 * @param key tag key to add to *pm (will be av_strduped depending on flags)<br>
	 * @param value tag value to add to *pm (will be av_strduped depending on flags).<br>
	 *        Passing a NULL value will cause an existing tag to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_metadata_set2(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7545</i><br>
	 * @deprecated use the safer methods {@link #av_metadata_set2(com.sun.jna.ptr.PointerByReference, java.lang.String, java.lang.String, int)} and {@link #av_metadata_set2(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_metadata_set2(PointerByReference pm, Pointer key, Pointer value, int flags);
	/**
	 * Set the given tag in *pm, overwriting an existing tag.<br>
	 * * @param pm pointer to a pointer to a metadata struct. If *pm is NULL<br>
	 * a metadata struct is allocated and put in *pm.<br>
	 * @param key tag key to add to *pm (will be av_strduped depending on flags)<br>
	 * @param value tag value to add to *pm (will be av_strduped depending on flags).<br>
	 *        Passing a NULL value will cause an existing tag to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_metadata_set2(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7545</i>
	 */
	int av_metadata_set2(PointerByReference pm, String key, String value, int flags);
	/**
	 * This function is provided for compatibility reason and currently does nothing.<br>
	 * Original signature : <code>void av_metadata_conv(AVFormatContext*, const AVMetadataConv*, const AVMetadataConv*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7550</i><br>
	 * @deprecated use the safer method {@link #av_metadata_conv(acuitus.wrapffmpeg.AVFormatContext, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void av_metadata_conv(AVFormatContext ctx, Pointer d_conv, Pointer s_conv);
	/**
	 * This function is provided for compatibility reason and currently does nothing.<br>
	 * Original signature : <code>void av_metadata_conv(AVFormatContext*, const AVMetadataConv*, const AVMetadataConv*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7550</i>
	 */
	void av_metadata_conv(AVFormatContext ctx, PointerByReference d_conv, PointerByReference s_conv);
	/**
	 * Copy metadata from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting metadata in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * Original signature : <code>void av_metadata_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7560</i><br>
	 * @deprecated use the safer method {@link #av_metadata_copy(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	void av_metadata_copy(PointerByReference dst, Pointer src, int flags);
	/**
	 * Copy metadata from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting metadata in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * Original signature : <code>void av_metadata_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7560</i>
	 */
	void av_metadata_copy(PointerByReference dst, PointerByReference src, int flags);
	/**
	 * Free all the memory allocated for an AVDictionary struct.<br>
	 * Original signature : <code>void av_metadata_free(AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7565</i>
	 */
	void av_metadata_free(PointerByReference m);
	/**
	 * Allocate and read the payload of a packet and initialize its<br>
	 * fields with default values.<br>
	 * * @param pkt packet<br>
	 * @param size desired payload size<br>
	 * @return >0 (read size) if OK, AVERROR_xxx otherwise<br>
	 * Original signature : <code>int av_get_packet(AVIOContext*, AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7574</i>
	 */
	int av_get_packet(AVIOContext s, AVPacket pkt, int size);
	/**
	 * Read data and append it to the current content of the AVPacket.<br>
	 * If pkt->size is 0 this is identical to av_get_packet.<br>
	 * Note that this uses av_grow_packet and thus involves a realloc<br>
	 * which is inefficient. Thus this function should only be used<br>
	 * when there is no reasonable way to know (an upper bound of)<br>
	 * the final size.<br>
	 * * @param pkt packet<br>
	 * @param size amount of data to read<br>
	 * @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data<br>
	 *         will not be lost even if an error occurs.<br>
	 * Original signature : <code>int av_append_packet(AVIOContext*, AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:7588</i>
	 */
	int av_append_packet(AVIOContext s, AVPacket pkt, int size);
	/**
	 * Return the LIBAVFORMAT_VERSION_INT constant.<br>
	 * Original signature : <code>int avformat_version()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8143</i>
	 */
	int avformat_version();
	/**
	 * Return the libavformat build-time configuration.<br>
	 * Original signature : <code>char* avformat_configuration()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8148</i>
	 */
	String avformat_configuration();
	/**
	 * Return the libavformat license.<br>
	 * Original signature : <code>char* avformat_license()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8153</i>
	 */
	String avformat_license();
	/**
	 * Initialize libavformat and register all the muxers, demuxers and<br>
	 * protocols. If you do not call this function, then you can select<br>
	 * exactly which formats you want to support.<br>
	 * * @see av_register_input_format()<br>
	 * @see av_register_output_format()<br>
	 * @see av_register_protocol()<br>
	 * Original signature : <code>void av_register_all()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8163</i>
	 */
	void av_register_all();
	/**
	 * Original signature : <code>void av_register_input_format(AVInputFormat*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8165</i>
	 */
	void av_register_input_format(AVInputFormat format);
	/**
	 * Original signature : <code>void av_register_output_format(AVOutputFormat*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8167</i>
	 */
	void av_register_output_format(AVOutputFormat format);
	/**
	 * Do global initialization of network components. This is optional,<br>
	 * but recommended, since it avoids the overhead of implicitly<br>
	 * doing the setup for each session.<br>
	 * * Calling this function will become mandatory if using network<br>
	 * protocols at some major version bump.<br>
	 * Original signature : <code>int avformat_network_init()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8176</i>
	 */
	int avformat_network_init();
	/**
	 * Undo the initialization done by avformat_network_init.<br>
	 * Original signature : <code>int avformat_network_deinit()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8181</i>
	 */
	int avformat_network_deinit();
	/**
	 * If f is NULL, returns the first registered input format,<br>
	 * if f is non-NULL, returns the next registered input format after f<br>
	 * or NULL if f is the last one.<br>
	 * Original signature : <code>AVInputFormat* av_iformat_next(AVInputFormat*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8188</i>
	 */
	AVInputFormat av_iformat_next(AVInputFormat f);
	/**
	 * If f is NULL, returns the first registered output format,<br>
	 * if f is non-NULL, returns the next registered output format after f<br>
	 * or NULL if f is the last one.<br>
	 * Original signature : <code>AVOutputFormat* av_oformat_next(AVOutputFormat*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8195</i>
	 */
	AVOutputFormat.ByReference av_oformat_next(AVOutputFormat f);
	/**
	 * Allocate an AVFormatContext.<br>
	 * avformat_free_context() can be used to free the context and everything<br>
	 * allocated by the framework within it.<br>
	 * Original signature : <code>AVFormatContext* avformat_alloc_context()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8202</i>
	 */
	AVFormatContext avformat_alloc_context();
	/**
	 * Free an AVFormatContext and all its streams.<br>
	 * @param s context to free<br>
	 * Original signature : <code>void avformat_free_context(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8208</i>
	 */
	void avformat_free_context(AVFormatContext s);
	/**
	 * Get the AVClass for AVFormatContext. It can be used in combination with<br>
	 * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
	 * * @see av_opt_find().<br>
	 * Original signature : <code>AVClass* avformat_get_class()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8215</i>
	 */
	AVClass avformat_get_class();
	/**
	 * Add a new stream to a media file.<br>
	 * * When demuxing, it is called by the demuxer in read_header(). If the<br>
	 * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also<br>
	 * be called in read_packet().<br>
	 * * When muxing, should be called by the user before avformat_write_header().<br>
	 * * @param c If non-NULL, the AVCodecContext corresponding to the new stream<br>
	 * will be initialized to use this codec. This is needed for e.g. codec-specific<br>
	 * defaults to be set, so codec should be provided if it is known.<br>
	 * * @return newly created stream or NULL on error.<br>
	 * Original signature : <code>AVStream* avformat_new_stream(AVFormatContext*, AVCodec*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8228</i>
	 */
	AVStream avformat_new_stream(AVFormatContext s, AVCodec c);
	/**
	 * Original signature : <code>AVProgram* av_new_program(AVFormatContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8230</i>
	 */
	AVProgram av_new_program(AVFormatContext s, int id);
	/**
	 * Original signature : <code>CodecID av_guess_image2_codec(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8232</i><br>
	 * @deprecated use the safer methods {@link #av_guess_image2_codec(java.lang.String)} and {@link #av_guess_image2_codec(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_guess_image2_codec(Pointer filename);
	/**
	 * Original signature : <code>CodecID av_guess_image2_codec(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8232</i>
	 */
	int av_guess_image2_codec(String filename);
	/**
	 * Original signature : <code>void av_pkt_dump(FILE*, AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8234</i><br>
	 * @deprecated use the safer method {@link #av_pkt_dump(com.sun.jna.ptr.PointerByReference, acuitus.wrapffmpeg.AVPacket, int)} instead
	 */
	@Deprecated 
	void av_pkt_dump(Pointer f, AVPacket pkt, int dump_payload);
	/**
	 * Original signature : <code>void av_pkt_dump(FILE*, AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8234</i>
	 */
	void av_pkt_dump(PointerByReference f, AVPacket pkt, int dump_payload);
	/**
	 * Original signature : <code>void av_pkt_dump_log(void*, int, AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8236</i>
	 */
	void av_pkt_dump_log(Pointer avcl, int level, AVPacket pkt, int dump_payload);
	/**
	 * Find AVInputFormat based on the short name of the input format.<br>
	 * Original signature : <code>AVInputFormat* av_find_input_format(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8241</i><br>
	 * @deprecated use the safer methods {@link #av_find_input_format(java.lang.String)} and {@link #av_find_input_format(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	AVInputFormat av_find_input_format(Pointer short_name);
	/**
	 * Find AVInputFormat based on the short name of the input format.<br>
	 * Original signature : <code>AVInputFormat* av_find_input_format(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8241</i>
	 */
	AVInputFormat av_find_input_format(String short_name);
	/**
	 * Guess the file format.<br>
	 * * @param is_opened Whether the file is already opened; determines whether<br>
	 *                  demuxers with or without AVFMT_NOFILE are probed.<br>
	 * Original signature : <code>AVInputFormat* av_probe_input_format(AVProbeData*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8248</i>
	 */
	AVInputFormat av_probe_input_format(AVProbeData pd, int is_opened);
	/**
	 * Guess the file format.<br>
	 * * @param is_opened Whether the file is already opened; determines whether<br>
	 *                  demuxers with or without AVFMT_NOFILE are probed.<br>
	 * @param score_max A probe score larger that this is required to accept a<br>
	 *                  detection, the variable is set to the actual detection<br>
	 *                  score afterwards.<br>
	 *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended<br>
	 *                  to retry with a larger probe buffer.<br>
	 * Original signature : <code>AVInputFormat* av_probe_input_format2(AVProbeData*, int, int*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8260</i><br>
	 * @deprecated use the safer methods {@link #av_probe_input_format2(acuitus.wrapffmpeg.AVProbeData, int, java.nio.IntBuffer)} and {@link #av_probe_input_format2(acuitus.wrapffmpeg.AVProbeData, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	AVInputFormat av_probe_input_format2(AVProbeData pd, int is_opened, IntByReference score_max);
	/**
	 * Guess the file format.<br>
	 * * @param is_opened Whether the file is already opened; determines whether<br>
	 *                  demuxers with or without AVFMT_NOFILE are probed.<br>
	 * @param score_max A probe score larger that this is required to accept a<br>
	 *                  detection, the variable is set to the actual detection<br>
	 *                  score afterwards.<br>
	 *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended<br>
	 *                  to retry with a larger probe buffer.<br>
	 * Original signature : <code>AVInputFormat* av_probe_input_format2(AVProbeData*, int, int*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8260</i>
	 */
	AVInputFormat av_probe_input_format2(AVProbeData pd, int is_opened, IntBuffer score_max);
	/**
	 * Probe a bytestream to determine the input format. Each time a probe returns<br>
	 * with a score that is too low, the probe buffer size is increased and another<br>
	 * attempt is made. When the maximum probe size is reached, the input format<br>
	 * with the highest score is returned.<br>
	 * * @param pb the bytestream to probe<br>
	 * @param fmt the input format is put here<br>
	 * @param filename the filename of the stream<br>
	 * @param logctx the log context<br>
	 * @param offset the offset within the bytestream to probe from<br>
	 * @param max_probe_size the maximum probe buffer size (zero for default)<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code otherwise<br>
	 * Original signature : <code>int av_probe_input_buffer(AVIOContext*, AVInputFormat**, const char*, void*, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8276</i><br>
	 * @deprecated use the safer methods {@link #av_probe_input_buffer(acuitus.wrapffmpeg.AVIOContext, acuitus.wrapffmpeg.AVInputFormat.ByReference[], java.lang.String, com.sun.jna.Pointer, int, int)} and {@link #av_probe_input_buffer(acuitus.wrapffmpeg.AVIOContext, acuitus.wrapffmpeg.AVInputFormat.ByReference[], com.sun.jna.Pointer, com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	int av_probe_input_buffer(AVIOContext pb, PointerByReference fmt, Pointer filename, Pointer logctx, int offset, int max_probe_size);
	/**
	 * Probe a bytestream to determine the input format. Each time a probe returns<br>
	 * with a score that is too low, the probe buffer size is increased and another<br>
	 * attempt is made. When the maximum probe size is reached, the input format<br>
	 * with the highest score is returned.<br>
	 * * @param pb the bytestream to probe<br>
	 * @param fmt the input format is put here<br>
	 * @param filename the filename of the stream<br>
	 * @param logctx the log context<br>
	 * @param offset the offset within the bytestream to probe from<br>
	 * @param max_probe_size the maximum probe buffer size (zero for default)<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code otherwise<br>
	 * Original signature : <code>int av_probe_input_buffer(AVIOContext*, AVInputFormat**, const char*, void*, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8276</i>
	 */
	int av_probe_input_buffer(AVIOContext pb, AVInputFormat.ByReference fmt[], String filename, Pointer logctx, int offset, int max_probe_size);
	/**
	 * Probe a bytestream to determine the input format. Each time a probe returns<br>
	 * with a score that is too low, the probe buffer size is increased and another<br>
	 * attempt is made. When the maximum probe size is reached, the input format<br>
	 * with the highest score is returned.<br>
	 * * @param pb the bytestream to probe<br>
	 * @param fmt the input format is put here<br>
	 * @param filename the filename of the stream<br>
	 * @param logctx the log context<br>
	 * @param offset the offset within the bytestream to probe from<br>
	 * @param max_probe_size the maximum probe buffer size (zero for default)<br>
	 * @return 0 in case of success, a negative value corresponding to an<br>
	 * AVERROR code otherwise<br>
	 * Original signature : <code>int av_probe_input_buffer(AVIOContext*, AVInputFormat**, const char*, void*, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8276</i>
	 */
	int av_probe_input_buffer(AVIOContext pb, AVInputFormat.ByReference fmt[], Pointer filename, Pointer logctx, int offset, int max_probe_size);
	/**
	 * Allocate all the structures needed to read an input stream.<br>
	 *        This does not open the needed codecs for decoding the stream[s].<br>
	 * @deprecated use avformat_open_input instead.<br>
	 * Original signature : <code>int av_open_input_stream(AVFormatContext**, AVIOContext*, const char*, AVInputFormat*, AVFormatParameters*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8283</i><br>
	 * @deprecated use the safer methods {@link #av_open_input_stream(acuitus.wrapffmpeg.AVFormatContext.ByReference[], acuitus.wrapffmpeg.AVIOContext, java.lang.String, acuitus.wrapffmpeg.AVInputFormat, acuitus.wrapffmpeg.AVFormatParameters)} and {@link #av_open_input_stream(acuitus.wrapffmpeg.AVFormatContext.ByReference[], acuitus.wrapffmpeg.AVIOContext, com.sun.jna.Pointer, acuitus.wrapffmpeg.AVInputFormat, acuitus.wrapffmpeg.AVFormatParameters)} instead
	 */
	@Deprecated 
	int av_open_input_stream(PointerByReference ic_ptr, AVIOContext pb, Pointer filename, AVInputFormat fmt, AVFormatParameters ap);
	/**
	 * Allocate all the structures needed to read an input stream.<br>
	 *        This does not open the needed codecs for decoding the stream[s].<br>
	 * @deprecated use avformat_open_input instead.<br>
	 * Original signature : <code>int av_open_input_stream(AVFormatContext**, AVIOContext*, const char*, AVInputFormat*, AVFormatParameters*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8283</i>
	 */
	int av_open_input_stream(AVFormatContext.ByReference ic_ptr[], AVIOContext pb, String filename, AVInputFormat fmt, AVFormatParameters ap);
	/**
	 * Allocate all the structures needed to read an input stream.<br>
	 *        This does not open the needed codecs for decoding the stream[s].<br>
	 * @deprecated use avformat_open_input instead.<br>
	 * Original signature : <code>int av_open_input_stream(AVFormatContext**, AVIOContext*, const char*, AVInputFormat*, AVFormatParameters*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8283</i>
	 */
	int av_open_input_stream(AVFormatContext.ByReference ic_ptr[], AVIOContext pb, Pointer filename, AVInputFormat fmt, AVFormatParameters ap);
	/**
	 * Open a media file as input. The codecs are not opened. Only the file<br>
	 * header (if present) is read.<br>
	 * * @param ic_ptr The opened media file handle is put here.<br>
	 * @param filename filename to open<br>
	 * @param fmt If non-NULL, force the file format to use.<br>
	 * @param buf_size optional buffer size (zero if default is OK)<br>
	 * @param ap Additional parameters needed when opening the file<br>
	 *           (NULL if default).<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * * @deprecated use avformat_open_input instead.<br>
	 * Original signature : <code>int av_open_input_file(AVFormatContext**, const char*, AVInputFormat*, int, AVFormatParameters*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8297</i><br>
	 * @deprecated use the safer methods {@link #av_open_input_file(acuitus.wrapffmpeg.AVFormatContext.ByReference[], java.lang.String, acuitus.wrapffmpeg.AVInputFormat, int, acuitus.wrapffmpeg.AVFormatParameters)} and {@link #av_open_input_file(acuitus.wrapffmpeg.AVFormatContext.ByReference[], com.sun.jna.Pointer, acuitus.wrapffmpeg.AVInputFormat, int, acuitus.wrapffmpeg.AVFormatParameters)} instead
	 */
	@Deprecated 
	int av_open_input_file(PointerByReference ic_ptr, Pointer filename, AVInputFormat fmt, int buf_size, AVFormatParameters ap);
	/**
	 * Open a media file as input. The codecs are not opened. Only the file<br>
	 * header (if present) is read.<br>
	 * * @param ic_ptr The opened media file handle is put here.<br>
	 * @param filename filename to open<br>
	 * @param fmt If non-NULL, force the file format to use.<br>
	 * @param buf_size optional buffer size (zero if default is OK)<br>
	 * @param ap Additional parameters needed when opening the file<br>
	 *           (NULL if default).<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * * @deprecated use avformat_open_input instead.<br>
	 * Original signature : <code>int av_open_input_file(AVFormatContext**, const char*, AVInputFormat*, int, AVFormatParameters*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8297</i>
	 */
	int av_open_input_file(AVFormatContext.ByReference ic_ptr[], String filename, AVInputFormat fmt, int buf_size, AVFormatParameters ap);
	/**
	 * Open a media file as input. The codecs are not opened. Only the file<br>
	 * header (if present) is read.<br>
	 * * @param ic_ptr The opened media file handle is put here.<br>
	 * @param filename filename to open<br>
	 * @param fmt If non-NULL, force the file format to use.<br>
	 * @param buf_size optional buffer size (zero if default is OK)<br>
	 * @param ap Additional parameters needed when opening the file<br>
	 *           (NULL if default).<br>
	 * @return 0 if OK, AVERROR_xxx otherwise<br>
	 * * @deprecated use avformat_open_input instead.<br>
	 * Original signature : <code>int av_open_input_file(AVFormatContext**, const char*, AVInputFormat*, int, AVFormatParameters*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8297</i>
	 */
	int av_open_input_file(AVFormatContext.ByReference ic_ptr[], Pointer filename, AVInputFormat fmt, int buf_size, AVFormatParameters ap);
	/**
	 * Open an input stream and read the header. The codecs are not opened.<br>
	 * The stream must be closed with av_close_input_file().<br>
	 * * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).<br>
	 *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this<br>
	 *           function and written into ps.<br>
	 *           Note that a user-supplied AVFormatContext will be freed on failure.<br>
	 * @param filename Name of the stream to open.<br>
	 * @param fmt If non-NULL, this parameter forces a specific input format.<br>
	 *            Otherwise the format is autodetected.<br>
	 * @param options  A dictionary filled with AVFormatContext and demuxer-private options.<br>
	 *                 On return this parameter will be destroyed and replaced with a dict containing<br>
	 *                 options that were not found. May be NULL.<br>
	 * * @return 0 on success, a negative AVERROR on failure.<br>
	 * * @note If you want to use custom IO, preallocate the format context and set its pb field.<br>
	 * Original signature : <code>int avformat_open_input(AVFormatContext**, const char*, AVInputFormat*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8315</i><br>
	 * @deprecated use the safer methods {@link #avformat_open_input(acuitus.wrapffmpeg.AVFormatContext.ByReference[], java.lang.String, acuitus.wrapffmpeg.AVInputFormat, com.sun.jna.ptr.PointerByReference)} and {@link #avformat_open_input(acuitus.wrapffmpeg.AVFormatContext.ByReference[], com.sun.jna.Pointer, acuitus.wrapffmpeg.AVInputFormat, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int avformat_open_input(PointerByReference ps, Pointer filename, AVInputFormat fmt, PointerByReference options);
	/**
	 * Open an input stream and read the header. The codecs are not opened.<br>
	 * The stream must be closed with av_close_input_file().<br>
	 * * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).<br>
	 *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this<br>
	 *           function and written into ps.<br>
	 *           Note that a user-supplied AVFormatContext will be freed on failure.<br>
	 * @param filename Name of the stream to open.<br>
	 * @param fmt If non-NULL, this parameter forces a specific input format.<br>
	 *            Otherwise the format is autodetected.<br>
	 * @param options  A dictionary filled with AVFormatContext and demuxer-private options.<br>
	 *                 On return this parameter will be destroyed and replaced with a dict containing<br>
	 *                 options that were not found. May be NULL.<br>
	 * * @return 0 on success, a negative AVERROR on failure.<br>
	 * * @note If you want to use custom IO, preallocate the format context and set its pb field.<br>
	 * Original signature : <code>int avformat_open_input(AVFormatContext**, const char*, AVInputFormat*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8315</i>
	 */
	int avformat_open_input(AVFormatContext.ByReference ps[], String filename, AVInputFormat fmt, PointerByReference options);
	/**
	 * Open an input stream and read the header. The codecs are not opened.<br>
	 * The stream must be closed with av_close_input_file().<br>
	 * * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).<br>
	 *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this<br>
	 *           function and written into ps.<br>
	 *           Note that a user-supplied AVFormatContext will be freed on failure.<br>
	 * @param filename Name of the stream to open.<br>
	 * @param fmt If non-NULL, this parameter forces a specific input format.<br>
	 *            Otherwise the format is autodetected.<br>
	 * @param options  A dictionary filled with AVFormatContext and demuxer-private options.<br>
	 *                 On return this parameter will be destroyed and replaced with a dict containing<br>
	 *                 options that were not found. May be NULL.<br>
	 * * @return 0 on success, a negative AVERROR on failure.<br>
	 * * @note If you want to use custom IO, preallocate the format context and set its pb field.<br>
	 * Original signature : <code>int avformat_open_input(AVFormatContext**, const char*, AVInputFormat*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8315</i>
	 */
	int avformat_open_input(AVFormatContext.ByReference ps[], Pointer filename, AVInputFormat fmt, PointerByReference options);
	/**
	 * Original signature : <code>int av_find_stream_info(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8317</i>
	 */
	int av_find_stream_info(AVFormatContext ic);
	/**
	 * Read packets of a media file to get stream information. This<br>
	 * is useful for file formats with no headers such as MPEG. This<br>
	 * function also computes the real framerate in case of MPEG-2 repeat<br>
	 * frame mode.<br>
	 * The logical file position is not changed by this function;<br>
	 * examined packets may be buffered for later processing.<br>
	 * * @param ic media file handle<br>
	 * @param options  If non-NULL, an ic.nb_streams long array of pointers to<br>
	 *                 dictionaries, where i-th member contains options for<br>
	 *                 codec corresponding to i-th stream.<br>
	 *                 On return each dictionary will be filled with options that were not found.<br>
	 * @return >=0 if OK, AVERROR_xxx on error<br>
	 * * @note this function isn't guaranteed to open all the codecs, so<br>
	 *       options being non-empty at return is a perfectly normal behavior.<br>
	 * * @todo Let the user decide somehow what information is needed so that<br>
	 *       we do not waste time getting stuff the user does not need.<br>
	 * Original signature : <code>int avformat_find_stream_info(AVFormatContext*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8337</i>
	 */
	int avformat_find_stream_info(AVFormatContext ic, PointerByReference options);
	/**
	 * Find the "best" stream in the file.<br>
	 * The best stream is determined according to various heuristics as the most<br>
	 * likely to be what the user expects.<br>
	 * If the decoder parameter is non-NULL, av_find_best_stream will find the<br>
	 * default decoder for the stream's codec; streams for which no decoder can<br>
	 * be found are ignored.<br>
	 * * @param ic                media file handle<br>
	 * @param type              stream type: video, audio, subtitles, etc.<br>
	 * @param wanted_stream_nb  user-requested stream number,<br>
	 *                          or -1 for automatic selection<br>
	 * @param related_stream    try to find a stream related (eg. in the same<br>
	 *                          program) to this one, or -1 if none<br>
	 * @param decoder_ret       if non-NULL, returns the decoder for the<br>
	 *                          selected stream<br>
	 * @param flags             flags; none are currently defined<br>
	 * @return  the non-negative stream number in case of success,<br>
	 *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type<br>
	 *          could be found,<br>
	 *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder<br>
	 * @note  If av_find_best_stream returns successfully and decoder_ret is not<br>
	 *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.<br>
	 * Original signature : <code>int av_find_best_stream(AVFormatContext*, AVMediaType, int, int, AVCodec**, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8362</i><br>
	 * @deprecated use the safer method {@link #av_find_best_stream(acuitus.wrapffmpeg.AVFormatContext, int, int, int, acuitus.wrapffmpeg.AVCodec.ByReference[], int)} instead
	 */
	@Deprecated 
	int av_find_best_stream(AVFormatContext ic, int type, int wanted_stream_nb, int related_stream, PointerByReference decoder_ret, int flags);
	/**
	 * Find the "best" stream in the file.<br>
	 * The best stream is determined according to various heuristics as the most<br>
	 * likely to be what the user expects.<br>
	 * If the decoder parameter is non-NULL, av_find_best_stream will find the<br>
	 * default decoder for the stream's codec; streams for which no decoder can<br>
	 * be found are ignored.<br>
	 * * @param ic                media file handle<br>
	 * @param type              stream type: video, audio, subtitles, etc.<br>
	 * @param wanted_stream_nb  user-requested stream number,<br>
	 *                          or -1 for automatic selection<br>
	 * @param related_stream    try to find a stream related (eg. in the same<br>
	 *                          program) to this one, or -1 if none<br>
	 * @param decoder_ret       if non-NULL, returns the decoder for the<br>
	 *                          selected stream<br>
	 * @param flags             flags; none are currently defined<br>
	 * @return  the non-negative stream number in case of success,<br>
	 *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type<br>
	 *          could be found,<br>
	 *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder<br>
	 * @note  If av_find_best_stream returns successfully and decoder_ret is not<br>
	 *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.<br>
	 * Original signature : <code>int av_find_best_stream(AVFormatContext*, AVMediaType, int, int, AVCodec**, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8362</i>
	 */
	int av_find_best_stream(AVFormatContext ic, int type, int wanted_stream_nb, int related_stream, AVCodec.ByReference decoder_ret[], int flags);
	/**
	 * Read a transport packet from a media file.<br>
	 * * This function is obsolete and should never be used.<br>
	 * Use av_read_frame() instead.<br>
	 * * @param s media file handle<br>
	 * @param pkt is filled<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_read_packet(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8372</i>
	 */
	int av_read_packet(AVFormatContext s, AVPacket pkt);
	/**
	 * Return the next frame of a stream.<br>
	 * This function returns what is stored in the file, and does not validate<br>
	 * that what is there are valid frames for the decoder. It will split what is<br>
	 * stored in the file into frames and return one for each call. It will not<br>
	 * omit invalid data between valid frames so as to give the decoder the maximum<br>
	 * information possible for decoding.<br>
	 * * The returned packet is valid<br>
	 * until the next av_read_frame() or until av_close_input_file() and<br>
	 * must be freed with av_free_packet. For video, the packet contains<br>
	 * exactly one frame. For audio, it contains an integer number of<br>
	 * frames if each frame has a known fixed size (e.g. PCM or ADPCM<br>
	 * data). If the audio frames have a variable size (e.g. MPEG audio),<br>
	 * then it contains one frame.<br>
	 * * pkt->pts, pkt->dts and pkt->duration are always set to correct<br>
	 * values in AVStream.time_base units (and guessed if the format cannot<br>
	 * provide them). pkt->pts can be AV_NOPTS_VALUE if the video format<br>
	 * has B-frames, so it is better to rely on pkt->dts if you do not<br>
	 * decompress the payload.<br>
	 * * @return 0 if OK, < 0 on error or end of file<br>
	 * Original signature : <code>int av_read_frame(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8395</i>
	 */
	int av_read_frame(AVFormatContext s, AVPacket pkt);
	/**
	 * Seek to the keyframe at timestamp.<br>
	 * 'timestamp' in 'stream_index'.<br>
	 * @param stream_index If stream_index is (-1), a default<br>
	 * stream is selected, and timestamp is automatically converted<br>
	 * from AV_TIME_BASE units to the stream specific time_base.<br>
	 * @param timestamp Timestamp in AVStream.time_base units<br>
	 *        or, if no stream is specified, in AV_TIME_BASE units.<br>
	 * @param flags flags which select direction and seeking mode<br>
	 * @return >= 0 on success<br>
	 * Original signature : <code>int av_seek_frame(AVFormatContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8408</i>
	 */
	int av_seek_frame(AVFormatContext s, int stream_index, long timestamp, int flags);
	/**
	 * Seek to timestamp ts.<br>
	 * Seeking will be done so that the point from which all active streams<br>
	 * can be presented successfully will be closest to ts and within min/max_ts.<br>
	 * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.<br>
	 * * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and<br>
	 * are the file position (this may not be supported by all demuxers).<br>
	 * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames<br>
	 * in the stream with stream_index (this may not be supported by all demuxers).<br>
	 * Otherwise all timestamps are in units of the stream selected by stream_index<br>
	 * or if stream_index is -1, in AV_TIME_BASE units.<br>
	 * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as<br>
	 * keyframes (this may not be supported by all demuxers).<br>
	 * * @param stream_index index of the stream which is used as time base reference<br>
	 * @param min_ts smallest acceptable timestamp<br>
	 * @param ts target timestamp<br>
	 * @param max_ts largest acceptable timestamp<br>
	 * @param flags flags<br>
	 * @return >=0 on success, error code otherwise<br>
	 * * @note This is part of the new seek API which is still under construction.<br>
	 *       Thus do not use this yet. It may change at any time, do not expect<br>
	 *       ABI compatibility yet!<br>
	 * Original signature : <code>int avformat_seek_file(AVFormatContext*, int, int64_t, int64_t, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8433</i>
	 */
	int avformat_seek_file(AVFormatContext s, int stream_index, long min_ts, long ts, long max_ts, int flags);
	/**
	 * Start playing a network-based stream (e.g. RTSP stream) at the<br>
	 * current position.<br>
	 * Original signature : <code>int av_read_play(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8439</i>
	 */
	int av_read_play(AVFormatContext s);
	/**
	 * Pause a network-based stream (e.g. RTSP stream).<br>
	 * * Use av_read_play() to resume it.<br>
	 * Original signature : <code>int av_read_pause(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8445</i>
	 */
	int av_read_pause(AVFormatContext s);
	/**
	 * Original signature : <code>void av_close_input_stream(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8447</i>
	 */
	void av_close_input_stream(AVFormatContext s);
	/**
	 * Original signature : <code>void av_close_input_file(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8449</i>
	 */
	void av_close_input_file(AVFormatContext s);
	/**
	 * Close an opened input AVFormatContext. Free it and all its contents<br>
	 * and set *s to NULL.<br>
	 * Original signature : <code>void avformat_close_input(AVFormatContext**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8455</i><br>
	 * @deprecated use the safer method {@link #avformat_close_input(acuitus.wrapffmpeg.AVFormatContext.ByReference[])} instead
	 */
	@Deprecated 
	void avformat_close_input(PointerByReference s);
	/**
	 * Close an opened input AVFormatContext. Free it and all its contents<br>
	 * and set *s to NULL.<br>
	 * Original signature : <code>void avformat_close_input(AVFormatContext**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8455</i>
	 */
	void avformat_close_input(AVFormatContext.ByReference s[]);
	/**
	 * Original signature : <code>AVStream* av_new_stream(AVFormatContext*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8457</i>
	 */
	AVStream av_new_stream(AVFormatContext s, int id);
	/**
	 * Original signature : <code>void av_set_pts_info(AVStream*, int, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8459</i>
	 */
	void av_set_pts_info(AVStream s, int pts_wrap_bits, int pts_num, int pts_den);
	/**
	 * Original signature : <code>int av_seek_frame_binary(AVFormatContext*, int, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8461</i>
	 */
	int av_seek_frame_binary(AVFormatContext s, int stream_index, long target_ts, int flags);
	/**
	 * Original signature : <code>void av_update_cur_dts(AVFormatContext*, AVStream*, int64_t)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8463</i>
	 */
	void av_update_cur_dts(AVFormatContext s, AVStream ref_st, long timestamp);
	/**
	 * Original signature : <code>int64_t av_gen_search(AVFormatContext*, int, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int, int64_t*, av_gen_search_read_timestamp_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8465</i><br>
	 * @deprecated use the safer methods {@link #av_gen_search(acuitus.wrapffmpeg.AVFormatContext, int, long, long, long, long, long, long, int, java.nio.LongBuffer, acuitus.wrapffmpeg.AvformatLibrary.av_gen_search_read_timestamp_callback)} and {@link #av_gen_search(acuitus.wrapffmpeg.AVFormatContext, int, long, long, long, long, long, long, int, com.sun.jna.ptr.LongByReference, acuitus.wrapffmpeg.AvformatLibrary.av_gen_search_read_timestamp_callback)} instead
	 */
	@Deprecated 
	long av_gen_search(AVFormatContext s, int stream_index, long target_ts, long pos_min, long pos_max, long pos_limit, long ts_min, long ts_max, int flags, LongByReference ts_ret, AvformatLibrary.av_gen_search_read_timestamp_callback read_timestamp);
	/**
	 * Original signature : <code>int64_t av_gen_search(AVFormatContext*, int, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int, int64_t*, av_gen_search_read_timestamp_callback*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8465</i>
	 */
	long av_gen_search(AVFormatContext s, int stream_index, long target_ts, long pos_min, long pos_max, long pos_limit, long ts_min, long ts_max, int flags, LongBuffer ts_ret, AvformatLibrary.av_gen_search_read_timestamp_callback read_timestamp);
	/**
	 * @deprecated pass the options to avformat_write_header directly.<br>
	 * Original signature : <code>int av_set_parameters(AVFormatContext*, AVFormatParameters*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8470</i>
	 */
	int av_set_parameters(AVFormatContext s, AVFormatParameters ap);
	/**
	 * Allocate the stream private data and write the stream header to<br>
	 * an output media file.<br>
	 * * @param s Media file handle, must be allocated with avformat_alloc_context().<br>
	 *          Its oformat field must be set to the desired output format;<br>
	 *          Its pb field must be set to an already openened AVIOContext.<br>
	 * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.<br>
	 *                 On return this parameter will be destroyed and replaced with a dict containing<br>
	 *                 options that were not found. May be NULL.<br>
	 * * @return 0 on success, negative AVERROR on failure.<br>
	 * * @see av_opt_find, av_dict_set, avio_open, av_oformat_next.<br>
	 * Original signature : <code>int avformat_write_header(AVFormatContext*, AVDictionary**)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8484</i>
	 */
	int avformat_write_header(AVFormatContext s, PointerByReference options);
	/**
	 * Allocate the stream private data and write the stream header to an<br>
	 * output media file.<br>
	 * @note: this sets stream time-bases, if possible to stream->codec->time_base<br>
	 * but for some formats it might also be some other time base<br>
	 * * @param s media file handle<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * * @deprecated use avformat_write_header.<br>
	 * Original signature : <code>int av_write_header(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8495</i>
	 */
	int av_write_header(AVFormatContext s);
	/**
	 * Write a packet to an output media file.<br>
	 * * The packet shall contain one audio or video frame.<br>
	 * The packet must be correctly interleaved according to the container<br>
	 * specification, if not then av_interleaved_write_frame must be used.<br>
	 * * @param s media file handle<br>
	 * @param pkt The packet, which contains the stream_index, buf/buf_size,<br>
	 * dts/pts, ...<br>
	 * @return < 0 on error, = 0 if OK, 1 if end of stream wanted<br>
	 * Original signature : <code>int av_write_frame(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8507</i>
	 */
	int av_write_frame(AVFormatContext s, AVPacket pkt);
	/**
	 * Write a packet to an output media file ensuring correct interleaving.<br>
	 * * The packet must contain one audio or video frame.<br>
	 * If the packets are already correctly interleaved, the application should<br>
	 * call av_write_frame() instead as it is slightly faster. It is also important<br>
	 * to keep in mind that completely non-interleaved input will need huge amounts<br>
	 * of memory to interleave with this, so it is preferable to interleave at the<br>
	 * demuxer level.<br>
	 * * @param s media file handle<br>
	 * @param pkt The packet containing the data to be written. Libavformat takes<br>
	 * ownership of the data and will free it when it sees fit using the packet's<br>
	 * @ref AVPacket.destruct "destruct" field. The caller must not access the data<br>
	 * after this function returns, as it may already be freed.<br>
	 * Packet's @ref AVPacket.stream_index "stream_index" field must be set to the<br>
	 * index of the corresponding stream in @ref AVFormatContext.streams<br>
	 * "s.streams".<br>
	 * It is very strongly recommended that timing information (@ref AVPacket.pts<br>
	 * "pts", @ref AVPacket.dts "dts" @ref AVPacket.duration "duration") is set to<br>
	 * correct values.<br>
	 * * @return 0 on success, a negative AVERROR on error.<br>
	 * Original signature : <code>int av_interleaved_write_frame(AVFormatContext*, AVPacket*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8530</i>
	 */
	int av_interleaved_write_frame(AVFormatContext s, AVPacket pkt);
	/**
	 * Interleave a packet per dts in an output media file.<br>
	 * * Packets with pkt->destruct == av_destruct_packet will be freed inside this<br>
	 * function, so they cannot be used after it. Note that calling av_free_packet()<br>
	 * on them is still safe.<br>
	 * * @param s media file handle<br>
	 * @param out the interleaved packet will be output here<br>
	 * @param pkt the input packet<br>
	 * @param flush 1 if no further packets are available as input and all<br>
	 *              remaining packets should be output<br>
	 * @return 1 if a packet was output, 0 if no packet could be output,<br>
	 *         < 0 if an error occurred<br>
	 * Original signature : <code>int av_interleave_packet_per_dts(AVFormatContext*, AVPacket*, AVPacket*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8545</i>
	 */
	int av_interleave_packet_per_dts(AVFormatContext s, AVPacket out, AVPacket pkt, int flush);
	/**
	 * Write the stream trailer to an output media file and free the<br>
	 * file private data.<br>
	 * * May only be called after a successful call to av_write_header.<br>
	 * * @param s media file handle<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_write_trailer(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8554</i>
	 */
	int av_write_trailer(AVFormatContext s);
	/**
	 * Return the output format in the list of registered output formats<br>
	 * which best matches the provided parameters, or return NULL if<br>
	 * there is no match.<br>
	 * * @param short_name if non-NULL checks if short_name matches with the<br>
	 * names of the registered formats<br>
	 * @param filename if non-NULL checks if filename terminates with the<br>
	 * extensions of the registered formats<br>
	 * @param mime_type if non-NULL checks if mime_type matches with the<br>
	 * MIME type of the registered formats<br>
	 * Original signature : <code>AVOutputFormat* av_guess_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8567</i><br>
	 * @deprecated use the safer methods {@link #av_guess_format(java.lang.String, java.lang.String, java.lang.String)} and {@link #av_guess_format(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	AVOutputFormat av_guess_format(Pointer short_name, Pointer filename, Pointer mime_type);
	/**
	 * Return the output format in the list of registered output formats<br>
	 * which best matches the provided parameters, or return NULL if<br>
	 * there is no match.<br>
	 * * @param short_name if non-NULL checks if short_name matches with the<br>
	 * names of the registered formats<br>
	 * @param filename if non-NULL checks if filename terminates with the<br>
	 * extensions of the registered formats<br>
	 * @param mime_type if non-NULL checks if mime_type matches with the<br>
	 * MIME type of the registered formats<br>
	 * Original signature : <code>AVOutputFormat* av_guess_format(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8567</i>
	 */
	AVOutputFormat av_guess_format(String short_name, String filename, String mime_type);
	/**
	 * Guess the codec ID based upon muxer and filename.<br>
	 * Original signature : <code>CodecID av_guess_codec(AVOutputFormat*, const char*, const char*, const char*, AVMediaType)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8572</i><br>
	 * @deprecated use the safer methods {@link #av_guess_codec(acuitus.wrapffmpeg.AVOutputFormat, java.lang.String, java.lang.String, java.lang.String, int)} and {@link #av_guess_codec(acuitus.wrapffmpeg.AVOutputFormat, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_guess_codec(AVOutputFormat fmt, Pointer short_name, Pointer filename, Pointer mime_type, int type);
	/**
	 * Guess the codec ID based upon muxer and filename.<br>
	 * Original signature : <code>CodecID av_guess_codec(AVOutputFormat*, const char*, const char*, const char*, AVMediaType)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8572</i>
	 */
	int av_guess_codec(AVOutputFormat fmt, String short_name, String filename, String mime_type, int type);
	/**
	 * Send a nice hexadecimal dump of a buffer to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2<br>
	 * Original signature : <code>void av_hex_dump(FILE*, uint8_t*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8581</i><br>
	 * @deprecated use the safer methods {@link #av_hex_dump(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, int)} and {@link #av_hex_dump(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void av_hex_dump(Pointer f, Pointer buf, int size);
	/**
	 * Send a nice hexadecimal dump of a buffer to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2<br>
	 * Original signature : <code>void av_hex_dump(FILE*, uint8_t*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8581</i>
	 */
	void av_hex_dump(PointerByReference f, ByteBuffer buf, int size);
	/**
	 * Send a nice hexadecimal dump of a buffer to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2<br>
	 * Original signature : <code>void av_hex_dump(FILE*, uint8_t*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8581</i>
	 */
	void av_hex_dump(PointerByReference f, Pointer buf, int size);
	/**
	 * Send a nice hexadecimal dump of a buffer to the log.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2<br>
	 * Original signature : <code>void av_hex_dump_log(void*, int, uint8_t*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8593</i><br>
	 * @deprecated use the safer methods {@link #av_hex_dump_log(com.sun.jna.Pointer, int, java.nio.ByteBuffer, int)} and {@link #av_hex_dump_log(com.sun.jna.Pointer, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void av_hex_dump_log(Pointer avcl, int level, Pointer buf, int size);
	/**
	 * Send a nice hexadecimal dump of a buffer to the log.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param buf buffer<br>
	 * @param size buffer size<br>
	 * * @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2<br>
	 * Original signature : <code>void av_hex_dump_log(void*, int, uint8_t*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8593</i>
	 */
	void av_hex_dump_log(Pointer avcl, int level, ByteBuffer buf, int size);
	/**
	 * Send a nice dump of a packet to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param pkt packet to dump<br>
	 * @param dump_payload True if the payload must be displayed, too.<br>
	 * @param st AVStream that the packet belongs to<br>
	 * Original signature : <code>void av_pkt_dump2(FILE*, AVPacket*, int, AVStream*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8602</i><br>
	 * @deprecated use the safer method {@link #av_pkt_dump2(com.sun.jna.ptr.PointerByReference, acuitus.wrapffmpeg.AVPacket, int, acuitus.wrapffmpeg.AVStream)} instead
	 */
	@Deprecated 
	void av_pkt_dump2(Pointer f, AVPacket pkt, int dump_payload, AVStream st);
	/**
	 * Send a nice dump of a packet to the specified file stream.<br>
	 * * @param f The file stream pointer where the dump should be sent to.<br>
	 * @param pkt packet to dump<br>
	 * @param dump_payload True if the payload must be displayed, too.<br>
	 * @param st AVStream that the packet belongs to<br>
	 * Original signature : <code>void av_pkt_dump2(FILE*, AVPacket*, int, AVStream*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8602</i>
	 */
	void av_pkt_dump2(PointerByReference f, AVPacket pkt, int dump_payload, AVStream st);
	/**
	 * Send a nice dump of a packet to the log.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param pkt packet to dump<br>
	 * @param dump_payload True if the payload must be displayed, too.<br>
	 * @param st AVStream that the packet belongs to<br>
	 * Original signature : <code>void av_pkt_dump_log2(void*, int, AVPacket*, int, AVStream*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8614</i>
	 */
	void av_pkt_dump_log2(Pointer avcl, int level, AVPacket pkt, int dump_payload, AVStream st);
	/**
	 * Get the CodecID for the given codec tag tag.<br>
	 * If no codec id is found returns CODEC_ID_NONE.<br>
	 * * @param tags list of supported codec_id-codec_tag pairs, as stored<br>
	 * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag<br>
	 * Original signature : <code>CodecID av_codec_get_id(const AVCodecTag**, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8622</i><br>
	 * @deprecated use the safer method {@link #av_codec_get_id(acuitus.wrapffmpeg.AvformatLibrary.AVCodecTag[], int)} instead
	 */
	@Deprecated 
	int av_codec_get_id(PointerByReference tags, int tag);
	/**
	 * Get the CodecID for the given codec tag tag.<br>
	 * If no codec id is found returns CODEC_ID_NONE.<br>
	 * * @param tags list of supported codec_id-codec_tag pairs, as stored<br>
	 * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag<br>
	 * Original signature : <code>CodecID av_codec_get_id(const AVCodecTag**, unsigned int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8622</i>
	 */
	int av_codec_get_id(AvformatLibrary.AVCodecTag tags[], int tag);
	/**
	 * Get the codec tag for the given codec id id.<br>
	 * If no codec tag is found returns 0.<br>
	 * * @param tags list of supported codec_id-codec_tag pairs, as stored<br>
	 * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag<br>
	 * Original signature : <code>int av_codec_get_tag(const AVCodecTag**, CodecID)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8630</i><br>
	 * @deprecated use the safer method {@link #av_codec_get_tag(acuitus.wrapffmpeg.AvformatLibrary.AVCodecTag[], int)} instead
	 */
	@Deprecated 
	int av_codec_get_tag(PointerByReference tags, int id);
	/**
	 * Get the codec tag for the given codec id id.<br>
	 * If no codec tag is found returns 0.<br>
	 * * @param tags list of supported codec_id-codec_tag pairs, as stored<br>
	 * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag<br>
	 * Original signature : <code>int av_codec_get_tag(const AVCodecTag**, CodecID)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8630</i>
	 */
	int av_codec_get_tag(AvformatLibrary.AVCodecTag tags[], int id);
	/**
	 * Original signature : <code>int av_find_default_stream_index(AVFormatContext*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8632</i>
	 */
	int av_find_default_stream_index(AVFormatContext s);
	/**
	 * Get the index for a specific timestamp.<br>
	 * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond<br>
	 *                 to the timestamp which is <= the requested one, if backward<br>
	 *                 is 0, then it will be >=<br>
	 *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise<br>
	 * @return < 0 if no such timestamp could be found<br>
	 * Original signature : <code>int av_index_search_timestamp(AVStream*, int64_t, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8642</i>
	 */
	int av_index_search_timestamp(AVStream st, long timestamp, int flags);
	/**
	 * Add an index entry into a sorted list. Update the entry if the list<br>
	 * already contains it.<br>
	 * * @param timestamp timestamp in the time base of the given stream<br>
	 * Original signature : <code>int av_add_index_entry(AVStream*, int64_t, int64_t, int, int, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8649</i>
	 */
	int av_add_index_entry(AVStream st, long pos, long timestamp, int size, int distance, int flags);
	/**
	 * Split a URL string into components.<br>
	 * * The pointers to buffers for storing individual components may be null,<br>
	 * in order to ignore that component. Buffers for components not found are<br>
	 * set to empty strings. If the port is not found, it is set to a negative<br>
	 * value.<br>
	 * * @param proto the buffer for the protocol<br>
	 * @param proto_size the size of the proto buffer<br>
	 * @param authorization the buffer for the authorization<br>
	 * @param authorization_size the size of the authorization buffer<br>
	 * @param hostname the buffer for the host name<br>
	 * @param hostname_size the size of the hostname buffer<br>
	 * @param port_ptr a pointer to store the port number in<br>
	 * @param path the buffer for the path<br>
	 * @param path_size the size of the path buffer<br>
	 * @param url the URL to split<br>
	 * Original signature : <code>void av_url_split(char*, int, char*, int, char*, int, int*, char*, int, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8668</i><br>
	 * @deprecated use the safer methods {@link #av_url_split(java.nio.ByteBuffer, int, java.nio.ByteBuffer, int, java.nio.ByteBuffer, int, java.nio.IntBuffer, java.nio.ByteBuffer, int, java.lang.String)} and {@link #av_url_split(com.sun.jna.Pointer, int, com.sun.jna.Pointer, int, com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void av_url_split(Pointer proto, int proto_size, Pointer authorization, int authorization_size, Pointer hostname, int hostname_size, IntByReference port_ptr, Pointer path, int path_size, Pointer url);
	/**
	 * Split a URL string into components.<br>
	 * * The pointers to buffers for storing individual components may be null,<br>
	 * in order to ignore that component. Buffers for components not found are<br>
	 * set to empty strings. If the port is not found, it is set to a negative<br>
	 * value.<br>
	 * * @param proto the buffer for the protocol<br>
	 * @param proto_size the size of the proto buffer<br>
	 * @param authorization the buffer for the authorization<br>
	 * @param authorization_size the size of the authorization buffer<br>
	 * @param hostname the buffer for the host name<br>
	 * @param hostname_size the size of the hostname buffer<br>
	 * @param port_ptr a pointer to store the port number in<br>
	 * @param path the buffer for the path<br>
	 * @param path_size the size of the path buffer<br>
	 * @param url the URL to split<br>
	 * Original signature : <code>void av_url_split(char*, int, char*, int, char*, int, int*, char*, int, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8668</i>
	 */
	void av_url_split(ByteBuffer proto, int proto_size, ByteBuffer authorization, int authorization_size, ByteBuffer hostname, int hostname_size, IntBuffer port_ptr, ByteBuffer path, int path_size, String url);
	/**
	 * Original signature : <code>void dump_format(AVFormatContext*, int, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8670</i><br>
	 * @deprecated use the safer methods {@link #dump_format(acuitus.wrapffmpeg.AVFormatContext, int, java.lang.String, int)} and {@link #dump_format(acuitus.wrapffmpeg.AVFormatContext, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void dump_format(AVFormatContext ic, int index, Pointer url, int is_output);
	/**
	 * Original signature : <code>void dump_format(AVFormatContext*, int, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8670</i>
	 */
	void dump_format(AVFormatContext ic, int index, String url, int is_output);
	/**
	 * Original signature : <code>void av_dump_format(AVFormatContext*, int, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8672</i><br>
	 * @deprecated use the safer methods {@link #av_dump_format(acuitus.wrapffmpeg.AVFormatContext, int, java.lang.String, int)} and {@link #av_dump_format(acuitus.wrapffmpeg.AVFormatContext, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void av_dump_format(AVFormatContext ic, int index, Pointer url, int is_output);
	/**
	 * Original signature : <code>void av_dump_format(AVFormatContext*, int, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8672</i>
	 */
	void av_dump_format(AVFormatContext ic, int index, String url, int is_output);
	/**
	 * Original signature : <code>int64_t parse_date(const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8674</i><br>
	 * @deprecated use the safer methods {@link #parse_date(java.lang.String, int)} and {@link #parse_date(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	long parse_date(Pointer datestr, int duration);
	/**
	 * Original signature : <code>int64_t parse_date(const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8674</i>
	 */
	long parse_date(String datestr, int duration);
	/**
	 * Get the current time in microseconds.<br>
	 * Original signature : <code>int64_t av_gettime()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8679</i>
	 */
	long av_gettime();
	/**
	 * @deprecated use av_find_info_tag in libavutil instead.<br>
	 * Original signature : <code>int find_info_tag(char*, int, const char*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8684</i><br>
	 * @deprecated use the safer methods {@link #find_info_tag(java.nio.ByteBuffer, int, java.lang.String, java.lang.String)} and {@link #find_info_tag(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int find_info_tag(Pointer arg, int arg_size, Pointer tag1, Pointer info);
	/**
	 * @deprecated use av_find_info_tag in libavutil instead.<br>
	 * Original signature : <code>int find_info_tag(char*, int, const char*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8684</i>
	 */
	int find_info_tag(ByteBuffer arg, int arg_size, String tag1, String info);
	/**
	 * Return in 'buf' the path with '%d' replaced by a number.<br>
	 * * Also handles the '%0nd' format where 'n' is the total number<br>
	 * of digits and '%%'.<br>
	 * * @param buf destination buffer<br>
	 * @param buf_size destination buffer size<br>
	 * @param path numbered sequence string<br>
	 * @param number frame number<br>
	 * @return 0 if OK, -1 on format error<br>
	 * Original signature : <code>int av_get_frame_filename(char*, int, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8696</i><br>
	 * @deprecated use the safer methods {@link #av_get_frame_filename(java.nio.ByteBuffer, int, java.lang.String, int)} and {@link #av_get_frame_filename(com.sun.jna.Pointer, int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_get_frame_filename(Pointer buf, int buf_size, Pointer path, int number);
	/**
	 * Return in 'buf' the path with '%d' replaced by a number.<br>
	 * * Also handles the '%0nd' format where 'n' is the total number<br>
	 * of digits and '%%'.<br>
	 * * @param buf destination buffer<br>
	 * @param buf_size destination buffer size<br>
	 * @param path numbered sequence string<br>
	 * @param number frame number<br>
	 * @return 0 if OK, -1 on format error<br>
	 * Original signature : <code>int av_get_frame_filename(char*, int, const char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8696</i>
	 */
	int av_get_frame_filename(ByteBuffer buf, int buf_size, String path, int number);
	/**
	 * Check whether filename actually is a numbered sequence generator.<br>
	 * * @param filename possible numbered sequence string<br>
	 * @return 1 if a valid numbered sequence string, 0 otherwise<br>
	 * Original signature : <code>int av_filename_number_test(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8703</i><br>
	 * @deprecated use the safer methods {@link #av_filename_number_test(java.lang.String)} and {@link #av_filename_number_test(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_filename_number_test(Pointer filename);
	/**
	 * Check whether filename actually is a numbered sequence generator.<br>
	 * * @param filename possible numbered sequence string<br>
	 * @return 1 if a valid numbered sequence string, 0 otherwise<br>
	 * Original signature : <code>int av_filename_number_test(const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8703</i>
	 */
	int av_filename_number_test(String filename);
	/**
	 * Generate an SDP for an RTP session.<br>
	 * * @param ac array of AVFormatContexts describing the RTP streams. If the<br>
	 *           array is composed by only one context, such context can contain<br>
	 *           multiple AVStreams (one AVStream per RTP stream). Otherwise,<br>
	 *           all the contexts in the array (an AVCodecContext per RTP stream)<br>
	 *           must contain only one AVStream.<br>
	 * @param n_files number of AVCodecContexts contained in ac<br>
	 * @param buf buffer where the SDP will be stored (must be allocated by<br>
	 *            the caller)<br>
	 * @param size the size of the buffer<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8718</i><br>
	 * @deprecated use the safer methods {@link #av_sdp_create(acuitus.wrapffmpeg.AVFormatContext.ByReference[], int, java.nio.ByteBuffer, int)} and {@link #av_sdp_create(acuitus.wrapffmpeg.AVFormatContext.ByReference[], int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_sdp_create(PointerByReference ac, int n_files, Pointer buf, int size);
	/**
	 * Generate an SDP for an RTP session.<br>
	 * * @param ac array of AVFormatContexts describing the RTP streams. If the<br>
	 *           array is composed by only one context, such context can contain<br>
	 *           multiple AVStreams (one AVStream per RTP stream). Otherwise,<br>
	 *           all the contexts in the array (an AVCodecContext per RTP stream)<br>
	 *           must contain only one AVStream.<br>
	 * @param n_files number of AVCodecContexts contained in ac<br>
	 * @param buf buffer where the SDP will be stored (must be allocated by<br>
	 *            the caller)<br>
	 * @param size the size of the buffer<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8718</i>
	 */
	int av_sdp_create(AVFormatContext.ByReference ac[], int n_files, ByteBuffer buf, int size);
	/**
	 * Generate an SDP for an RTP session.<br>
	 * * @param ac array of AVFormatContexts describing the RTP streams. If the<br>
	 *           array is composed by only one context, such context can contain<br>
	 *           multiple AVStreams (one AVStream per RTP stream). Otherwise,<br>
	 *           all the contexts in the array (an AVCodecContext per RTP stream)<br>
	 *           must contain only one AVStream.<br>
	 * @param n_files number of AVCodecContexts contained in ac<br>
	 * @param buf buffer where the SDP will be stored (must be allocated by<br>
	 *            the caller)<br>
	 * @param size the size of the buffer<br>
	 * @return 0 if OK, AVERROR_xxx on error<br>
	 * Original signature : <code>int av_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8718</i>
	 */
	int av_sdp_create(AVFormatContext.ByReference ac[], int n_files, Pointer buf, int size);
	/**
	 * Original signature : <code>int avf_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8720</i><br>
	 * @deprecated use the safer methods {@link #avf_sdp_create(acuitus.wrapffmpeg.AVFormatContext.ByReference[], int, java.nio.ByteBuffer, int)} and {@link #avf_sdp_create(acuitus.wrapffmpeg.AVFormatContext.ByReference[], int, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int avf_sdp_create(PointerByReference ac, int n_files, Pointer buff, int size);
	/**
	 * Original signature : <code>int avf_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8720</i>
	 */
	int avf_sdp_create(AVFormatContext.ByReference ac[], int n_files, ByteBuffer buff, int size);
	/**
	 * Original signature : <code>int avf_sdp_create(AVFormatContext*[], int, char*, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8720</i>
	 */
	int avf_sdp_create(AVFormatContext.ByReference ac[], int n_files, Pointer buff, int size);
	/**
	 * Return a positive value if the given filename has one of the given<br>
	 * extensions, 0 otherwise.<br>
	 * * @param extensions a comma-separated list of filename extensions<br>
	 * Original signature : <code>int av_match_ext(const char*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8727</i><br>
	 * @deprecated use the safer methods {@link #av_match_ext(java.lang.String, java.lang.String)} and {@link #av_match_ext(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_match_ext(Pointer filename, Pointer extensions);
	/**
	 * Return a positive value if the given filename has one of the given<br>
	 * extensions, 0 otherwise.<br>
	 * * @param extensions a comma-separated list of filename extensions<br>
	 * Original signature : <code>int av_match_ext(const char*, const char*)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8727</i>
	 */
	int av_match_ext(String filename, String extensions);
	/**
	 * Test if the given container can store a codec.<br>
	 * * @param std_compliance standards compliance level, one of FF_COMPLIANCE_*<br>
	 * * @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.<br>
	 *         A negative number if this information is not available.<br>
	 * Original signature : <code>int avformat_query_codec(AVOutputFormat*, CodecID, int)</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8735</i>
	 */
	int avformat_query_codec(AVOutputFormat ofmt, int codec_id, int std_compliance);
	/**
	 * @return the table mapping RIFF FourCCs for video to libavcodec CodecID.<br>
	 * Original signature : <code>AVCodecTag* avformat_get_riff_video_tags()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8740</i>
	 */
	AvformatLibrary.AVCodecTag avformat_get_riff_video_tags();
	/**
	 * @return the table mapping RIFF FourCCs for audio to CodecID.<br>
	 * Original signature : <code>AVCodecTag* avformat_get_riff_audio_tags()</code><br>
	 * <i>native declaration : /usr/include/libavformat/avformat.h:8745</i>
	 */
	AvformatLibrary.AVCodecTag avformat_get_riff_audio_tags();
	public static final GlobalCallback<URLInterruptCB > url_interrupt_cb = new GlobalCallback<URLInterruptCB >(AvformatLibrary.JNA_NATIVE_LIB, URLInterruptCB.class, "url_interrupt_cb");
	public static class AVMetadataConv extends PointerType {
		public AVMetadataConv(Pointer address) {
			super(address);
		}
		public AVMetadataConv() {
			super();
		}
	};
	public static class AVCodecTag extends PointerType {
		public AVCodecTag(Pointer address) {
			super(address);
		}
		public AVCodecTag() {
			super();
		}
	};
	public static class FILE extends PointerType {
		public FILE(Pointer address) {
			super(address);
		}
		public FILE() {
			super();
		}
	};
}
