package wrapffmpeg;
import com.ochafik.lang.jnaerator.runtime.NativeSize;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
/**
 * JNA Wrapper for library <b>avutil</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface AvutilLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "avutil";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(AvutilLibrary.JNA_LIBRARY_NAME);
	public static final AvutilLibrary INSTANCE = (AvutilLibrary)Native.loadLibrary(AvutilLibrary.JNA_LIBRARY_NAME, AvutilLibrary.class);
	/**
	 * <i>native declaration : libavutil/avutil.h:26</i><br>
	 * enum values
	 */
	public static interface AVMediaType {
		/**
		 * < Usually treated as AVMEDIA_TYPE_DATA<br>
		 * <i>native declaration : libavutil/avutil.h:17</i>
		 */
		public static final int AVMEDIA_TYPE_UNKNOWN = -1;
		/** <i>native declaration : libavutil/avutil.h:18</i> */
		public static final int AVMEDIA_TYPE_VIDEO = 0;
		/** <i>native declaration : libavutil/avutil.h:19</i> */
		public static final int AVMEDIA_TYPE_AUDIO = 1;
		/**
		 * < Opaque data information usually continuous<br>
		 * <i>native declaration : libavutil/avutil.h:21</i>
		 */
		public static final int AVMEDIA_TYPE_DATA = 2;
		/** <i>native declaration : libavutil/avutil.h:22</i> */
		public static final int AVMEDIA_TYPE_SUBTITLE = 3;
		/**
		 * < Opaque data information usually sparse<br>
		 * <i>native declaration : libavutil/avutil.h:24</i>
		 */
		public static final int AVMEDIA_TYPE_ATTACHMENT = 4;
		/** <i>native declaration : libavutil/avutil.h:25</i> */
		public static final int AVMEDIA_TYPE_NB = 5;
	};
	/**
	 * <i>native declaration : libavutil/avutil.h:50</i><br>
	 * enum values
	 */
	public static interface AVPictureType {
		/**
		 * < Undefined<br>
		 * <i>native declaration : libavutil/avutil.h:35</i>
		 */
		public static final int AV_PICTURE_TYPE_NONE = 0;
		/**
		 * < Intra<br>
		 * <i>native declaration : libavutil/avutil.h:37</i>
		 */
		public static final int AV_PICTURE_TYPE_I = 1;
		/**
		 * < Predicted<br>
		 * <i>native declaration : libavutil/avutil.h:39</i>
		 */
		public static final int AV_PICTURE_TYPE_P = 2;
		/**
		 * < Bi-dir predicted<br>
		 * <i>native declaration : libavutil/avutil.h:41</i>
		 */
		public static final int AV_PICTURE_TYPE_B = 3;
		/**
		 * < S(GMC)-VOP MPEG4<br>
		 * <i>native declaration : libavutil/avutil.h:43</i>
		 */
		public static final int AV_PICTURE_TYPE_S = 4;
		/**
		 * < Switching Intra<br>
		 * <i>native declaration : libavutil/avutil.h:45</i>
		 */
		public static final int AV_PICTURE_TYPE_SI = 5;
		/**
		 * < Switching Predicted<br>
		 * <i>native declaration : libavutil/avutil.h:47</i>
		 */
		public static final int AV_PICTURE_TYPE_SP = 6;
		/**
		 * < BI type<br>
		 * <i>native declaration : libavutil/avutil.h:49</i>
		 */
		public static final int AV_PICTURE_TYPE_BI = 7;
	};
	/**
	 * <i>native declaration : libavutil/mathematics.h:13</i><br>
	 * enum values
	 */
	public static interface AVRounding {
		/**
		 * < Round toward zero.<br>
		 * <i>native declaration : libavutil/mathematics.h:2</i>
		 */
		public static final int AV_ROUND_ZERO = 0;
		/**
		 * < Round away from zero.<br>
		 * <i>native declaration : libavutil/mathematics.h:4</i>
		 */
		public static final int AV_ROUND_INF = 1;
		/**
		 * < Round toward -infinity.<br>
		 * <i>native declaration : libavutil/mathematics.h:6</i>
		 */
		public static final int AV_ROUND_DOWN = 2;
		/**
		 * < Round toward +infinity.<br>
		 * <i>native declaration : libavutil/mathematics.h:8</i>
		 */
		public static final int AV_ROUND_UP = 3;
		/**
		 * < Round to nearest and halfway cases away from zero.<br>
		 * <i>native declaration : libavutil/mathematics.h:10</i>
		 */
		public static final int AV_ROUND_NEAR_INF = 5;
		/**
		 * < Flag to pass INT64_MIN/MAX through instead of rescaling, this avoids special cases for AV_NOPTS_VALUE<br>
		 * <i>native declaration : libavutil/mathematics.h:12</i>
		 */
		public static final int AV_ROUND_PASS_MINMAX = 8192;
	};
	/**
	 * <i>native declaration : libavutil/log.h:13</i><br>
	 * enum values
	 */
	public static interface AVClassCategory {
		/** <i>native declaration : libavutil/log.h:1</i> */
		public static final int AV_CLASS_CATEGORY_NA = 0;
		/** <i>native declaration : libavutil/log.h:2</i> */
		public static final int AV_CLASS_CATEGORY_INPUT = 1;
		/** <i>native declaration : libavutil/log.h:3</i> */
		public static final int AV_CLASS_CATEGORY_OUTPUT = 2;
		/** <i>native declaration : libavutil/log.h:4</i> */
		public static final int AV_CLASS_CATEGORY_MUXER = 3;
		/** <i>native declaration : libavutil/log.h:5</i> */
		public static final int AV_CLASS_CATEGORY_DEMUXER = 4;
		/** <i>native declaration : libavutil/log.h:6</i> */
		public static final int AV_CLASS_CATEGORY_ENCODER = 5;
		/** <i>native declaration : libavutil/log.h:7</i> */
		public static final int AV_CLASS_CATEGORY_DECODER = 6;
		/** <i>native declaration : libavutil/log.h:8</i> */
		public static final int AV_CLASS_CATEGORY_FILTER = 7;
		/** <i>native declaration : libavutil/log.h:9</i> */
		public static final int AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8;
		/** <i>native declaration : libavutil/log.h:10</i> */
		public static final int AV_CLASS_CATEGORY_SWSCALER = 9;
		/** <i>native declaration : libavutil/log.h:11</i> */
		public static final int AV_CLASS_CATEGORY_SWRESAMPLER = 10;
		/** <i>native declaration : libavutil/log.h:12</i> */
		public static final int AV_CLASS_CATEGORY_NB = 11;
	};
	/**
	 * Audio Sample Formats<br>
	 * * @par<br>
	 * The data described by the sample format is always in native-endian order.<br>
	 * Sample values can be expressed by native C types, hence the lack of a signed<br>
	 * 24-bit sample format even though it is a common raw audio data format.<br>
	 * * @par<br>
	 * The floating-point formats are based on full volume being in the range<br>
	 * [-1.0, 1.0]. Any values outside this range are beyond full volume level.<br>
	 * * @par<br>
	 * The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg<br>
	 * (such as AVFrame in libavcodec) is as follows:<br>
	 * * For planar sample formats, each audio channel is in a separate data plane,<br>
	 * and linesize is the buffer size, in bytes, for a single plane. All data<br>
	 * planes must be the same size. For packed sample formats, only the first data<br>
	 * plane is used, and samples for each channel are interleaved. In this case,<br>
	 * linesize is the buffer size, in bytes, for the 1 plane.<br>
	 * <i>native declaration : libavutil/samplefmt.h:42</i><br>
	 * enum values
	 */
	public static interface AVSampleFormat {
		/** <i>native declaration : libavutil/samplefmt.h:19</i> */
		public static final int AV_SAMPLE_FMT_NONE = -1;
		/**
		 * < unsigned 8 bits<br>
		 * <i>native declaration : libavutil/samplefmt.h:21</i>
		 */
		public static final int AV_SAMPLE_FMT_U8 = 0;
		/**
		 * < signed 16 bits<br>
		 * <i>native declaration : libavutil/samplefmt.h:23</i>
		 */
		public static final int AV_SAMPLE_FMT_S16 = 1;
		/**
		 * < signed 32 bits<br>
		 * <i>native declaration : libavutil/samplefmt.h:25</i>
		 */
		public static final int AV_SAMPLE_FMT_S32 = 2;
		/**
		 * < float<br>
		 * <i>native declaration : libavutil/samplefmt.h:27</i>
		 */
		public static final int AV_SAMPLE_FMT_FLT = 3;
		/**
		 * < double<br>
		 * <i>native declaration : libavutil/samplefmt.h:29</i>
		 */
		public static final int AV_SAMPLE_FMT_DBL = 4;
		/**
		 * < unsigned 8 bits, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:31</i>
		 */
		public static final int AV_SAMPLE_FMT_U8P = 5;
		/**
		 * < signed 16 bits, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:33</i>
		 */
		public static final int AV_SAMPLE_FMT_S16P = 6;
		/**
		 * < signed 32 bits, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:35</i>
		 */
		public static final int AV_SAMPLE_FMT_S32P = 7;
		/**
		 * < float, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:37</i>
		 */
		public static final int AV_SAMPLE_FMT_FLTP = 8;
		/**
		 * < double, planar<br>
		 * <i>native declaration : libavutil/samplefmt.h:39</i>
		 */
		public static final int AV_SAMPLE_FMT_DBLP = 9;
		/**
		 * < Number of sample formats. DO NOT USE if linking dynamically<br>
		 * <i>native declaration : libavutil/samplefmt.h:41</i>
		 */
		public static final int AV_SAMPLE_FMT_NB = 10;
	};
	/**
	 * <i>native declaration : libavutil/channel_layout.h:5</i><br>
	 * enum values
	 */
	public static interface AVMatrixEncoding {
		/** <i>native declaration : libavutil/channel_layout.h:1</i> */
		public static final int AV_MATRIX_ENCODING_NONE = 0;
		/** <i>native declaration : libavutil/channel_layout.h:2</i> */
		public static final int AV_MATRIX_ENCODING_DOLBY = 1;
		/** <i>native declaration : libavutil/channel_layout.h:3</i> */
		public static final int AV_MATRIX_ENCODING_DPLII = 2;
		/** <i>native declaration : libavutil/channel_layout.h:4</i> */
		public static final int AV_MATRIX_ENCODING_NB = 3;
	};
	/**
	 * <i>native declaration : libavutil/frame.h:15</i><br>
	 * enum values
	 */
	public static interface AVColorSpace {
		/** <i>native declaration : libavutil/frame.h:1</i> */
		public static final int AVCOL_SPC_RGB = 0;
		/**
		 * < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B<br>
		 * <i>native declaration : libavutil/frame.h:3</i>
		 */
		public static final int AVCOL_SPC_BT709 = 1;
		/** <i>native declaration : libavutil/frame.h:4</i> */
		public static final int AVCOL_SPC_UNSPECIFIED = 2;
		/** <i>native declaration : libavutil/frame.h:5</i> */
		public static final int AVCOL_SPC_FCC = 4;
		/**
		 * < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601<br>
		 * <i>native declaration : libavutil/frame.h:7</i>
		 */
		public static final int AVCOL_SPC_BT470BG = 5;
		/**
		 * < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above<br>
		 * <i>native declaration : libavutil/frame.h:9</i>
		 */
		public static final int AVCOL_SPC_SMPTE170M = 6;
		/** <i>native declaration : libavutil/frame.h:10</i> */
		public static final int AVCOL_SPC_SMPTE240M = 7;
		/**
		 * < Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16<br>
		 * <i>native declaration : libavutil/frame.h:12</i>
		 */
		public static final int AVCOL_SPC_YCOCG = 8;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil/frame.h:14</i>
		 */
		public static final int AVCOL_SPC_NB = 9;
	};
	/**
	 * <i>native declaration : libavutil/frame.h:24</i><br>
	 * enum values
	 */
	public static interface AVColorRange {
		/** <i>native declaration : libavutil/frame.h:17</i> */
		public static final int AVCOL_RANGE_UNSPECIFIED = 0;
		/**
		 * < the normal 219*2^(n-8) "MPEG" YUV ranges<br>
		 * <i>native declaration : libavutil/frame.h:19</i>
		 */
		public static final int AVCOL_RANGE_MPEG = 1;
		/**
		 * < the normal     2^n-1   "JPEG" YUV ranges<br>
		 * <i>native declaration : libavutil/frame.h:21</i>
		 */
		public static final int AVCOL_RANGE_JPEG = 2;
		/**
		 * < Not part of ABI<br>
		 * <i>native declaration : libavutil/frame.h:23</i>
		 */
		public static final int AVCOL_RANGE_NB = 3;
	};
	/**
	 * <i>native declaration : libavutil/frame.h:28</i><br>
	 * enum values
	 */
	public static interface AVFrameSideDataType {
		/**
		 * The data is the AVPanScan struct defined in libavcodec.<br>
		 * <i>native declaration : libavutil/frame.h:27</i>
		 */
		public static final int AV_FRAME_DATA_PANSCAN = 0;
	};
	/**
	 * Conversion Error : a.num<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil/rational.h:16</i><br>
	 * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
	 */
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_CONTEXT_SIZE = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_SAMPLES_UTILS_RETURN_ZERO = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_OPTION_NOT_FOUND = (int)(-((0xF8) | (('O') << 8) | (('P') << 16) | (('T') << 24)));
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT0_FRONT = (int)(((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_STEREO = (int)(0x00000001 | 0x00000002);
	/** <i>native declaration : libavutil/pixfmt.h</i> */
	public static final int AVPALETTE_SIZE = (int)1024;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_FRONT_CENTER = (int)0x00000004;
	/** <i>native declaration : libavutil/mathematics.h</i> */
	public static final double M_LOG2_10 = (double)3.32192809488736234787;
	/** <i>native declaration : libavutil/frame.h</i> */
	public static final int FF_DECODE_ERROR_INVALID_BITSTREAM = (int)1;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_SIDE_RIGHT = (int)0x00000400;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_AVX = (int)0x4000;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AV_ERROR_MAX_STRING_SIZE = (int)64;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final long AV_CH_WIDE_LEFT = (long)0x0000000080000000L;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_FRONT_LEFT = (int)0x00000001;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final long AV_CH_WIDE_RIGHT = (long)0x0000000100000000L;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_CPU_FLAG_MMX2 = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSSE3 = (int)0x0080;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_MMX = (int)0x0001;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final long AV_CH_SURROUND_DIRECT_LEFT = (long)0x0000000200000000L;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_NEON = (int)(1 << 5);
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_SKIP_REPEATED = (int)1;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_AUDIOCONVERT = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_FRONT_RIGHT_OF_CENTER = (int)0x00000080;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000100);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000100);
	/** <i>native declaration : libavutil/avconfig.h</i> */
	public static final int AV_HAVE_FAST_UNALIGNED = (int)1;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_EOF = (int)(-(('E') | (('O') << 8) | (('F') << 16) | ((' ') << 24)));
	/** <i>native declaration : libavutil/mathematics.h</i> */
	public static final double M_PHI = (double)1.61803398874989484820;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_STEREO_DOWNMIX = (int)(0x20000000 | 0x40000000);
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_ARMV5TE = (int)(1 << 0);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1_WIDE = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000040 | 0x00000080);
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_MAX_OFFSET = (int)(48 - -8);
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_WARNING = (int)24;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE2SLOW = (int)0x40000000;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_PROTOCOL_NOT_FOUND = (int)(-((0xF8) | (('P') << 8) | (('R') << 16) | (('O') << 24)));
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_TOP_FRONT_CENTER = (int)0x00002000;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT0_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_STEREO_RIGHT = (int)0x40000000;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE3SLOW = (int)0x20000000;
	/** <i>native declaration : libavutil/avutil.h</i> */
	public static final int FF_QUALITY_SCALE = (int)(1 << 7);
	/** <i>native declaration : libavutil/avutil.h</i> */
	public static final long AV_NOPTS_VALUE = (long)0x8000000000000000L;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_TOP_FRONT_RIGHT = (int)0x00004000;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_DECODER_NOT_FOUND = (int)(-((0xF8) | (('D') << 8) | (('E') << 16) | (('C') << 24)));
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_QUIET = (int)-8;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_VFPV3 = (int)(1 << 4);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_4POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_MAJOR = (int)52;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_4POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100) | 0x00000008);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_FRONT_LEFT_OF_CENTER = (int)0x00000040;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_VFP = (int)(1 << 3);
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_UNKNOWN = (int)(-(('U') | (('N') << 8) | (('K') << 16) | (('N') << 24)));
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_BUG2 = (int)(-(('B') | (('U') << 8) | (('G') << 16) | ((' ') << 24)));
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_PIX_FMT = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/avutil.h</i> */
	public static final int FF_QP2LAMBDA = (int)118;
	/** <i>native declaration : libavutil/avconfig.h</i> */
	public static final int AV_HAVE_INCOMPATIBLE_LIBAV_ABI = (int)0;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LOW_FREQUENCY = (int)0x00000008;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_EXIT = (int)(-(('E') | (('X') << 8) | (('I') << 16) | (('T') << 24)));
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_2POINT1 = (int)((0x00000001 | 0x00000002) | 0x00000008);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_TOP_FRONT_LEFT = (int)0x00001000;
	/** <i>native declaration : libavutil/frame.h</i> */
	public static final int FF_DECODE_ERROR_MISSING_REFERENCE = (int)2;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_PATCHWELCOME = (int)(-(('P') | (('A') << 8) | (('W') << 16) | (('E') << 24)));
	/** <i>native declaration : libavutil/pixfmt.h</i> */
	public static final int AVPALETTE_COUNT = (int)256;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_TOP_BACK_RIGHT = (int)0x00020000;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_FMA4 = (int)0x0800;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_PIX_FMT_DESC = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_FRONT_RIGHT = (int)0x00000002;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_TOP_CENTER = (int)0x00000800;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_AVFRAME_LAVC = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_FORCE = (int)0x80000000;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE = (int)0x0008;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_VAL = (int)8;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_MINOR = (int)42;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final String LIBAVUTIL_IDENT = (String)"Lavu";
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1_WIDE_BACK = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008) | 0x00000040 | 0x00000080);
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_ENCODER_NOT_FOUND = (int)(-((0xF8) | (('E') << 8) | (('N') << 16) | (('C') << 24)));
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final long AV_CH_LOW_FREQUENCY_2 = (long)0x0000000800000000L;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_ALTIVEC = (int)0x0001;
	/** <i>native declaration : libavutil/avutil.h</i> */
	public static final int FF_LAMBDA_SHIFT = (int)7;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_FILTER_NOT_FOUND = (int)(-((0xF8) | (('F') << 8) | (('I') << 16) | (('L') << 24)));
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_OLD_AVOPTIONS = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_IGNORE_SUFFIX = (int)2;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final long AV_CH_SURROUND_DIRECT_RIGHT = (long)0x0000000400000000L;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_SIDE_LEFT = (int)0x00000200;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_APPEND = (int)32;
	/** <i>native declaration : libavutil/avutil.h</i> */
	public static final int FF_LAMBDA_MAX = (int)(256 * 128 - 1);
	/** <i>native declaration : libavutil/frame.h</i> */
	public static final int AV_NUM_DATA_POINTERS = (int)8;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_MMXEXT = (int)0x0002;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_TOP_BACK_LEFT = (int)0x00008000;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_ATOM = (int)0x10000000;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_MICRO = (int)100;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_BUG = (int)(-(('B') | (('U') << 8) | (('G') << 16) | (('!') << 24)));
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_STEREO_LEFT = (int)0x20000000;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_INVALIDDATA = (int)(-(('I') | (('N') << 8) | (('D') << 16) | (('A') << 24)));
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_PANIC = (int)0;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE2 = (int)0x0010;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_QUAD = (int)((0x00000001 | 0x00000002) | 0x00000010 | 0x00000020);
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_XOP = (int)0x0400;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE3 = (int)0x0040;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE4 = (int)0x0100;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_STRDUP_KEY = (int)4;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT1_BACK = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008);
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_DEBUG = (int)48;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_SURROUND = (int)((0x00000001 | 0x00000002) | 0x00000004);
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_VERBOSE = (int)40;
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_INFO = (int)32;
	/** <i>native declaration : libavutil/avutil.h</i> */
	public static final int AV_TIME_BASE = (int)1000000;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_MMX2 = (int)0x0002;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000010 | 0x00000020);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_7POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000020);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_BACK_RIGHT = (int)0x00000020;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_GET_BITS_PER_SAMPLE_FMT = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_CMOV = (int)0x1001000;
	/**
	 * define<br>
	 * Conversion Error : 52.42.<br>
	 * SKIPPED:<br>
	 * <i>native declaration : libavutil/version.h:0</i><br>
	 * 52.42.
	 */
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_STREAM_NOT_FOUND = (int)(-((0xF8) | (('S') << 8) | (('T') << 16) | (('R') << 24)));
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_OCTAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000100 | 0x00000020);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_BACK_CENTER = (int)0x00000100;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_VDPAU = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_2_1 = (int)((0x00000001 | 0x00000002) | 0x00000100);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_2_2 = (int)((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_3POINT1 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000008);
	/** <i>native declaration : libavutil/avconfig.h</i> */
	public static final int AV_HAVE_INCOMPATIBLE_FORK_ABI = (int)0;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_VERSION_INT = (int)(52 << 16 | 42 << 8 | 100);
	/** <i>native declaration : libavutil/avutil.h</i> */
	public static final int FF_LAMBDA_SCALE = (int)(1 << 7);
	/** <i>native declaration : libavutil/avconfig.h</i> */
	public static final int AV_HAVE_BIGENDIAN = (int)0;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_BACK_LEFT = (int)0x00000010;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final long AV_CH_LAYOUT_NATIVE = (long)0x8000000000000000L;
	/** <i>native declaration : libavutil/version.h</i> */
	public static final int LIBAVUTIL_BUILD = (int)(52 << 16 | 42 << 8 | 100);
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_MATCH_CASE = (int)1;
	/** <i>native declaration : libavutil/dict.h</i> */
	public static final int AV_DICT_DONT_OVERWRITE = (int)16;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_SSE42 = (int)0x0200;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1_BACK = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008) | 0x00000100);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_LLS_PRIVATE = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_MUXER_NOT_FOUND = (int)(-((0xF8) | (('M') << 8) | (('U') << 16) | (('X') << 24)));
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_EXTERNAL = (int)(-(('E') | (('X') << 8) | (('T') << 16) | ((' ') << 24)));
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_HEXAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000100);
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_DEMUXER_NOT_FOUND = (int)(-((0xF8) | (('D') << 8) | (('E') << 16) | (('M') << 24)));
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_3DNOW = (int)0x0004;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_MONO = (int)(0x00000004);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_AV_REVERSE = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_TOP_BACK_CENTER = (int)0x00010000;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_6POINT1_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080) | 0x00000008);
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_ARMV6T2 = (int)(1 << 2);
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_ARMV6 = (int)(1 << 1);
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_EXPERIMENTAL = (int)(0x2bb2afa8);
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_ERROR = (int)16;
	/** <i>native declaration : libavutil/channel_layout.h</i> */
	public static final int AV_CH_LAYOUT_5POINT0_BACK = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020);
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_BSF_NOT_FOUND = (int)(-((0xF8) | (('B') << 8) | (('S') << 16) | (('F') << 24)));
	/** <i>native declaration : libavutil/log.h</i> */
	public static final int AV_LOG_FATAL = (int)8;
	/** <i>native declaration : libavutil/cpu.h</i> */
	public static final int AV_CPU_FLAG_3DNOWEXT = (int)0x0020;
	/** <i>native declaration : libavutil/error.h</i> */
	public static final int AVERROR_BUFFER_TOO_SMALL = (int)(-(('B') | (('U') << 8) | (('F') << 16) | (('S') << 24)));
	/** <i>native declaration : libavutil/buffer.h</i> */
	public static final int AV_BUFFER_FLAG_READONLY = (int)(1 << 0);
	/** <i>native declaration : libavutil/version.h</i> */
	public static final boolean FF_API_FIND_OPT = (boolean)(52 < 53);
	/** <i>native declaration : libavutil/log.h:122</i> */
	public interface av_log_set_callback_arg1_callback extends Callback {
		void apply(Pointer voidPtr1, int int1, Pointer charPtr1, Pointer va_list1);
	};
	/** <i>native declaration : libavutil/buffer.h:142</i> */
	public interface av_buffer_create_free_callback extends Callback {
		void apply(Pointer opaque, Pointer data);
	};
	/** <i>native declaration : libavutil/buffer.h:143</i> */
	public interface av_buffer_pool_init_alloc_callback extends Callback {
		AVBufferRef apply(int size);
	};
	/**
	 * Return the LIBAVUTIL_VERSION_INT constant.<br>
	 * Original signature : <code>int avutil_version()</code><br>
	 * <i>native declaration : libavutil/avutil.h:4</i>
	 */
	int avutil_version();
	/**
	 * Return the libavutil build-time configuration.<br>
	 * Original signature : <code>char* avutil_configuration()</code><br>
	 * <i>native declaration : libavutil/avutil.h:9</i>
	 */
	String avutil_configuration();
	/**
	 * Return the libavutil license.<br>
	 * Original signature : <code>char* avutil_license()</code><br>
	 * <i>native declaration : libavutil/avutil.h:14</i>
	 */
	String avutil_license();
	/**
	 * Return a string describing the media_type enum, NULL if media_type<br>
	 * is unknown.<br>
	 * Original signature : <code>char* av_get_media_type_string(AVMediaType)</code><br>
	 * <i>native declaration : libavutil/avutil.h:32</i>
	 */
	String av_get_media_type_string(int media_type);
	/**
	 * Return a single letter to describe the given picture type<br>
	 * pict_type.<br>
	 * * @param[in] pict_type the picture type @return a single character<br>
	 * representing the picture type, '?' if pict_type is unknown<br>
	 * Original signature : <code>char av_get_picture_type_char(AVPictureType)</code><br>
	 * <i>native declaration : libavutil/avutil.h:58</i>
	 */
	byte av_get_picture_type_char(int pict_type);
	/**
	 * Original signature : <code>int av_log2(unsigned)</code><br>
	 * <i>native declaration : libavutil/common.h:1</i>
	 */
	int av_log2(int v);
	/**
	 * Original signature : <code>int av_log2_16bit(unsigned)</code><br>
	 * <i>native declaration : libavutil/common.h:3</i>
	 */
	int av_log2_16bit(int v);
	/**
	 * Put a description of the AVERROR code errnum in errbuf.<br>
	 * In case of failure the global variable errno is set to indicate the<br>
	 * error. Even in case of failure av_strerror() will print a generic<br>
	 * error message indicating the errnum provided to errbuf.<br>
	 * * @param errnum      error code to describe<br>
	 * @param errbuf      buffer to which description is written<br>
	 * @param errbuf_size the size in bytes of errbuf<br>
	 * @return 0 on success, a negative value if a description for errnum<br>
	 * cannot be found<br>
	 * Original signature : <code>int av_strerror(int, char*, size_t)</code><br>
	 * <i>native declaration : libavutil/error.h:12</i><br>
	 * @deprecated use the safer methods {@link #av_strerror(int, java.nio.ByteBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize)} and {@link #av_strerror(int, com.sun.jna.Pointer, com.ochafik.lang.jnaerator.runtime.NativeSize)} instead
	 */
	@Deprecated 
	int av_strerror(int errnum, Pointer errbuf, NativeSize errbuf_size);
	/**
	 * Put a description of the AVERROR code errnum in errbuf.<br>
	 * In case of failure the global variable errno is set to indicate the<br>
	 * error. Even in case of failure av_strerror() will print a generic<br>
	 * error message indicating the errnum provided to errbuf.<br>
	 * * @param errnum      error code to describe<br>
	 * @param errbuf      buffer to which description is written<br>
	 * @param errbuf_size the size in bytes of errbuf<br>
	 * @return 0 on success, a negative value if a description for errnum<br>
	 * cannot be found<br>
	 * Original signature : <code>int av_strerror(int, char*, size_t)</code><br>
	 * <i>native declaration : libavutil/error.h:12</i>
	 */
	int av_strerror(int errnum, ByteBuffer errbuf, NativeSize errbuf_size);
	/**
	 * Allocate a block of size bytes with alignment suitable for all<br>
	 * memory accesses (including vectors if available on the CPU).<br>
	 * @param size Size in bytes for the memory block to be allocated.<br>
	 * @return Pointer to the allocated block, NULL if the block cannot<br>
	 * be allocated.<br>
	 * @see av_mallocz()<br>
	 * Original signature : <code>void* av_malloc(size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:9</i>
	 */
	Pointer av_malloc(NativeSize size);
	/**
	 * Allocate or reallocate a block of memory.<br>
	 * If ptr is NULL and size > 0, allocate a new block. If<br>
	 * size is zero, free the memory block pointed to by ptr.<br>
	 * @param ptr Pointer to a memory block already allocated with<br>
	 * av_malloc(z)() or av_realloc() or NULL.<br>
	 * @param size Size in bytes for the memory block to be allocated or<br>
	 * reallocated.<br>
	 * @return Pointer to a newly reallocated block or NULL if the block<br>
	 * cannot be reallocated or the function is used to free the memory block.<br>
	 * @see av_fast_realloc()<br>
	 * Original signature : <code>void* av_realloc(void*, size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:38</i>
	 */
	Pointer av_realloc(Pointer ptr, NativeSize size);
	/**
	 * Allocate or reallocate a block of memory.<br>
	 * This function does the same thing as av_realloc, except:<br>
	 * - It takes two arguments and checks the result of the multiplication for<br>
	 *   integer overflow.<br>
	 * - It frees the input block in case of failure, thus avoiding the memory<br>
	 *   leak with the classic "buf = realloc(buf); if (!buf) return -1;".<br>
	 * Original signature : <code>void* av_realloc_f(void*, size_t, size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:48</i>
	 */
	Pointer av_realloc_f(Pointer ptr, NativeSize nelem, NativeSize elsize);
	/**
	 * Allocate or reallocate an array.<br>
	 * If ptr is NULL and nmemb > 0, allocate a new block. If<br>
	 * nmemb is zero, free the memory block pointed to by ptr.<br>
	 * @param ptr Pointer to a memory block already allocated with<br>
	 * av_malloc(z)() or av_realloc() or NULL.<br>
	 * @param nmemb Number of elements<br>
	 * @param size Size of the single element<br>
	 * @return Pointer to a newly reallocated block or NULL if the block<br>
	 * cannot be reallocated or the function is used to free the memory block.<br>
	 * Original signature : <code>void* av_realloc_array(void*, size_t, size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:61</i>
	 */
	Pointer av_realloc_array(Pointer ptr, NativeSize nmemb, NativeSize size);
	/**
	 * Allocate or reallocate an array.<br>
	 * If *ptr is NULL and nmemb > 0, allocate a new block. If<br>
	 * nmemb is zero, free the memory block pointed to by ptr.<br>
	 * @param ptr Pointer to a pointer to a memory block already allocated<br>
	 * with av_malloc(z)() or av_realloc(), or pointer to a pointer to NULL.<br>
	 * The pointer is updated on success, or freed on failure.<br>
	 * @param nmemb Number of elements<br>
	 * @param size Size of the single element<br>
	 * @return Zero on success, an AVERROR error code on failure.<br>
	 * Original signature : <code>int av_reallocp_array(void*, size_t, size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:74</i>
	 */
	int av_reallocp_array(Pointer ptr, NativeSize nmemb, NativeSize size);
	/**
	 * Free a memory block which has been allocated with av_malloc(z)() or<br>
	 * av_realloc().<br>
	 * @param ptr Pointer to the memory block which should be freed.<br>
	 * @note ptr = NULL is explicitly allowed.<br>
	 * @note It is recommended that you use av_freep() instead.<br>
	 * @see av_freep()<br>
	 * Original signature : <code>void av_free(void*)</code><br>
	 * <i>native declaration : libavutil/mem.h:84</i>
	 */
	void av_free(Pointer ptr);
	/**
	 * Allocate a block of size bytes with alignment suitable for all<br>
	 * memory accesses (including vectors if available on the CPU) and<br>
	 * zero all the bytes of the block.<br>
	 * @param size Size in bytes for the memory block to be allocated.<br>
	 * @return Pointer to the allocated block, NULL if it cannot be allocated.<br>
	 * @see av_malloc()<br>
	 * Original signature : <code>void* av_mallocz(size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:94</i>
	 */
	Pointer av_mallocz(NativeSize size);
	/**
	 * Allocate a block of nmemb * size bytes with alignment suitable for all<br>
	 * memory accesses (including vectors if available on the CPU) and<br>
	 * zero all the bytes of the block.<br>
	 * The allocation will fail if nmemb * size is greater than or equal<br>
	 * to INT_MAX.<br>
	 * @param nmemb<br>
	 * @param size<br>
	 * @return Pointer to the allocated block, NULL if it cannot be allocated.<br>
	 * Original signature : <code>void* av_calloc(size_t, size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:106</i>
	 */
	Pointer av_calloc(NativeSize nmemb, NativeSize size);
	/**
	 * Duplicate the string s.<br>
	 * @param s string to be duplicated<br>
	 * @return Pointer to a newly allocated string containing a<br>
	 * copy of s or NULL if the string cannot be allocated.<br>
	 * Original signature : <code>char* av_strdup(const char*)</code><br>
	 * <i>native declaration : libavutil/mem.h:130</i><br>
	 * @deprecated use the safer methods {@link #av_strdup(java.lang.String)} and {@link #av_strdup(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer av_strdup(Pointer s);
	/**
	 * Duplicate the string s.<br>
	 * @param s string to be duplicated<br>
	 * @return Pointer to a newly allocated string containing a<br>
	 * copy of s or NULL if the string cannot be allocated.<br>
	 * Original signature : <code>char* av_strdup(const char*)</code><br>
	 * <i>native declaration : libavutil/mem.h:130</i>
	 */
	Pointer av_strdup(String s);
	/**
	 * Duplicate the buffer p.<br>
	 * @param p buffer to be duplicated<br>
	 * @return Pointer to a newly allocated buffer containing a<br>
	 * copy of p or NULL if the buffer cannot be allocated.<br>
	 * Original signature : <code>void* av_memdup(const void*, size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:138</i>
	 */
	Pointer av_memdup(Pointer p, NativeSize size);
	/**
	 * Free a memory block which has been allocated with av_malloc(z)() or<br>
	 * av_realloc() and set the pointer pointing to it to NULL.<br>
	 * @param ptr Pointer to the pointer to the memory block which should<br>
	 * be freed.<br>
	 * @see av_free()<br>
	 * Original signature : <code>void av_freep(void*)</code><br>
	 * <i>native declaration : libavutil/mem.h:147</i>
	 */
	void av_freep(Pointer ptr);
	/**
	 * Add an element to a dynamic array.<br>
	 * * The array to grow is supposed to be an array of pointers to<br>
	 * structures, and the element to add must be a pointer to an already<br>
	 * allocated structure.<br>
	 * * The array is reallocated when its size reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by nb_ptr<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, *tab_ptr is set to NULL and<br>
	 * *nb_ptr is set to 0.<br>
	 * * @param tab_ptr pointer to the array to grow<br>
	 * @param nb_ptr  pointer to the number of elements in the array<br>
	 * @param elem    element to add<br>
	 * @see av_dynarray2_add()<br>
	 * Original signature : <code>void av_dynarray_add(void*, int*, void*)</code><br>
	 * <i>native declaration : libavutil/mem.h:166</i><br>
	 * @deprecated use the safer methods {@link #av_dynarray_add(com.sun.jna.Pointer, java.nio.IntBuffer, com.sun.jna.Pointer)} and {@link #av_dynarray_add(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void av_dynarray_add(Pointer tab_ptr, IntByReference nb_ptr, Pointer elem);
	/**
	 * Add an element to a dynamic array.<br>
	 * * The array to grow is supposed to be an array of pointers to<br>
	 * structures, and the element to add must be a pointer to an already<br>
	 * allocated structure.<br>
	 * * The array is reallocated when its size reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by nb_ptr<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, *tab_ptr is set to NULL and<br>
	 * *nb_ptr is set to 0.<br>
	 * * @param tab_ptr pointer to the array to grow<br>
	 * @param nb_ptr  pointer to the number of elements in the array<br>
	 * @param elem    element to add<br>
	 * @see av_dynarray2_add()<br>
	 * Original signature : <code>void av_dynarray_add(void*, int*, void*)</code><br>
	 * <i>native declaration : libavutil/mem.h:166</i>
	 */
	void av_dynarray_add(Pointer tab_ptr, IntBuffer nb_ptr, Pointer elem);
	/**
	 * Add an element of size elem_size to a dynamic array.<br>
	 * * The array is reallocated when its number of elements reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by nb_ptr<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, *tab_ptr is set to NULL and<br>
	 * *nb_ptr is set to 0.<br>
	 * * @param tab_ptr   pointer to the array to grow<br>
	 * @param nb_ptr    pointer to the number of elements in the array<br>
	 * @param elem_size size in bytes of the elements in the array<br>
	 * @param elem_data pointer to the data of the element to add. If NULL, the space of<br>
	 *                  the new added element is not filled.<br>
	 * @return          pointer to the data of the element to copy in the new allocated space.<br>
	 *                  If NULL, the new allocated space is left uninitialized."<br>
	 * @see av_dynarray_add()<br>
	 * Original signature : <code>void* av_dynarray2_add(void**, int*, size_t, const uint8_t*)</code><br>
	 * <i>native declaration : libavutil/mem.h:186</i><br>
	 * @deprecated use the safer methods {@link #av_dynarray2_add(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, com.ochafik.lang.jnaerator.runtime.NativeSize, java.nio.ByteBuffer)} and {@link #av_dynarray2_add(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.ochafik.lang.jnaerator.runtime.NativeSize, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer av_dynarray2_add(PointerByReference tab_ptr, IntByReference nb_ptr, NativeSize elem_size, Pointer elem_data);
	/**
	 * Add an element of size elem_size to a dynamic array.<br>
	 * * The array is reallocated when its number of elements reaches powers of 2.<br>
	 * Therefore, the amortized cost of adding an element is constant.<br>
	 * * In case of success, the pointer to the array is updated in order to<br>
	 * point to the new grown array, and the number pointed to by nb_ptr<br>
	 * is incremented.<br>
	 * In case of failure, the array is freed, *tab_ptr is set to NULL and<br>
	 * *nb_ptr is set to 0.<br>
	 * * @param tab_ptr   pointer to the array to grow<br>
	 * @param nb_ptr    pointer to the number of elements in the array<br>
	 * @param elem_size size in bytes of the elements in the array<br>
	 * @param elem_data pointer to the data of the element to add. If NULL, the space of<br>
	 *                  the new added element is not filled.<br>
	 * @return          pointer to the data of the element to copy in the new allocated space.<br>
	 *                  If NULL, the new allocated space is left uninitialized."<br>
	 * @see av_dynarray_add()<br>
	 * Original signature : <code>void* av_dynarray2_add(void**, int*, size_t, const uint8_t*)</code><br>
	 * <i>native declaration : libavutil/mem.h:186</i>
	 */
	Pointer av_dynarray2_add(PointerByReference tab_ptr, IntBuffer nb_ptr, NativeSize elem_size, ByteBuffer elem_data);
	/**
	 * Set the maximum size that may me allocated in one block.<br>
	 * Original signature : <code>void av_max_alloc(size_t)</code><br>
	 * <i>native declaration : libavutil/mem.h:203</i>
	 */
	void av_max_alloc(NativeSize max);
	/**
	 * @brief deliberately overlapping memcpy implementation<br>
	 * @param dst destination buffer<br>
	 * @param back how many bytes back we start (the initial size of the overlapping window), must be > 0<br>
	 * @param cnt number of bytes to copy, must be >= 0<br>
	 * * cnt > back is valid, this will copy the bytes we just copied,<br>
	 * thus creating a repeating pattern with a period length of back.<br>
	 * Original signature : <code>void av_memcpy_backptr(uint8_t*, int, int)</code><br>
	 * <i>native declaration : libavutil/mem.h:213</i><br>
	 * @deprecated use the safer methods {@link #av_memcpy_backptr(java.nio.ByteBuffer, int, int)} and {@link #av_memcpy_backptr(com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	void av_memcpy_backptr(Pointer dst, int back, int cnt);
	/**
	 * @brief deliberately overlapping memcpy implementation<br>
	 * @param dst destination buffer<br>
	 * @param back how many bytes back we start (the initial size of the overlapping window), must be > 0<br>
	 * @param cnt number of bytes to copy, must be >= 0<br>
	 * * cnt > back is valid, this will copy the bytes we just copied,<br>
	 * thus creating a repeating pattern with a period length of back.<br>
	 * Original signature : <code>void av_memcpy_backptr(uint8_t*, int, int)</code><br>
	 * <i>native declaration : libavutil/mem.h:213</i>
	 */
	void av_memcpy_backptr(ByteBuffer dst, int back, int cnt);
	/**
	 * Reduce a fraction.<br>
	 * This is useful for framerate calculations.<br>
	 * @param dst_num destination numerator<br>
	 * @param dst_den destination denominator<br>
	 * @param num source numerator<br>
	 * @param den source denominator<br>
	 * @param max the maximum allowed for dst_num & dst_den<br>
	 * @return 1 if exact, 0 otherwise<br>
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil/rational.h:48</i><br>
	 * @deprecated use the safer methods {@link #av_reduce(java.nio.IntBuffer, java.nio.IntBuffer, long, long, long)} and {@link #av_reduce(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, long, long, long)} instead
	 */
	@Deprecated 
	int av_reduce(IntByReference dst_num, IntByReference dst_den, long num, long den, long max);
	/**
	 * Reduce a fraction.<br>
	 * This is useful for framerate calculations.<br>
	 * @param dst_num destination numerator<br>
	 * @param dst_den destination denominator<br>
	 * @param num source numerator<br>
	 * @param den source denominator<br>
	 * @param max the maximum allowed for dst_num & dst_den<br>
	 * @return 1 if exact, 0 otherwise<br>
	 * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil/rational.h:48</i>
	 */
	int av_reduce(IntBuffer dst_num, IntBuffer dst_den, long num, long den, long max);
	/**
	 * Multiply two rationals.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b*c<br>
	 * Original signature : <code>AVRational av_mul_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil/rational.h:56</i>
	 */
	AVRational.ByValue av_mul_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Divide one rational by another.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b/c<br>
	 * Original signature : <code>AVRational av_div_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil/rational.h:64</i>
	 */
	AVRational.ByValue av_div_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Add two rationals.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b+c<br>
	 * Original signature : <code>AVRational av_add_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil/rational.h:72</i>
	 */
	AVRational.ByValue av_add_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Subtract one rational from another.<br>
	 * @param b first rational<br>
	 * @param c second rational<br>
	 * @return b-c<br>
	 * Original signature : <code>AVRational av_sub_q(AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil/rational.h:80</i>
	 */
	AVRational.ByValue av_sub_q(AVRational.ByValue b, AVRational.ByValue c);
	/**
	 * Convert a double precision floating point number to a rational.<br>
	 * inf is expressed as {1,0} or {-1,0} depending on the sign.<br>
	 * * @param d double to convert<br>
	 * @param max the maximum allowed numerator and denominator<br>
	 * @return (AVRational) d<br>
	 * Original signature : <code>AVRational av_d2q(double, int)</code><br>
	 * <i>native declaration : libavutil/rational.h:99</i>
	 */
	AVRational.ByValue av_d2q(double d, int max);
	/**
	 * @return 1 if q1 is nearer to q than q2, -1 if q2 is nearer<br>
	 * than q1, 0 if they have the same distance.<br>
	 * Original signature : <code>int av_nearer_q(AVRational, AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil/rational.h:105</i>
	 */
	int av_nearer_q(AVRational.ByValue q, AVRational.ByValue q1, AVRational.ByValue q2);
	/**
	 * Find the nearest value in q_list to q.<br>
	 * @param q_list an array of rationals terminated by {0, 0}<br>
	 * @return the index of the nearest value found in the array<br>
	 * Original signature : <code>int av_find_nearest_q_idx(AVRational, const AVRational*)</code><br>
	 * <i>native declaration : libavutil/rational.h:112</i>
	 */
	int av_find_nearest_q_idx(AVRational.ByValue q, AVRational q_list);
	/**
	 * Return the greatest common divisor of a and b.<br>
	 * If both a and b are 0 or either or both are <0 then behavior is<br>
	 * undefined.<br>
	 * Original signature : <code>int64_t av_gcd(int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:20</i>
	 */
	long av_gcd(long a, long b);
	/**
	 * Rescale a 64-bit integer with rounding to nearest.<br>
	 * A simple a*b/c isn't possible as it can overflow.<br>
	 * Original signature : <code>int64_t av_rescale(int64_t, int64_t, int64_t)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:26</i>
	 */
	long av_rescale(long a, long b, long c);
	/**
	 * Rescale a 64-bit integer with specified rounding.<br>
	 * A simple a*b/c isn't possible as it can overflow.<br>
	 * * @return rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is<br>
	 *         INT64_MIN or INT64_MAX then a is passed through unchanged.<br>
	 * Original signature : <code>int64_t av_rescale_rnd(int64_t, int64_t, int64_t, AVRounding)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:34</i>
	 */
	long av_rescale_rnd(long a, long b, long c, int arg1);
	/**
	 * Rescale a 64-bit integer by 2 rational numbers.<br>
	 * Original signature : <code>int64_t av_rescale_q(int64_t, AVRational, AVRational)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:39</i>
	 */
	long av_rescale_q(long a, AVRational.ByValue bq, AVRational.ByValue cq);
	/**
	 * Rescale a 64-bit integer by 2 rational numbers with specified rounding.<br>
	 * * @return rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is<br>
	 *         INT64_MIN or INT64_MAX then a is passed through unchanged.<br>
	 * Original signature : <code>int64_t av_rescale_q_rnd(int64_t, AVRational, AVRational, AVRounding)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:46</i>
	 */
	long av_rescale_q_rnd(long a, AVRational.ByValue bq, AVRational.ByValue cq, int arg1);
	/**
	 * Compare 2 timestamps each in its own timebases.<br>
	 * The result of the function is undefined if one of the timestamps<br>
	 * is outside the int64_t range when represented in the others timebase.<br>
	 * @return -1 if ts_a is before ts_b, 1 if ts_a is after ts_b or 0 if they represent the same position<br>
	 * Original signature : <code>int av_compare_ts(int64_t, AVRational, int64_t, AVRational)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:54</i>
	 */
	int av_compare_ts(long ts_a, AVRational.ByValue tb_a, long ts_b, AVRational.ByValue tb_b);
	/**
	 * Compare 2 integers modulo mod.<br>
	 * That is we compare integers a and b for which only the least<br>
	 * significant log2(mod) bits are known.<br>
	 * * @param mod must be a power of 2<br>
	 * @return a negative value if a is smaller than b<br>
	 *         a positive value if a is greater than b<br>
	 *         0                if a equals          b<br>
	 * Original signature : <code>int64_t av_compare_mod(uint64_t, uint64_t, uint64_t)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:65</i>
	 */
	long av_compare_mod(long a, long b, long mod);
	/**
	 * Rescale a timestamp while preserving known durations.<br>
	 * * @param in_ts Input timestamp<br>
	 * @param in_tb Input timesbase<br>
	 * @param fs_tb Duration and *last timebase<br>
	 * @param duration duration till the next call<br>
	 * @param out_tb Output timesbase<br>
	 * Original signature : <code>int64_t av_rescale_delta(AVRational, int64_t, AVRational, int, int64_t*, AVRational)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:75</i><br>
	 * @deprecated use the safer methods {@link #av_rescale_delta(wrapffmpeg.AVRational.ByValue, long, wrapffmpeg.AVRational.ByValue, int, java.nio.LongBuffer, wrapffmpeg.AVRational.ByValue)} and {@link #av_rescale_delta(wrapffmpeg.AVRational.ByValue, long, wrapffmpeg.AVRational.ByValue, int, com.sun.jna.ptr.LongByReference, wrapffmpeg.AVRational.ByValue)} instead
	 */
	@Deprecated 
	long av_rescale_delta(AVRational.ByValue in_tb, long in_ts, AVRational.ByValue fs_tb, int duration, LongByReference last, AVRational.ByValue out_tb);
	/**
	 * Rescale a timestamp while preserving known durations.<br>
	 * * @param in_ts Input timestamp<br>
	 * @param in_tb Input timesbase<br>
	 * @param fs_tb Duration and *last timebase<br>
	 * @param duration duration till the next call<br>
	 * @param out_tb Output timesbase<br>
	 * Original signature : <code>int64_t av_rescale_delta(AVRational, int64_t, AVRational, int, int64_t*, AVRational)</code><br>
	 * <i>native declaration : libavutil/mathematics.h:75</i>
	 */
	long av_rescale_delta(AVRational.ByValue in_tb, long in_ts, AVRational.ByValue fs_tb, int duration, LongBuffer last, AVRational.ByValue out_tb);
	/**
	 * Original signature : <code>double av_int2dbl(int64_t)</code><br>
	 * <i>native declaration : libavutil/intfloat_readwrite.h:6</i>
	 */
	double av_int2dbl(long v);
	/**
	 * Original signature : <code>float av_int2flt(int32_t)</code><br>
	 * <i>native declaration : libavutil/intfloat_readwrite.h:8</i>
	 */
	float av_int2flt(int v);
	/**
	 * Original signature : <code>double av_ext2dbl(const AVExtFloat)</code><br>
	 * <i>native declaration : libavutil/intfloat_readwrite.h:10</i>
	 */
	double av_ext2dbl(wrapffmpeg.AVExtFloat.ByValue ext);
	/**
	 * Original signature : <code>int64_t av_dbl2int(double)</code><br>
	 * <i>native declaration : libavutil/intfloat_readwrite.h:12</i>
	 */
	long av_dbl2int(double d);
	/**
	 * Original signature : <code>int32_t av_flt2int(float)</code><br>
	 * <i>native declaration : libavutil/intfloat_readwrite.h:14</i>
	 */
	int av_flt2int(float d);
	/**
	 * Original signature : <code>AVExtFloat av_dbl2ext(double)</code><br>
	 * <i>native declaration : libavutil/intfloat_readwrite.h:16</i>
	 */
	wrapffmpeg.AVExtFloat.ByValue av_dbl2ext(double d);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different av_vlog callback<br>
	 * function.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 * subsequent arguments are converted to output.<br>
	 * @see av_vlog<br>
	 * Original signature : <code>void av_log(void*, int, const char*, null)</code><br>
	 * <i>native declaration : libavutil/log.h:96</i><br>
	 * @deprecated use the safer methods {@link #av_log(com.sun.jna.Pointer, int, java.lang.String, java.lang.Object)} and {@link #av_log(com.sun.jna.Pointer, int, com.sun.jna.Pointer, java.lang.Object)} instead
	 */
	@Deprecated 
	void av_log(Pointer avcl, int level, Pointer fmt, Object... varargs);
	/**
	 * Send the specified message to the log if the level is less than or equal<br>
	 * to the current av_log_level. By default, all logging messages are sent to<br>
	 * stderr. This behavior can be altered by setting a different av_vlog callback<br>
	 * function.<br>
	 * * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
	 * pointer to an AVClass struct.<br>
	 * @param level The importance level of the message, lower values signifying<br>
	 * higher importance.<br>
	 * @param fmt The format string (printf-compatible) that specifies how<br>
	 * subsequent arguments are converted to output.<br>
	 * @see av_vlog<br>
	 * Original signature : <code>void av_log(void*, int, const char*, null)</code><br>
	 * <i>native declaration : libavutil/log.h:96</i>
	 */
	void av_log(Pointer avcl, int level, String fmt, Object... varargs);
	/**
	 * Original signature : <code>void av_vlog(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil/log.h:98</i><br>
	 * @deprecated use the safer methods {@link #av_vlog(com.sun.jna.Pointer, int, java.lang.String, wrapffmpeg.AvutilLibrary.va_list)} and {@link #av_vlog(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void av_vlog(Pointer avcl, int level, Pointer fmt, Pointer va_list1);
	/**
	 * Original signature : <code>void av_vlog(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil/log.h:98</i>
	 */
	void av_vlog(Pointer avcl, int level, String fmt, AvutilLibrary.va_list va_list1);
	/**
	 * Original signature : <code>int av_log_get_level()</code><br>
	 * <i>native declaration : libavutil/log.h:100</i>
	 */
	int av_log_get_level();
	/**
	 * Original signature : <code>void av_log_set_level(int)</code><br>
	 * <i>native declaration : libavutil/log.h:102</i>
	 */
	void av_log_set_level(int int1);
	/**
	 * Original signature : <code>void av_log_set_callback(av_log_set_callback_arg1_callback*)</code><br>
	 * <i>native declaration : libavutil/log.h:104</i>
	 */
	void av_log_set_callback(AvutilLibrary.av_log_set_callback_arg1_callback arg1);
	/**
	 * Original signature : <code>void av_log_default_callback(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil/log.h:106</i><br>
	 * @deprecated use the safer methods {@link #av_log_default_callback(com.sun.jna.Pointer, int, java.lang.String, wrapffmpeg.AvutilLibrary.va_list)} and {@link #av_log_default_callback(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void av_log_default_callback(Pointer ptr, int level, Pointer fmt, Pointer vl);
	/**
	 * Original signature : <code>void av_log_default_callback(void*, int, const char*, va_list)</code><br>
	 * <i>native declaration : libavutil/log.h:106</i>
	 */
	void av_log_default_callback(Pointer ptr, int level, String fmt, AvutilLibrary.va_list vl);
	/**
	 * Original signature : <code>char* av_default_item_name(void*)</code><br>
	 * <i>native declaration : libavutil/log.h:108</i>
	 */
	String av_default_item_name(Pointer ctx);
	/**
	 * Original signature : <code>AVClassCategory av_default_get_category(void*)</code><br>
	 * <i>native declaration : libavutil/log.h:110</i>
	 */
	int av_default_get_category(Pointer ptr);
	/**
	 * Format a line of log the same way as the default callback.<br>
	 * @param line          buffer to receive the formated line<br>
	 * @param line_size     size of the buffer<br>
	 * @param print_prefix  used to store whether the prefix must be printed;<br>
	 *                      must point to a persistent integer initially set to 1<br>
	 * Original signature : <code>void av_log_format_line(void*, int, const char*, va_list, char*, int, int*)</code><br>
	 * <i>native declaration : libavutil/log.h:119</i><br>
	 * @deprecated use the safer methods {@link #av_log_format_line(com.sun.jna.Pointer, int, java.lang.String, wrapffmpeg.AvutilLibrary.va_list, java.nio.ByteBuffer, int, java.nio.IntBuffer)} and {@link #av_log_format_line(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	void av_log_format_line(Pointer ptr, int level, Pointer fmt, Pointer vl, Pointer line, int line_size, IntByReference print_prefix);
	/**
	 * Format a line of log the same way as the default callback.<br>
	 * @param line          buffer to receive the formated line<br>
	 * @param line_size     size of the buffer<br>
	 * @param print_prefix  used to store whether the prefix must be printed;<br>
	 *                      must point to a persistent integer initially set to 1<br>
	 * Original signature : <code>void av_log_format_line(void*, int, const char*, va_list, char*, int, int*)</code><br>
	 * <i>native declaration : libavutil/log.h:119</i>
	 */
	void av_log_format_line(Pointer ptr, int level, String fmt, AvutilLibrary.va_list vl, ByteBuffer line, int line_size, IntBuffer print_prefix);
	/**
	 * Original signature : <code>void av_log_set_flags(int)</code><br>
	 * <i>native declaration : libavutil/log.h:121</i>
	 */
	void av_log_set_flags(int arg);
	/**
	 * Compute the length of an integer list.<br>
	 * * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)<br>
	 * @param term    list terminator (usually 0 or -1)<br>
	 * @param list    pointer to the list<br>
	 * @return  length of the list, in elements, not counting the terminator<br>
	 * Original signature : <code>int av_int_list_length_for_size(unsigned, const void*, uint64_t)</code><br>
	 * <i>native declaration : libavutil/avutil.h:15</i>
	 */
	int av_int_list_length_for_size(int elsize, Pointer list, long term);
	/**
	 * Return the name of sample_fmt, or NULL if sample_fmt is not<br>
	 * recognized.<br>
	 * Original signature : <code>char* av_get_sample_fmt_name(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:48</i>
	 */
	String av_get_sample_fmt_name(int sample_fmt);
	/**
	 * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE<br>
	 * on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:54</i><br>
	 * @deprecated use the safer methods {@link #av_get_sample_fmt(java.lang.String)} and {@link #av_get_sample_fmt(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_get_sample_fmt(Pointer name);
	/**
	 * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE<br>
	 * on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:54</i>
	 */
	int av_get_sample_fmt(String name);
	/**
	 * Return the planar<->packed alternative form of the given sample format, or<br>
	 * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the<br>
	 * requested planar/packed format, the format returned is the same as the<br>
	 * input.<br>
	 * Original signature : <code>AVSampleFormat av_get_alt_sample_fmt(AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:62</i>
	 */
	int av_get_alt_sample_fmt(int sample_fmt, int planar);
	/**
	 * Get the packed alternative form of the given sample format.<br>
	 * * If the passed sample_fmt is already in packed format, the format returned is<br>
	 * the same as the input.<br>
	 * * @return  the packed alternative form of the given sample format or<br>
	 * AV_SAMPLE_FMT_NONE on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_packed_sample_fmt(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:71</i>
	 */
	int av_get_packed_sample_fmt(int sample_fmt);
	/**
	 * Get the planar alternative form of the given sample format.<br>
	 * * If the passed sample_fmt is already in planar format, the format returned is<br>
	 * the same as the input.<br>
	 * * @return  the planar alternative form of the given sample format or<br>
	 * AV_SAMPLE_FMT_NONE on error.<br>
	 * Original signature : <code>AVSampleFormat av_get_planar_sample_fmt(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:80</i>
	 */
	int av_get_planar_sample_fmt(int sample_fmt);
	/**
	 * Generate a string corresponding to the sample format with<br>
	 * sample_fmt, or a header if sample_fmt is negative.<br>
	 * * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param sample_fmt the number of the sample format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * @return the pointer to the filled buffer or NULL if sample_fmt is<br>
	 * unknown or in case of other errors<br>
	 * Original signature : <code>char* av_get_sample_fmt_string(char*, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:93</i><br>
	 * @deprecated use the safer methods {@link #av_get_sample_fmt_string(java.nio.ByteBuffer, int, int)} and {@link #av_get_sample_fmt_string(com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	Pointer av_get_sample_fmt_string(Pointer buf, int buf_size, int sample_fmt);
	/**
	 * Generate a string corresponding to the sample format with<br>
	 * sample_fmt, or a header if sample_fmt is negative.<br>
	 * * @param buf the buffer where to write the string<br>
	 * @param buf_size the size of buf<br>
	 * @param sample_fmt the number of the sample format to print the<br>
	 * corresponding info string, or a negative value to print the<br>
	 * corresponding header.<br>
	 * @return the pointer to the filled buffer or NULL if sample_fmt is<br>
	 * unknown or in case of other errors<br>
	 * Original signature : <code>char* av_get_sample_fmt_string(char*, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:93</i>
	 */
	Pointer av_get_sample_fmt_string(ByteBuffer buf, int buf_size, int sample_fmt);
	/**
	 * Original signature : <code>int av_get_bits_per_sample_fmt(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:95</i>
	 */
	int av_get_bits_per_sample_fmt(int sample_fmt);
	/**
	 * Return number of bytes per sample.<br>
	 * * @param sample_fmt the sample format<br>
	 * @return number of bytes per sample or zero if unknown for the given<br>
	 * sample format<br>
	 * Original signature : <code>int av_get_bytes_per_sample(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:103</i>
	 */
	int av_get_bytes_per_sample(int sample_fmt);
	/**
	 * Check if the sample format is planar.<br>
	 * * @param sample_fmt the sample format to inspect<br>
	 * @return 1 if the sample format is planar, 0 if it is interleaved<br>
	 * Original signature : <code>int av_sample_fmt_is_planar(AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:110</i>
	 */
	int av_sample_fmt_is_planar(int sample_fmt);
	/**
	 * Get the required buffer size for the given audio parameters.<br>
	 * * @param[out] linesize calculated linesize, may be NULL<br>
	 * @param nb_channels   the number of channels<br>
	 * @param nb_samples    the number of samples in a single channel<br>
	 * @param sample_fmt    the sample format<br>
	 * @param align         buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return              required buffer size, or negative error code on failure<br>
	 * Original signature : <code>int av_samples_get_buffer_size(int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:121</i><br>
	 * @deprecated use the safer methods {@link #av_samples_get_buffer_size(java.nio.IntBuffer, int, int, int, int)} and {@link #av_samples_get_buffer_size(com.sun.jna.ptr.IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_get_buffer_size(IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Get the required buffer size for the given audio parameters.<br>
	 * * @param[out] linesize calculated linesize, may be NULL<br>
	 * @param nb_channels   the number of channels<br>
	 * @param nb_samples    the number of samples in a single channel<br>
	 * @param sample_fmt    the sample format<br>
	 * @param align         buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return              required buffer size, or negative error code on failure<br>
	 * Original signature : <code>int av_samples_get_buffer_size(int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:121</i>
	 */
	int av_samples_get_buffer_size(IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Fill plane data pointers and linesize for samples with sample<br>
	 * format sample_fmt.<br>
	 * * The audio_data array is filled with the pointers to the samples data planes:<br>
	 * for planar, set the start point of each channel's data within the buffer,<br>
	 * for packed, set the start point of the entire buffer only.<br>
	 * * The value pointed to by linesize is set to the aligned size of each<br>
	 * channel's data buffer for planar layout, or to the aligned size of the<br>
	 * buffer for all channels for packed layout.<br>
	 * * The buffer in buf must be big enough to contain all the samples<br>
	 * (use av_samples_get_buffer_size() to compute its minimum size),<br>
	 * otherwise the audio_data pointers will point to invalid data.<br>
	 * * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    calculated linesize, may be NULL<br>
	 * @param buf              the pointer to a buffer containing the samples<br>
	 * @param nb_channels      the number of channels<br>
	 * @param nb_samples       the number of samples in a single channel<br>
	 * @param sample_fmt       the sample format<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return minimum size in bytes required for the buffer in case<br>
	 * of success at the next bump<br>
	 * Original signature : <code>int av_samples_fill_arrays(uint8_t**, int*, const uint8_t*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:148</i><br>
	 * @deprecated use the safer methods {@link #av_samples_fill_arrays(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, java.nio.ByteBuffer, int, int, int, int)} and {@link #av_samples_fill_arrays(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_fill_arrays(PointerByReference audio_data, IntByReference linesize, Pointer buf, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Fill plane data pointers and linesize for samples with sample<br>
	 * format sample_fmt.<br>
	 * * The audio_data array is filled with the pointers to the samples data planes:<br>
	 * for planar, set the start point of each channel's data within the buffer,<br>
	 * for packed, set the start point of the entire buffer only.<br>
	 * * The value pointed to by linesize is set to the aligned size of each<br>
	 * channel's data buffer for planar layout, or to the aligned size of the<br>
	 * buffer for all channels for packed layout.<br>
	 * * The buffer in buf must be big enough to contain all the samples<br>
	 * (use av_samples_get_buffer_size() to compute its minimum size),<br>
	 * otherwise the audio_data pointers will point to invalid data.<br>
	 * * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    calculated linesize, may be NULL<br>
	 * @param buf              the pointer to a buffer containing the samples<br>
	 * @param nb_channels      the number of channels<br>
	 * @param nb_samples       the number of samples in a single channel<br>
	 * @param sample_fmt       the sample format<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return minimum size in bytes required for the buffer in case<br>
	 * of success at the next bump<br>
	 * Original signature : <code>int av_samples_fill_arrays(uint8_t**, int*, const uint8_t*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:148</i>
	 */
	int av_samples_fill_arrays(PointerByReference audio_data, IntBuffer linesize, ByteBuffer buf, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a samples buffer for nb_samples samples, and fill data pointers and<br>
	 * linesize accordingly.<br>
	 * The allocated samples buffer can be freed by using av_freep(&audio_data[0])<br>
	 * Allocated data will be initialized to silence.<br>
	 * * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    aligned size for audio buffer(s), may be NULL<br>
	 * @param nb_channels      number of audio channels<br>
	 * @param nb_samples       number of samples per channel<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return the size of the allocated buffer in case of success at the next bump<br>
	 * @see av_samples_fill_arrays()<br>
	 * @see av_samples_alloc_array_and_samples()<br>
	 * Original signature : <code>int av_samples_alloc(uint8_t**, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:167</i><br>
	 * @deprecated use the safer methods {@link #av_samples_alloc(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, int, int, int, int)} and {@link #av_samples_alloc(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_alloc(PointerByReference audio_data, IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a samples buffer for nb_samples samples, and fill data pointers and<br>
	 * linesize accordingly.<br>
	 * The allocated samples buffer can be freed by using av_freep(&audio_data[0])<br>
	 * Allocated data will be initialized to silence.<br>
	 * * @see enum AVSampleFormat<br>
	 * The documentation for AVSampleFormat describes the data layout.<br>
	 * * @param[out] audio_data  array to be filled with the pointer for each channel<br>
	 * @param[out] linesize    aligned size for audio buffer(s), may be NULL<br>
	 * @param nb_channels      number of audio channels<br>
	 * @param nb_samples       number of samples per channel<br>
	 * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
	 * @return                 >=0 on success or a negative error code on failure<br>
	 * @todo return the size of the allocated buffer in case of success at the next bump<br>
	 * @see av_samples_fill_arrays()<br>
	 * @see av_samples_alloc_array_and_samples()<br>
	 * Original signature : <code>int av_samples_alloc(uint8_t**, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:167</i>
	 */
	int av_samples_alloc(PointerByReference audio_data, IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a data pointers array, samples buffer for nb_samples<br>
	 * samples, and fill data pointers and linesize accordingly.<br>
	 * * This is the same as av_samples_alloc(), but also allocates the data<br>
	 * pointers array.<br>
	 * * @see av_samples_alloc()<br>
	 * Original signature : <code>int av_samples_alloc_array_and_samples(uint8_t***, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:176</i><br>
	 * @deprecated use the safer methods {@link #av_samples_alloc_array_and_samples(com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, int, int, int, int)} and {@link #av_samples_alloc_array_and_samples(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.IntByReference, int, int, int, int)} instead
	 */
	@Deprecated 
	int av_samples_alloc_array_and_samples(PointerByReference audio_data, IntByReference linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Allocate a data pointers array, samples buffer for nb_samples<br>
	 * samples, and fill data pointers and linesize accordingly.<br>
	 * * This is the same as av_samples_alloc(), but also allocates the data<br>
	 * pointers array.<br>
	 * * @see av_samples_alloc()<br>
	 * Original signature : <code>int av_samples_alloc_array_and_samples(uint8_t***, int*, int, int, AVSampleFormat, int)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:176</i>
	 */
	int av_samples_alloc_array_and_samples(PointerByReference audio_data, IntBuffer linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
	/**
	 * Copy samples from src to dst.<br>
	 * * @param dst destination array of pointers to data planes<br>
	 * @param src source array of pointers to data planes<br>
	 * @param dst_offset offset in samples at which the data will be written to dst<br>
	 * @param src_offset offset in samples at which the data will be read from src<br>
	 * @param nb_samples number of samples to be copied<br>
	 * @param nb_channels number of audio channels<br>
	 * @param sample_fmt audio sample format<br>
	 * Original signature : <code>int av_samples_copy(uint8_t**, const uint8_t**, int, int, int, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:188</i>
	 */
	int av_samples_copy(PointerByReference dst, PointerByReference src, int dst_offset, int src_offset, int nb_samples, int nb_channels, int sample_fmt);
	/**
	 * Fill an audio buffer with silence.<br>
	 * * @param audio_data  array of pointers to data planes<br>
	 * @param offset      offset in samples at which to start filling<br>
	 * @param nb_samples  number of samples to fill<br>
	 * @param nb_channels number of audio channels<br>
	 * @param sample_fmt  audio sample format<br>
	 * Original signature : <code>int av_samples_set_silence(uint8_t**, int, int, int, AVSampleFormat)</code><br>
	 * <i>native declaration : libavutil/samplefmt.h:198</i>
	 */
	int av_samples_set_silence(PointerByReference audio_data, int offset, int nb_samples, int nb_channels, int sample_fmt);
	/**
	 * Allocate an AVBuffer of the given size using av_malloc().<br>
	 * * @return an AVBufferRef of given size or NULL when out of memory<br>
	 * Original signature : <code>AVBufferRef* av_buffer_alloc(int)</code><br>
	 * <i>native declaration : libavutil/buffer.h:26</i>
	 */
	AVBufferRef av_buffer_alloc(int size);
	/**
	 * Same as av_buffer_alloc(), except the returned buffer will be initialized<br>
	 * to zero.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_allocz(int)</code><br>
	 * <i>native declaration : libavutil/buffer.h:32</i>
	 */
	AVBufferRef av_buffer_allocz(int size);
	/**
	 * Create an AVBuffer from an existing array.<br>
	 * * If this function is successful, data is owned by the AVBuffer. The caller may<br>
	 * only access data through the returned AVBufferRef and references derived from<br>
	 * it.<br>
	 * If this function fails, data is left untouched.<br>
	 * @param data   data array<br>
	 * @param size   size of data in bytes<br>
	 * @param free   a callback for freeing this buffer's data<br>
	 * @param opaque parameter to be got for processing or passed to free<br>
	 * @param flags  a combination of AV_BUFFER_FLAG_*<br>
	 * * @return an AVBufferRef referring to data on success, NULL on failure.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_create(uint8_t*, int, av_buffer_create_free_callback*, void*, int)</code><br>
	 * <i>native declaration : libavutil/buffer.h:47</i><br>
	 * @deprecated use the safer methods {@link #av_buffer_create(java.nio.ByteBuffer, int, wrapffmpeg.AvutilLibrary.av_buffer_create_free_callback, com.sun.jna.Pointer, int)} and {@link #av_buffer_create(com.sun.jna.Pointer, int, wrapffmpeg.AvutilLibrary.av_buffer_create_free_callback, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	AVBufferRef av_buffer_create(Pointer data, int size, AvutilLibrary.av_buffer_create_free_callback free, Pointer opaque, int flags);
	/**
	 * Create an AVBuffer from an existing array.<br>
	 * * If this function is successful, data is owned by the AVBuffer. The caller may<br>
	 * only access data through the returned AVBufferRef and references derived from<br>
	 * it.<br>
	 * If this function fails, data is left untouched.<br>
	 * @param data   data array<br>
	 * @param size   size of data in bytes<br>
	 * @param free   a callback for freeing this buffer's data<br>
	 * @param opaque parameter to be got for processing or passed to free<br>
	 * @param flags  a combination of AV_BUFFER_FLAG_*<br>
	 * * @return an AVBufferRef referring to data on success, NULL on failure.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_create(uint8_t*, int, av_buffer_create_free_callback*, void*, int)</code><br>
	 * <i>native declaration : libavutil/buffer.h:47</i>
	 */
	AVBufferRef av_buffer_create(ByteBuffer data, int size, AvutilLibrary.av_buffer_create_free_callback free, Pointer opaque, int flags);
	/**
	 * Default free callback, which calls av_free() on the buffer data.<br>
	 * This function is meant to be passed to av_buffer_create(), not called<br>
	 * directly.<br>
	 * Original signature : <code>void av_buffer_default_free(void*, uint8_t*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:54</i><br>
	 * @deprecated use the safer methods {@link #av_buffer_default_free(com.sun.jna.Pointer, java.nio.ByteBuffer)} and {@link #av_buffer_default_free(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void av_buffer_default_free(Pointer opaque, Pointer data);
	/**
	 * Default free callback, which calls av_free() on the buffer data.<br>
	 * This function is meant to be passed to av_buffer_create(), not called<br>
	 * directly.<br>
	 * Original signature : <code>void av_buffer_default_free(void*, uint8_t*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:54</i>
	 */
	void av_buffer_default_free(Pointer opaque, ByteBuffer data);
	/**
	 * Create a new reference to an AVBuffer.<br>
	 * * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on<br>
	 * failure.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_ref(AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:61</i>
	 */
	AVBufferRef av_buffer_ref(AVBufferRef buf);
	/**
	 * Free a given reference and automatically free the buffer if there are no more<br>
	 * references to it.<br>
	 * * @param buf the reference to be freed. The pointer is set to NULL on return.<br>
	 * Original signature : <code>void av_buffer_unref(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil/buffer.h:68</i><br>
	 * @deprecated use the safer method {@link #av_buffer_unref(wrapffmpeg.AVBufferRef.ByReference[])} instead
	 */
	@Deprecated 
	void av_buffer_unref(PointerByReference buf);
	/**
	 * Free a given reference and automatically free the buffer if there are no more<br>
	 * references to it.<br>
	 * * @param buf the reference to be freed. The pointer is set to NULL on return.<br>
	 * Original signature : <code>void av_buffer_unref(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil/buffer.h:68</i>
	 */
	void av_buffer_unref(AVBufferRef.ByReference buf[]);
	/**
	 * @return 1 if the caller may write to the data referred to by buf (which is<br>
	 * true if and only if buf is the only reference to the underlying AVBuffer).<br>
	 * Return 0 otherwise.<br>
	 * A positive answer is valid until av_buffer_ref() is called on buf.<br>
	 * Original signature : <code>int av_buffer_is_writable(const AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:76</i>
	 */
	int av_buffer_is_writable(AVBufferRef buf);
	/**
	 * @return the opaque parameter set by av_buffer_create.<br>
	 * Original signature : <code>void* av_buffer_get_opaque(const AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:81</i>
	 */
	Pointer av_buffer_get_opaque(AVBufferRef buf);
	/**
	 * Original signature : <code>int av_buffer_get_ref_count(const AVBufferRef*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:83</i>
	 */
	int av_buffer_get_ref_count(AVBufferRef buf);
	/**
	 * Create a writable reference from a given buffer reference, avoiding data copy<br>
	 * if possible.<br>
	 * * @param buf buffer reference to make writable. On success, buf is either left<br>
	 *            untouched, or it is unreferenced and a new writable AVBufferRef is<br>
	 *            written in its place. On failure, buf is left untouched.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * Original signature : <code>int av_buffer_make_writable(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil/buffer.h:93</i><br>
	 * @deprecated use the safer method {@link #av_buffer_make_writable(wrapffmpeg.AVBufferRef.ByReference[])} instead
	 */
	@Deprecated 
	int av_buffer_make_writable(PointerByReference buf);
	/**
	 * Create a writable reference from a given buffer reference, avoiding data copy<br>
	 * if possible.<br>
	 * * @param buf buffer reference to make writable. On success, buf is either left<br>
	 *            untouched, or it is unreferenced and a new writable AVBufferRef is<br>
	 *            written in its place. On failure, buf is left untouched.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * Original signature : <code>int av_buffer_make_writable(AVBufferRef**)</code><br>
	 * <i>native declaration : libavutil/buffer.h:93</i>
	 */
	int av_buffer_make_writable(AVBufferRef.ByReference buf[]);
	/**
	 * Reallocate a given buffer.<br>
	 * * @param buf  a buffer reference to reallocate. On success, buf will be<br>
	 *             unreferenced and a new reference with the required size will be<br>
	 *             written in its place. On failure buf will be left untouched. *buf<br>
	 *             may be NULL, then a new buffer is allocated.<br>
	 * @param size required new buffer size.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * * @note the buffer is actually reallocated with av_realloc() only if it was<br>
	 * initially allocated through av_buffer_realloc(NULL) and there is only one<br>
	 * reference to it (i.e. the one passed to this function). In all other cases<br>
	 * a new buffer is allocated and the data is copied.<br>
	 * Original signature : <code>int av_buffer_realloc(AVBufferRef**, int)</code><br>
	 * <i>native declaration : libavutil/buffer.h:108</i><br>
	 * @deprecated use the safer method {@link #av_buffer_realloc(wrapffmpeg.AVBufferRef.ByReference[], int)} instead
	 */
	@Deprecated 
	int av_buffer_realloc(PointerByReference buf, int size);
	/**
	 * Reallocate a given buffer.<br>
	 * * @param buf  a buffer reference to reallocate. On success, buf will be<br>
	 *             unreferenced and a new reference with the required size will be<br>
	 *             written in its place. On failure buf will be left untouched. *buf<br>
	 *             may be NULL, then a new buffer is allocated.<br>
	 * @param size required new buffer size.<br>
	 * @return 0 on success, a negative AVERROR on failure.<br>
	 * * @note the buffer is actually reallocated with av_realloc() only if it was<br>
	 * initially allocated through av_buffer_realloc(NULL) and there is only one<br>
	 * reference to it (i.e. the one passed to this function). In all other cases<br>
	 * a new buffer is allocated and the data is copied.<br>
	 * Original signature : <code>int av_buffer_realloc(AVBufferRef**, int)</code><br>
	 * <i>native declaration : libavutil/buffer.h:108</i>
	 */
	int av_buffer_realloc(AVBufferRef.ByReference buf[], int size);
	/**
	 * Allocate and initialize a buffer pool.<br>
	 * * @param size size of each buffer in this pool<br>
	 * @param alloc a function that will be used to allocate new buffers when the<br>
	 * pool is empty. May be NULL, then the default allocator will be used<br>
	 * (av_buffer_alloc()).<br>
	 * @return newly created buffer pool on success, NULL on error.<br>
	 * Original signature : <code>AVBufferPool* av_buffer_pool_init(int, av_buffer_pool_init_alloc_callback*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:124</i>
	 */
	PointerByReference av_buffer_pool_init(int size, AvutilLibrary.av_buffer_pool_init_alloc_callback alloc);
	/**
	 * Mark the pool as being available for freeing. It will actually be freed only<br>
	 * once all the allocated buffers associated with the pool are released. Thus it<br>
	 * is safe to call this function while some of the allocated buffers are still<br>
	 * in use.<br>
	 * * @param pool pointer to the pool to be freed. It will be set to NULL.<br>
	 * @see av_buffer_pool_can_uninit()<br>
	 * Original signature : <code>void av_buffer_pool_uninit(AVBufferPool**)</code><br>
	 * <i>native declaration : libavutil/buffer.h:134</i>
	 */
	void av_buffer_pool_uninit(PointerByReference pool);
	/**
	 * Allocate a new AVBuffer, reusing an old buffer from the pool when available.<br>
	 * This function may be called simultaneously from multiple threads.<br>
	 * * @return a reference to the new buffer on success, NULL on error.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_pool_get(AVBufferPool*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:141</i><br>
	 * @deprecated use the safer method {@link #av_buffer_pool_get(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	AVBufferRef av_buffer_pool_get(Pointer pool);
	/**
	 * Allocate a new AVBuffer, reusing an old buffer from the pool when available.<br>
	 * This function may be called simultaneously from multiple threads.<br>
	 * * @return a reference to the new buffer on success, NULL on error.<br>
	 * Original signature : <code>AVBufferRef* av_buffer_pool_get(AVBufferPool*)</code><br>
	 * <i>native declaration : libavutil/buffer.h:141</i>
	 */
	AVBufferRef av_buffer_pool_get(PointerByReference pool);
	/**
	 * Return the flags which specify extensions supported by the CPU.<br>
	 * The returned value is affected by av_force_cpu_flags() if that was used<br>
	 * before. So av_get_cpu_flags() can easily be used in a application to<br>
	 * detect the enabled cpu flags.<br>
	 * Original signature : <code>int av_get_cpu_flags()</code><br>
	 * <i>native declaration : libavutil/cpu.h:7</i>
	 */
	int av_get_cpu_flags();
	/**
	 * Disables cpu detection and forces the specified flags.<br>
	 * -1 is a special case that disables forcing of specific flags.<br>
	 * Original signature : <code>void av_force_cpu_flags(int)</code><br>
	 * <i>native declaration : libavutil/cpu.h:13</i>
	 */
	void av_force_cpu_flags(int flags);
	/**
	 * Set a mask on flags returned by av_get_cpu_flags().<br>
	 * This function is mainly useful for testing.<br>
	 * Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible<br>
	 * * @warning this function is not thread safe.<br>
	 * Original signature : <code>void av_set_cpu_flags_mask(int)</code><br>
	 * <i>native declaration : libavutil/cpu.h:21</i>
	 */
	void av_set_cpu_flags_mask(int mask);
	/**
	 * Original signature : <code>int av_parse_cpu_flags(const char*)</code><br>
	 * <i>native declaration : libavutil/cpu.h:23</i><br>
	 * @deprecated use the safer methods {@link #av_parse_cpu_flags(java.lang.String)} and {@link #av_parse_cpu_flags(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_parse_cpu_flags(Pointer s);
	/**
	 * Original signature : <code>int av_parse_cpu_flags(const char*)</code><br>
	 * <i>native declaration : libavutil/cpu.h:23</i>
	 */
	int av_parse_cpu_flags(String s);
	/**
	 * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.<br>
	 * * @return negative on error.<br>
	 * Original signature : <code>int av_parse_cpu_caps(unsigned*, const char*)</code><br>
	 * <i>native declaration : libavutil/cpu.h:29</i><br>
	 * @deprecated use the safer methods {@link #av_parse_cpu_caps(java.nio.IntBuffer, java.lang.String)} and {@link #av_parse_cpu_caps(com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int av_parse_cpu_caps(IntByReference flags, Pointer s);
	/**
	 * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.<br>
	 * * @return negative on error.<br>
	 * Original signature : <code>int av_parse_cpu_caps(unsigned*, const char*)</code><br>
	 * <i>native declaration : libavutil/cpu.h:29</i>
	 */
	int av_parse_cpu_caps(IntBuffer flags, String s);
	/**
	 * @return the number of logical CPU cores present.<br>
	 * Original signature : <code>int av_cpu_count()</code><br>
	 * <i>native declaration : libavutil/cpu.h:34</i>
	 */
	int av_cpu_count();
	/**
	 * The following CPU-specific functions shall not be called directly.<br>
	 * Original signature : <code>int ff_get_cpu_flags_arm()</code><br>
	 * <i>native declaration : libavutil/cpu.h:39</i>
	 */
	int ff_get_cpu_flags_arm();
	/**
	 * Original signature : <code>int ff_get_cpu_flags_ppc()</code><br>
	 * <i>native declaration : libavutil/cpu.h:41</i>
	 */
	int ff_get_cpu_flags_ppc();
	/**
	 * Original signature : <code>int ff_get_cpu_flags_x86()</code><br>
	 * <i>native declaration : libavutil/cpu.h:43</i>
	 */
	int ff_get_cpu_flags_x86();
	/**
	 * Return a channel layout id that matches name, or 0 if no match is found.<br>
	 * * name can be one or several of the following notations,<br>
	 * separated by '+' or '|':<br>
	 * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,<br>
	 *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);<br>
	 * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,<br>
	 *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);<br>
	 * - a number of channels, in decimal, optionally followed by 'c', yielding<br>
	 *   the default channel layout for that number of channels (@see<br>
	 *   av_get_default_channel_layout);<br>
	 * - a channel layout mask, in hexadecimal starting with "0x" (see the<br>
	 *   AV_CH_* macros).<br>
	 * * Example: "stereo+FC" = "2+FC" = "2c+1c" = "0x7"<br>
	 * Original signature : <code>uint64_t av_get_channel_layout(const char*)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:22</i><br>
	 * @deprecated use the safer methods {@link #av_get_channel_layout(java.lang.String)} and {@link #av_get_channel_layout(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	long av_get_channel_layout(Pointer name);
	/**
	 * Return a channel layout id that matches name, or 0 if no match is found.<br>
	 * * name can be one or several of the following notations,<br>
	 * separated by '+' or '|':<br>
	 * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,<br>
	 *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);<br>
	 * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,<br>
	 *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);<br>
	 * - a number of channels, in decimal, optionally followed by 'c', yielding<br>
	 *   the default channel layout for that number of channels (@see<br>
	 *   av_get_default_channel_layout);<br>
	 * - a channel layout mask, in hexadecimal starting with "0x" (see the<br>
	 *   AV_CH_* macros).<br>
	 * * Example: "stereo+FC" = "2+FC" = "2c+1c" = "0x7"<br>
	 * Original signature : <code>uint64_t av_get_channel_layout(const char*)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:22</i>
	 */
	long av_get_channel_layout(String name);
	/**
	 * Return a description of a channel layout.<br>
	 * If nb_channels is <= 0, it is guessed from the channel_layout.<br>
	 * * @param buf put here the string containing the channel layout<br>
	 * @param buf_size size in bytes of the buffer<br>
	 * Original signature : <code>void av_get_channel_layout_string(char*, int, int, uint64_t)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:30</i><br>
	 * @deprecated use the safer methods {@link #av_get_channel_layout_string(java.nio.ByteBuffer, int, int, long)} and {@link #av_get_channel_layout_string(com.sun.jna.Pointer, int, int, long)} instead
	 */
	@Deprecated 
	void av_get_channel_layout_string(Pointer buf, int buf_size, int nb_channels, long channel_layout);
	/**
	 * Return a description of a channel layout.<br>
	 * If nb_channels is <= 0, it is guessed from the channel_layout.<br>
	 * * @param buf put here the string containing the channel layout<br>
	 * @param buf_size size in bytes of the buffer<br>
	 * Original signature : <code>void av_get_channel_layout_string(char*, int, int, uint64_t)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:30</i>
	 */
	void av_get_channel_layout_string(ByteBuffer buf, int buf_size, int nb_channels, long channel_layout);
	/**
	 * Append a description of a channel layout to a bprint buffer.<br>
	 * Original signature : <code>void av_bprint_channel_layout(AVBPrint*, int, uint64_t)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:36</i>
	 */
	void av_bprint_channel_layout(AvutilLibrary.AVBPrint bp, int nb_channels, long channel_layout);
	/**
	 * Return the number of channels in the channel layout.<br>
	 * Original signature : <code>int av_get_channel_layout_nb_channels(uint64_t)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:41</i>
	 */
	int av_get_channel_layout_nb_channels(long channel_layout);
	/**
	 * Return default channel layout for a given number of channels.<br>
	 * Original signature : <code>int64_t av_get_default_channel_layout(int)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:46</i>
	 */
	long av_get_default_channel_layout(int nb_channels);
	/**
	 * Get the index of a channel in channel_layout.<br>
	 * * @param channel a channel layout describing exactly one channel which must be<br>
	 *                present in channel_layout.<br>
	 * * @return index of channel in channel_layout on success, a negative AVERROR<br>
	 *         on error.<br>
	 * Original signature : <code>int av_get_channel_layout_channel_index(uint64_t, uint64_t)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:55</i>
	 */
	int av_get_channel_layout_channel_index(long channel_layout, long channel);
	/**
	 * Get the channel with the given index in channel_layout.<br>
	 * Original signature : <code>uint64_t av_channel_layout_extract_channel(uint64_t, int)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:60</i>
	 */
	long av_channel_layout_extract_channel(long channel_layout, int index);
	/**
	 * Get the name of a given channel.<br>
	 * * @return channel name on success, NULL on error.<br>
	 * Original signature : <code>char* av_get_channel_name(uint64_t)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:66</i>
	 */
	String av_get_channel_name(long channel);
	/**
	 * Get the description of a given channel.<br>
	 * * @param channel  a channel layout with a single channel<br>
	 * @return  channel description on success, NULL on error<br>
	 * Original signature : <code>char* av_get_channel_description(uint64_t)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:73</i>
	 */
	String av_get_channel_description(long channel);
	/**
	 * Get the value and name of a standard channel layout.<br>
	 * * @param[in]  index   index in an internal list, starting at 0<br>
	 * @param[out] layout  channel layout mask<br>
	 * @param[out] name    name of the layout<br>
	 * @return  0  if the layout exists,<br>
	 *          <0 if index is beyond the limits<br>
	 * Original signature : <code>int av_get_standard_channel_layout(unsigned, uint64_t*, const char**)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:83</i><br>
	 * @deprecated use the safer methods {@link #av_get_standard_channel_layout(int, java.nio.LongBuffer, java.lang.String[])} and {@link #av_get_standard_channel_layout(int, com.sun.jna.ptr.LongByReference, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int av_get_standard_channel_layout(int index, LongByReference layout, PointerByReference name);
	/**
	 * Get the value and name of a standard channel layout.<br>
	 * * @param[in]  index   index in an internal list, starting at 0<br>
	 * @param[out] layout  channel layout mask<br>
	 * @param[out] name    name of the layout<br>
	 * @return  0  if the layout exists,<br>
	 *          <0 if index is beyond the limits<br>
	 * Original signature : <code>int av_get_standard_channel_layout(unsigned, uint64_t*, const char**)</code><br>
	 * <i>native declaration : libavutil/channel_layout.h:83</i>
	 */
	int av_get_standard_channel_layout(int index, LongBuffer layout, String name[]);
	/**
	 * Get a dictionary entry with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found entry or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:13</i><br>
	 * @deprecated use the safer methods {@link #av_dict_get(com.sun.jna.ptr.PointerByReference, java.lang.String, wrapffmpeg.AVDictionaryEntry, int)} and {@link #av_dict_get(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, wrapffmpeg.AVDictionaryEntry, int)} instead
	 */
	@Deprecated 
	AVDictionaryEntry av_dict_get(Pointer m, Pointer key, AVDictionaryEntry prev, int flags);
	/**
	 * Get a dictionary entry with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found entry or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:13</i>
	 */
	AVDictionaryEntry av_dict_get(PointerByReference m, String key, AVDictionaryEntry prev, int flags);
	/**
	 * Get a dictionary entry with matching key.<br>
	 * * @param prev Set to the previous matching element to find the next.<br>
	 *             If set to NULL the first matching element is returned.<br>
	 * @param flags Allows case as well as suffix-insensitive comparisons.<br>
	 * @return Found entry or NULL, changing key or value leads to undefined behavior.<br>
	 * Original signature : <code>AVDictionaryEntry* av_dict_get(AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:13</i>
	 */
	AVDictionaryEntry av_dict_get(PointerByReference m, Pointer key, AVDictionaryEntry prev, int flags);
	/**
	 * Get number of entries in dictionary.<br>
	 * * @param m dictionary<br>
	 * @return  number of entries in dictionary<br>
	 * Original signature : <code>int av_dict_count(const AVDictionary*)</code><br>
	 * <i>native declaration : libavutil/dict.h:20</i><br>
	 * @deprecated use the safer method {@link #av_dict_count(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int av_dict_count(Pointer m);
	/**
	 * Get number of entries in dictionary.<br>
	 * * @param m dictionary<br>
	 * @return  number of entries in dictionary<br>
	 * Original signature : <code>int av_dict_count(const AVDictionary*)</code><br>
	 * <i>native declaration : libavutil/dict.h:20</i>
	 */
	int av_dict_count(PointerByReference m);
	/**
	 * Set the given entry in *pm, overwriting an existing entry.<br>
	 * * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
	 * a dictionary struct is allocated and put in *pm.<br>
	 * @param key entry key to add to *pm (will be av_strduped depending on flags)<br>
	 * @param value entry value to add to *pm (will be av_strduped depending on flags).<br>
	 *        Passing a NULL value will cause an existing entry to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:31</i><br>
	 * @deprecated use the safer methods {@link #av_dict_set(com.sun.jna.ptr.PointerByReference, java.lang.String, java.lang.String, int)} and {@link #av_dict_set(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_dict_set(PointerByReference pm, Pointer key, Pointer value, int flags);
	/**
	 * Set the given entry in *pm, overwriting an existing entry.<br>
	 * * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
	 * a dictionary struct is allocated and put in *pm.<br>
	 * @param key entry key to add to *pm (will be av_strduped depending on flags)<br>
	 * @param value entry value to add to *pm (will be av_strduped depending on flags).<br>
	 *        Passing a NULL value will cause an existing entry to be deleted.<br>
	 * @return >= 0 on success otherwise an error code <0<br>
	 * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:31</i>
	 */
	int av_dict_set(PointerByReference pm, String key, String value, int flags);
	/**
	 * Parse the key/value pairs list and add to a dictionary.<br>
	 * * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other<br>
	 * @param flags        flags to use when adding to dictionary.<br>
	 *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL<br>
	 *                     are ignored since the key/value tokens will always<br>
	 *                     be duplicated.<br>
	 * @return             0 on success, negative AVERROR code on failure<br>
	 * Original signature : <code>int av_dict_parse_string(AVDictionary**, const char*, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:45</i><br>
	 * @deprecated use the safer methods {@link #av_dict_parse_string(com.sun.jna.ptr.PointerByReference, java.lang.String, java.lang.String, java.lang.String, int)} and {@link #av_dict_parse_string(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	int av_dict_parse_string(PointerByReference pm, Pointer str, Pointer key_val_sep, Pointer pairs_sep, int flags);
	/**
	 * Parse the key/value pairs list and add to a dictionary.<br>
	 * * @param key_val_sep  a 0-terminated list of characters used to separate<br>
	 *                     key from value<br>
	 * @param pairs_sep    a 0-terminated list of characters used to separate<br>
	 *                     two pairs from each other<br>
	 * @param flags        flags to use when adding to dictionary.<br>
	 *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL<br>
	 *                     are ignored since the key/value tokens will always<br>
	 *                     be duplicated.<br>
	 * @return             0 on success, negative AVERROR code on failure<br>
	 * Original signature : <code>int av_dict_parse_string(AVDictionary**, const char*, const char*, const char*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:45</i>
	 */
	int av_dict_parse_string(PointerByReference pm, String str, String key_val_sep, String pairs_sep, int flags);
	/**
	 * Copy entries from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting entries in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * Original signature : <code>void av_dict_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:55</i><br>
	 * @deprecated use the safer method {@link #av_dict_copy(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	void av_dict_copy(PointerByReference dst, Pointer src, int flags);
	/**
	 * Copy entries from one AVDictionary struct into another.<br>
	 * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
	 *            this function will allocate a struct for you and put it in *dst<br>
	 * @param src pointer to source AVDictionary struct<br>
	 * @param flags flags to use when setting entries in *dst<br>
	 * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
	 * Original signature : <code>void av_dict_copy(AVDictionary**, AVDictionary*, int)</code><br>
	 * <i>native declaration : libavutil/dict.h:55</i>
	 */
	void av_dict_copy(PointerByReference dst, PointerByReference src, int flags);
	/**
	 * Free all the memory allocated for an AVDictionary struct<br>
	 * and all keys and values.<br>
	 * Original signature : <code>void av_dict_free(AVDictionary**)</code><br>
	 * <i>native declaration : libavutil/dict.h:61</i>
	 */
	void av_dict_free(PointerByReference m);
	/**
	 * Accessors for some AVFrame fields.<br>
	 * The position of these field in the structure is not part of the ABI,<br>
	 * they should not be accessed directly outside libavcodec.<br>
	 * Original signature : <code>int64_t av_frame_get_best_effort_timestamp(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:292</i>
	 */
	long av_frame_get_best_effort_timestamp(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_best_effort_timestamp(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil/frame.h:294</i>
	 */
	void av_frame_set_best_effort_timestamp(AVFrame frame, long val);
	/**
	 * Original signature : <code>int64_t av_frame_get_pkt_duration(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:296</i>
	 */
	long av_frame_get_pkt_duration(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_pkt_duration(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil/frame.h:298</i>
	 */
	void av_frame_set_pkt_duration(AVFrame frame, long val);
	/**
	 * Original signature : <code>int64_t av_frame_get_pkt_pos(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:300</i>
	 */
	long av_frame_get_pkt_pos(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_pkt_pos(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil/frame.h:302</i>
	 */
	void av_frame_set_pkt_pos(AVFrame frame, long val);
	/**
	 * Original signature : <code>int64_t av_frame_get_channel_layout(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:304</i>
	 */
	long av_frame_get_channel_layout(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_channel_layout(AVFrame*, int64_t)</code><br>
	 * <i>native declaration : libavutil/frame.h:306</i>
	 */
	void av_frame_set_channel_layout(AVFrame frame, long val);
	/**
	 * Original signature : <code>int av_frame_get_channels(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:308</i>
	 */
	int av_frame_get_channels(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_channels(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:310</i>
	 */
	void av_frame_set_channels(AVFrame frame, int val);
	/**
	 * Original signature : <code>int av_frame_get_sample_rate(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:312</i>
	 */
	int av_frame_get_sample_rate(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_sample_rate(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:314</i>
	 */
	void av_frame_set_sample_rate(AVFrame frame, int val);
	/**
	 * Original signature : <code>AVDictionary* av_frame_get_metadata(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:316</i>
	 */
	PointerByReference av_frame_get_metadata(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_metadata(AVFrame*, AVDictionary*)</code><br>
	 * <i>native declaration : libavutil/frame.h:318</i><br>
	 * @deprecated use the safer method {@link #av_frame_set_metadata(wrapffmpeg.AVFrame, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	void av_frame_set_metadata(AVFrame frame, Pointer val);
	/**
	 * Original signature : <code>void av_frame_set_metadata(AVFrame*, AVDictionary*)</code><br>
	 * <i>native declaration : libavutil/frame.h:318</i>
	 */
	void av_frame_set_metadata(AVFrame frame, PointerByReference val);
	/**
	 * Original signature : <code>int av_frame_get_decode_error_flags(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:320</i>
	 */
	int av_frame_get_decode_error_flags(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_decode_error_flags(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:322</i>
	 */
	void av_frame_set_decode_error_flags(AVFrame frame, int val);
	/**
	 * Original signature : <code>int av_frame_get_pkt_size(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:324</i>
	 */
	int av_frame_get_pkt_size(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_pkt_size(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:326</i>
	 */
	void av_frame_set_pkt_size(AVFrame frame, int val);
	/**
	 * Original signature : <code>AVDictionary** avpriv_frame_get_metadatap(AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:328</i>
	 */
	PointerByReference avpriv_frame_get_metadatap(AVFrame frame);
	/**
	 * Original signature : <code>int8_t* av_frame_get_qp_table(AVFrame*, int*, int*)</code><br>
	 * <i>native declaration : libavutil/frame.h:330</i><br>
	 * @deprecated use the safer methods {@link #av_frame_get_qp_table(wrapffmpeg.AVFrame, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #av_frame_get_qp_table(wrapffmpeg.AVFrame, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	Pointer av_frame_get_qp_table(AVFrame f, IntByReference stride, IntByReference type);
	/**
	 * Original signature : <code>int8_t* av_frame_get_qp_table(AVFrame*, int*, int*)</code><br>
	 * <i>native declaration : libavutil/frame.h:330</i>
	 */
	Pointer av_frame_get_qp_table(AVFrame f, IntBuffer stride, IntBuffer type);
	/**
	 * Original signature : <code>int av_frame_set_qp_table(AVFrame*, AVBufferRef*, int, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:332</i>
	 */
	int av_frame_set_qp_table(AVFrame f, AVBufferRef buf, int stride, int type);
	/**
	 * Original signature : <code>AVColorSpace av_frame_get_colorspace(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:334</i>
	 */
	int av_frame_get_colorspace(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_colorspace(AVFrame*, AVColorSpace)</code><br>
	 * <i>native declaration : libavutil/frame.h:336</i>
	 */
	void av_frame_set_colorspace(AVFrame frame, int val);
	/**
	 * Original signature : <code>AVColorRange av_frame_get_color_range(const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:338</i>
	 */
	int av_frame_get_color_range(AVFrame frame);
	/**
	 * Original signature : <code>void av_frame_set_color_range(AVFrame*, AVColorRange)</code><br>
	 * <i>native declaration : libavutil/frame.h:340</i>
	 */
	void av_frame_set_color_range(AVFrame frame, int val);
	/**
	 * Allocate an AVFrame and set its fields to default values.  The resulting<br>
	 * struct must be freed using av_frame_free().<br>
	 * * @return An AVFrame filled with default values or NULL on failure.<br>
	 * * @note this only allocates the AVFrame itself, not the data buffers. Those<br>
	 * must be allocated through other means, e.g. with av_frame_get_buffer() or<br>
	 * manually.<br>
	 * Original signature : <code>AVFrame* av_frame_alloc()</code><br>
	 * <i>native declaration : libavutil/frame.h:350</i>
	 */
	AVFrame av_frame_alloc();
	/**
	 * Free the frame and any dynamically allocated objects in it,<br>
	 * e.g. extended_data. If the frame is reference counted, it will be<br>
	 * unreferenced first.<br>
	 * * @param frame frame to be freed. The pointer will be set to NULL.<br>
	 * Original signature : <code>void av_frame_free(AVFrame**)</code><br>
	 * <i>native declaration : libavutil/frame.h:358</i><br>
	 * @deprecated use the safer method {@link #av_frame_free(wrapffmpeg.AVFrame.ByReference[])} instead
	 */
	@Deprecated 
	void av_frame_free(PointerByReference frame);
	/**
	 * Free the frame and any dynamically allocated objects in it,<br>
	 * e.g. extended_data. If the frame is reference counted, it will be<br>
	 * unreferenced first.<br>
	 * * @param frame frame to be freed. The pointer will be set to NULL.<br>
	 * Original signature : <code>void av_frame_free(AVFrame**)</code><br>
	 * <i>native declaration : libavutil/frame.h:358</i>
	 */
	void av_frame_free(AVFrame.ByReference frame[]);
	/**
	 * Setup a new reference to the data described by a given frame.<br>
	 * * Copy frame properties from src to dst and create a new reference for each<br>
	 * AVBufferRef from src.<br>
	 * * If src is not reference counted, new buffers are allocated and the data is<br>
	 * copied.<br>
	 * * @return 0 on success, a negative AVERROR on error<br>
	 * Original signature : <code>int av_frame_ref(AVFrame*, AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:368</i>
	 */
	int av_frame_ref(AVFrame dst, AVFrame src);
	/**
	 * Create a new frame that references the same data as src.<br>
	 * * This is a shortcut for av_frame_alloc()+av_frame_ref().<br>
	 * * @return newly created AVFrame on success, NULL on error.<br>
	 * Original signature : <code>AVFrame* av_frame_clone(AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:375</i>
	 */
	AVFrame av_frame_clone(AVFrame src);
	/**
	 * Unreference all the buffers referenced by frame and reset the frame fields.<br>
	 * Original signature : <code>void av_frame_unref(AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:380</i>
	 */
	void av_frame_unref(AVFrame frame);
	/**
	 * Move everythnig contained in src to dst and reset src.<br>
	 * Original signature : <code>void av_frame_move_ref(AVFrame*, AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:385</i>
	 */
	void av_frame_move_ref(AVFrame dst, AVFrame src);
	/**
	 * Allocate new buffer(s) for audio or video data.<br>
	 * * The following fields must be set on frame before calling this function:<br>
	 * - format (pixel format for video, sample format for audio)<br>
	 * - width and height for video<br>
	 * - nb_samples and channel_layout for audio<br>
	 * * This function will fill AVFrame.data and AVFrame.buf arrays and, if<br>
	 * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.<br>
	 * For planar formats, one buffer will be allocated for each plane.<br>
	 * * @param frame frame in which to store the new buffers.<br>
	 * @param align required buffer size alignment<br>
	 * * @return 0 on success, a negative AVERROR on error.<br>
	 * Original signature : <code>int av_frame_get_buffer(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:400</i>
	 */
	int av_frame_get_buffer(AVFrame frame, int align);
	/**
	 * Check if the frame data is writable.<br>
	 * * @return A positive value if the frame data is writable (which is true if and<br>
	 * only if each of the underlying buffers has only one reference, namely the one<br>
	 * stored in this frame). Return 0 otherwise.<br>
	 * * If 1 is returned the answer is valid until av_buffer_ref() is called on any<br>
	 * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).<br>
	 * * @see av_frame_make_writable(), av_buffer_is_writable()<br>
	 * Original signature : <code>int av_frame_is_writable(AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:411</i>
	 */
	int av_frame_is_writable(AVFrame frame);
	/**
	 * Ensure that the frame data is writable, avoiding data copy if possible.<br>
	 * * Do nothing if the frame is writable, allocate new buffers and copy the data<br>
	 * if it is not.<br>
	 * * @return 0 on success, a negative AVERROR on error.<br>
	 * * @see av_frame_is_writable(), av_buffer_is_writable(),<br>
	 * av_buffer_make_writable()<br>
	 * Original signature : <code>int av_frame_make_writable(AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:421</i>
	 */
	int av_frame_make_writable(AVFrame frame);
	/**
	 * Copy only "metadata" fields from src to dst.<br>
	 * * Metadata for the purpose of this function are those fields that do not affect<br>
	 * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample<br>
	 * aspect ratio (for video), but not width/height or channel layout.<br>
	 * Side data is also copied.<br>
	 * Original signature : <code>int av_frame_copy_props(AVFrame*, const AVFrame*)</code><br>
	 * <i>native declaration : libavutil/frame.h:430</i>
	 */
	int av_frame_copy_props(AVFrame dst, AVFrame src);
	/**
	 * Get the buffer reference a given data plane is stored in.<br>
	 * * @param plane index of the data plane of interest in frame->extended_data.<br>
	 * * @return the buffer reference that contains the plane or NULL if the input<br>
	 * frame is not valid.<br>
	 * Original signature : <code>AVBufferRef* av_frame_get_plane_buffer(AVFrame*, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:438</i>
	 */
	AVBufferRef av_frame_get_plane_buffer(AVFrame frame, int plane);
	/**
	 * Add a new side data to a frame.<br>
	 * * @param frame a frame to which the side data should be added<br>
	 * @param type type of the added side data<br>
	 * @param size size of the side data<br>
	 * * @return newly added side data on success, NULL on error<br>
	 * Original signature : <code>AVFrameSideData* av_frame_new_side_data(AVFrame*, AVFrameSideDataType, int)</code><br>
	 * <i>native declaration : libavutil/frame.h:447</i>
	 */
	AVFrameSideData av_frame_new_side_data(AVFrame frame, int type, int size);
	/**
	 * @return a pointer to the side data of a given type on success, NULL if there<br>
	 * is no side data with such type in this frame.<br>
	 * Original signature : <code>AVFrameSideData* av_frame_get_side_data(const AVFrame*, AVFrameSideDataType)</code><br>
	 * <i>native declaration : libavutil/frame.h:453</i>
	 */
	AVFrameSideData av_frame_get_side_data(AVFrame frame, int type);
	public static final class av_reverse {
		private static Pointer av_reverse;
		public static synchronized Pointer get() {
			if ((av_reverse == null)) 
				av_reverse = AvutilLibrary.JNA_NATIVE_LIB.getGlobalVariableAddress("av_reverse");
			return av_reverse;
		}
	};
	public static class AVBuffer extends PointerType {
		public AVBuffer(Pointer address) {
			super(address);
		}
		public AVBuffer() {
			super();
		}
	};
	public static class AVBPrint extends PointerType {
		public AVBPrint(Pointer address) {
			super(address);
		}
		public AVBPrint() {
			super();
		}
	};
	public static class va_list extends PointerType {
		public va_list(Pointer address) {
			super(address);
		}
		public va_list() {
			super();
		}
	};
	public static class AVBufferPool extends PointerType {
		public AVBufferPool(Pointer address) {
			super(address);
		}
		public AVBufferPool() {
			super();
		}
	};
	public static class AVDictionary extends PointerType {
		public AVDictionary(Pointer address) {
			super(address);
		}
		public AVDictionary() {
			super();
		}
	};
	public static class AVOption extends PointerType {
		public AVOption(Pointer address) {
			super(address);
		}
		public AVOption() {
			super();
		}
	};
}
